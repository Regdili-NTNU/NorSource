
;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;

;;;              - NorSource -
;;; 
;;;    Copyright (c)  NorSource version 1.0
;;;
;;;                     2014-2021
;;;
;;;            Lars Hellan and Tore Bruland
;;;
;;;			2010-2014
;;;
;;;    Lars Hellan, Mads H. Sand√∏y, Elias Aamot, Tore Bruland
;;;                         and
;;;                      Dan Flickinger
;;;                       
;;;
;;;            Earlier developments: 
;;;            2004-2008 Lars Hellan, Dorothee Beermann, Ben Waldron
;;;            2001-2003 Lars Hellan, Petter Haugereid
;;;    
;;;
;;;    Started at:
;;;    Norwegian University of Science and Technology, 7491 Trondheim
;;;    ==================================================================
;;; 
;;;    
;;;                   norsk.tdl
;
;;;              Basic definitions of types
;;;
;;;           based on HPSG Grammar Matrix 0.6

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
 adv-particle-word
dir-fixpoint-prep-2-word
dir-fixpoint-prep-word
dir-nonfixpoint-prep-2-word
dir-nonfixpoint-prep-word
dir-prep-p-adv-word  p
prep-modadvreg-word  p
prep-p-adv-word-reg  p
prep-word-reg
tel-fix-nondelim-prep-word
tel-fix-path-atelic-prep-word
tel-fix-pathtelic-prep-word
time-prep-word
|#

;;  ORDER OF PRESENTATION:

;; 1. Relation types
;; 2. Specifications under HOOK
;;   a. dirhook - - DIRARG
;;   b. augm-ref-ind - - BOUNDED
;;   c. PNG values
;;   d. SORT values for nouns
;;   e. SORT values for verbs
;;   f. TENSE and MOOD values
;; 3. HEAD values
;; 4. Basic lex-item types
;; 5. WORD types
;; 6. LEXEME types
;; 7. PHRASE types
;; 8. SYNSEM types
;; 9. VAL, QVAL and CAT types
;; 10. Lexical rules, for Passive, V-to-A, A-to-N, Q-to-N,... 


;;;;;;; DPF addenda



sign-min :+
  [ STEM orthog ].

word-or-lexrule :+
  [ STEM.FORM #form,
    TOKENS tokens & [ +LIST < [ +FORM #form ], ... > ] ].

orthog := cons &
  [ FORM string,
    FROM string,
    TO string ].

never_unify_lr := lex-rule &
  [ INFLECTED -,
    STEM < "_never_unify" >,
    SYNSEM.LOCAL.CAT.HEAD no-head,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD no-head,
	     INFLECTED + ] > ].
 
no-head := head.

;;;;;;; 1. Relation types

def-q-rel := quant-relation &
 [PRED "_def_q_rel"].

indef-q-rel := quant-relation.

plurindef-q-rel := quant-relation &
 [PRED "_plurindef_q_rel"].

contextual-q-rel := quant-relation &
 [PRED "_pronoun_q_rel"].

reflexive-q-rel := quant-relation &
 [PRED "_reflpronoun_q_rel"].

interrog-q-rel := quant-relation.
; &
; [PRED "_interrog_q_rel"].

expletive-q-rel := quant-relation-sup &
 [PRED "_expletive_q_rel"].

card-relation := const-relation &
  [ PRED "_card_rel" ].

card-arg1-relation := card-relation & arg1-relation.

adj_rel := ad-rel & arg1-relation.
; for comparative-roles - but it created problems...
;adj_rel := ad-rel & arg1-relation &
; [ ARG0.ROLE #1,
;   ARG1.ROLE #1 ].
adj0_rel := ad-rel.
adjObl_rel := adj_rel & obl-ad-relation.
obl-ad-relation := ad-rel &
  [ ARGOBLad semarg ].

familiar-rel := noun-relation & [ PRED "_familiar_c_rel"].
asserted-id-rel := arg1-relation &
  [ PRED "_asserted_id_rel" ].
familiarity-rel := arg1-relation &
  [ PRED "_familiar_c_rel" ].

fpos_prom_rel := arg1-relation &
[ PRED "first_position_prominent"].

  
deictic-rel := arg1-relation.
rel-pron_rel := arg1-relation.
pron_rel := noun-relation.

pers-pron-rel := pron_rel.
res-pron-rel := pron_rel &
  [ PRED "_res_pron_rel" ].
;rel_pron_rel := pron_rel &
;  [ PRED "_rel_pron_rel" ].
rel_pron_rel := noun-arg1-relation &
  [ PRED "_rel_pron_rel" ].
vp-rel_pron_rel := event-relation &
  [ PRED "_rel_pron_rel" ].

#|
1st-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS firstpers ].
1st-sg-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_1sg_pron_rel" ].
1st-pl-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_1pl_pron_rel" ].

2nd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS secpers ].
2nd-sg-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_2sg_pron_rel" ].
2nd-pl-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_2pl_pron_rel" ].

3rd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS thirdpers ].
3rd-sg-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3sg_pron_rel",
   ARG0.PNG 3sg ].
3rd-pl-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3pl_pron_rel",
   ARG0.PNG 3pl ].
3rd-wh-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3wh_pron_rel" ].
|#

1st-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS firstpers ].
1st-sg-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_1sg-pron_rel" ].
1st-pl-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_1pl-pron_rel" ].

2nd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS secpers ].
2nd-sg-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_2sg-pron_rel" ].
2nd-pl-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_2pl-pron_rel" ].

3rd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS thirdpers ].
3rd-sg-pers-pron-rel := 3rd-pers-pron-rel &
  [;PRED "_3sg-pron_rel",
   ARG0.PNG 3sg ].
3rd-pl-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3pl-pron_rel",
   ARG0.PNG 3pl ].
3rd-wh-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3wh-pron_rel" ].

3rd-rel-pron-rel := rel_pron_rel &
  [ ARG0.PNG.PERS thirdpers ].

refl-pron-rel := pron_rel.

1st-refl-pron-rel := refl-pron-rel &
  [ARG0.PNG.PERS firstpers].
1st-sg-refl-pron-rel := 1st-refl-pron-rel &
  [PRED "_1sg_refl_rel"].
1st-pl-refl-pron-rel := 1st-refl-pron-rel &
  [PRED "_1pl_refl_rel" ].

2nd-refl-pron-rel := refl-pron-rel &
  [ARG0.PNG.PERS secpers].
2nd-sg-refl-pron-rel := 2nd-refl-pron-rel &
  [PRED "_2sg_refl_rel" ].
2nd-pl-refl-pron-rel := 2nd-refl-pron-rel &
  [PRED "_2pl_refl_rel" ].

3rd-refl-pron-rel := refl-pron-rel &
  [PRED "_3p_refl_rel",
   ARG0.PNG.PERS thirdpers ].

same-rel := arg1-relation &
  [PRED "_same-as-mntd_rel" ].

context_understood_pron_rel := pron_rel &
  [ PRED "zero_pron_context_corr_rel" ].

partitive-rel := arg12-relation &
  [ PRED "_member-of-set_rel",
    ARG0 individual,
    ARG1 ref-ind,
    ARG2 ref-ind ].

reside-in-rel := arg12-relation &
  [ PRED "_reside-in_c_rel",
    ARG0 individual,
    ARG1 individual,
    ARG2 individual ].

;partitive-ersatz-rel := arg65-rel &
;  [ PRED "_instantiate_c_rel" ].

poss-rel := arg12-ev-relation &
  [ PRED "_possess_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

possessed-by-rel := prep-mod-relation &
  [ ARG1 ref-ind,
    ARG2 ref-ind ].

related-rel := arg12-ev-relation &
  [ PRED "_related_to_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

measure-out-rel := arg12-relation &
  [ PRED "_measure_out_rel",
    ARG1 individual & [ ROLE #1 ],
    ARG2 individual & [ ROLE #1 ] ].

accumulate-rel := arg12-relation &
  [ PRED "_accumulate-unit-subunit_rel",
    ARG1 handle,
    ARG2 handle ].

compound-rel := arg12-relation &
  [ PRED "_compound_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

compare-rel := arg12-relation &
  [ ARG1 individual & [ ROLE compare-top ],
    ARG2 individual & [ ROLE compare-ref ]].

cntxt-prpt-rel := arg1-relation &
  [ ARG1 ref-ind & [SORT cntxt-given ]].

title-of-rel := arg12-relation &
  [ PRED "_title-of_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].


agent-rel := arg12-ev-relation &
  [ PRED "_agent_of_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

undergoer-rel := arg12-ev-relation &
  [ PRED "_undergoer_of_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

conj-q-rel := quant-relation &
  [ PRED "_conjoined_q_rel" ].

conj-q-ev-rel := quant-event-relation &
  [ PRED "_conjoined_q_rel" ].
;conj-q-ev-rel := quant-event-relation.

argx-relation := event-relation &
  [ ARGX handle ].

arg2x-relation := arg12-relation & argx-relation.

arg1x-relation := arg1-relation-sup & argx-relation.

arg12x-relation := arg12-relation & argx-relation.

arg123x-relation := arg123-relation & argx-relation.

; the following were used in the "Hit and dit" Trollheim grammar
#|
place-rel := prep-mod-relation & 
  [ARG0.SORT place,
   ARG1 individual ].

externrelated-place-rel := place-rel & 
  [ARG2 ref-ind & [SORT full-thing] ].

internrelated-place-rel := place-rel &
  [ARG2 ref-ind & [SORT correlate] ].

; 'correlate' is intended as a discourse-fixed value, such as a speaker
; in 'close-to-corr' and some landmark in 'lower-than-corr'

vertical-internrelated-place-rel := internrelated-place-rel &
  [ARG2.SORT landmark ].

proxim-internrelated-place-rel := internrelated-place-rel &
  [ARG2.SORT speaker ].
|#


ad-rel := arg0-relation &
  [ ARG0 ad-event].

orient-rel := ad-rel &
  [ ARG0 orient-event].
;orient-adv-rel := orient-rel & arg1-relation & 
;  [ ARG0.SORT verb-act-specification,
;    ARG0.ORIENT orient ].
orient-adv-rel := orient-rel & arg1-relation & 
  [ ARG0.ORIENT orient ].
iarg-orient-adv-relation := iarg-relation & orient-adv-rel.

loc-rel := ad-rel.

; of use if LEGs were also operative with adverbs - currently not
;leg-rel := loc-rel &
;  [ LEG individual ].

adv-mod-relation := arg1-relation & loc-rel.

prep-mod-relation := loc-rel & arg12-relation.

; to facilitate integration with predsort

;prep-path-rel :=  loc-rel & arg12-relation &
;  [ ARG1 ref-ind,
;    ARG2 ref-ind,
;    LEG individual].

prep-line-rel :=  loc-rel & arg12-relation.
prep-fixpoint-line-rel := prep-line-rel &
  [ ARG0.SORT fix-point-motion ].
prep-nonfixpoint-line-rel := prep-line-rel &
  [ ARG0.SORT non-fix-point ].

; this ARG0 specification makes visible both for adverbs like "hit" and
; PPs like "til skogen" that they have a property inducing telicity.
; No subtype of 'prep-path-rel' fixes a PRED value, since in principle, we want
 ; a lexical item to be able to fill in this value itself, as when the item 
; is a preposition. 

end-of-path-rel := prep-fixpoint-line-rel &
  [ ARG0.SORT end-of-path-motion,
    ARG2.SORT endpnt-of-path ].
beginning-of-path-rel := prep-fixpoint-line-rel &
  [ ARG2.SORT startpnt-of-path ].
via-path-rel := prep-fixpoint-line-rel &
  [ ARG2.SORT via-pnt-of-path ].
along-path-rel := prep-nonfixpoint-line-rel &
  [ ARG0.SORT along-path-motion,
    ARG2.SORT path-followed ].

obl-relation := event-relation &
  [ ARGOBLQ semarg ].
obl2-relation := obl-relation &
  [ ARGOBLQ2 semarg ].
arg0obl-rel := obl-relation.
arg1obl-rel := arg1-relation-sup & obl-relation.
arg12obl-rel := arg12-relation & obl-relation.
arg123obl-rel := arg123-relation & obl-relation.

arg0obl2-rel := arg0obl-rel & obl2-relation.
arg1obl2-rel := arg1-relation-sup & obl2-relation.
arg12obl2-rel := arg12-relation & obl2-relation.
arg123obl2-rel := arg123-relation & obl2-relation.

argxobl-rel := argx-relation & arg0obl-rel.




;;; 2. SPECIFICATIONS UNDER 'HOOK' ( SYNSEM.CONTENT.HOOK...)

; INDEX values for nouns (...HOOK.INDEX ref-ind & [PNG png /SORT semsort..].)

augm-ref-ind := ref-ind &
  [ BOUNDED bool ].

; PNG values
;; obsolete
;mascsg-sup := sg & masc.
;femsg-sup := sg & fem.
;mascsg := mascsg-sup.
;femsg := femsg-sup.
;commsg := mascsg-sup & femsg-sup.

; active
png := avm &
  [ NG ng,
    PERS pers ].
ng := avm &
 [ NUM num, GEN gen].

num := avm.
gen := avm.

pers := avm.

number := ng .
sg := number & [ NUM sing].
pl := number & [ NUM plur].
sing := num.
plur := num.

gender := ng.
; lh Dec01-06 - to avoid "absorpsjonsevnene[mascorfem] smiler" getting a parse by the neuter infl-rule, and "adelskapene[mascorneut] smiler" getting a parse by the fem infl-rule
;f := gen.
;m := gen.
;n := gen.
m-or-f := gen.
m-or-n := gen.
m := m-or-f & m-or-n.
f := m-or-f.
n := m-or-n.

neut-or-masc := gender & [ GEN m-or-n].
neut := neut-or-masc & [ GEN n].
;; [bmw] what exactly is the difference between non-neut and masc-or-fem?
;;       i've replaced references to non-neut by masc-or-fem
;;non-neut := masc & fem.
; FIXME should be neut-sg
neutsg := sg & neut.
; changed to masc-or-fem-pl [???]
;;commpl := pl & non-neut.
; FIXME should be neut-pl
neutpl := pl & neut.

masc-or-fem := gender & [ GEN m-or-f].
masc := neut-or-masc & masc-or-fem & [ GEN m].
fem := masc-or-fem & [ GEN f].

; experiment 15112018 - so far valid
masc-strict := gender & [ GEN m].
fem-strict := gender & [ GEN f].
neut-strict := gender & [ GEN n].
masc-str-sg := sg & masc-strict.
fem-str-sg := sg & fem-strict.
neut-str-sg := sg & neut-strict.

m-strict-sg-noun-word := noun-word &
 [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG masc-str-sg ]].
f-strict-sg-noun-word := noun-word &
 [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG fem-str-sg ]].
n-strict-sg-noun-word := noun-word &
 [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG neut-str-sg ]].
;;;;;;

masc-or-fem-sg := sg & masc-or-fem.
masc-or-fem-pl := pl & masc-or-fem.
masc-sg := masc & masc-or-fem-sg.
fem-sg := fem & masc-or-fem-sg.
masc-pl := masc & masc-or-fem-pl.
fem-pl := fem & masc-or-fem-pl.

first-or-second-pers := pers.
firstpers := first-or-second-pers.
secpers := first-or-second-pers.
thirdpers := pers.
1sg := png &
  [ NG sg,
    PERS firstpers ].
1pl := png &
  [ NG pl,
    PERS firstpers ].
2sg := png &
  [ NG sg,
    PERS secpers ].
2pl := png &
  [ NG pl,
    PERS secpers ].
3sg := png &
  [ NG sg,
    PERS thirdpers ].
3pl := png &
  [ NG pl,
    PERS thirdpers ].
3msg := 3sg &
  [ NG masc-sg ].
3fsg := 3sg &
  [ NG fem-sg ].
3nsg := 3sg &
  [ NG neutsg ].



; SORT values (for nouns)

; semsort-reg := semsort.(defined under SORT-verb)
item-specification := semsort-reg.
endpnt-of-path := referential-thing.
anim-endpnt-of-path := endpnt-of-path & anim-thing & full-thing.
inan-endpnt-of-path := endpnt-of-path & inan-thing & full-thing.
startpnt-of-path := referential-thing.
anim-startpnt-of-path := startpnt-of-path & anim-thing & full-thing.
inan-startpnt-of-path := startpnt-of-path & inan-thing & full-thing.
via-pnt-of-path := referential-thing.
anim-viapnt-of-path := via-pnt-of-path & anim-thing & full-thing.
inan-viapnt-of-path := via-pnt-of-path & inan-thing & full-thing.
path-followed := referential-thing.
anim-path-followed := path-followed & anim-thing & full-thing.
inan-path-followed := path-followed & inan-thing & full-thing.
anim-1dim-endpnt-of-path := endpnt-of-path & anim-thing & one-dim-thing.
inan-1dim-endpnt-of-path := endpnt-of-path & inan-thing & one-dim-thing.
anim-1dim-startpnt-of-path := startpnt-of-path & anim-thing & one-dim-thing.
inan-1dim-startpnt-of-path := startpnt-of-path & inan-thing & one-dim-thing.
anim-1dim-viapnt-of-path := via-pnt-of-path & anim-thing & one-dim-thing.
inan-1dim-viapnt-of-path := via-pnt-of-path & inan-thing & one-dim-thing.
anim-1dim-path-followed := path-followed & anim-thing & one-dim-thing.
inan-1dim-path-followed := path-followed & inan-thing & one-dim-thing.

orientation-corr := full-thing.
orientation-target := orientation-corr.
orientation-direction := orientation-corr.
target-of-orient := full-thing.
starttime-of-motion := item-specification.
measure-unit := item-specification.
path-unit := measure-item.
event-unit := measure-item.
; doubled in predsorts.tdl.
time-item := measure-unit.
measure-item := measure-unit.
length-unit := measure-item.
inner-obj-unit := length-unit & event-unit & path-unit.
weight-unit := measure-item.
volume-unit := measure-item.
amount-unit := measure-item.
;to enable "tusen og tretti" as N-coordination:
;card-unit := measure-item.
card-unit := number-unit.
;card-unit := measure-item & referential-thing.
path-as-card-unit := path-unit & card-unit.
time-as-card-unit := time-item & card-unit.
time-as-amount-unit := time-item & amount-unit.
length-as-card-unit := length-unit & card-unit.
amount-as-card-unit := amount-unit & card-unit.
anim-card-unit := card-unit & anim-thing.
inanim-card-unit := card-unit & inan-thing.
;anim-card-unit := card-unit & animfull-thing.
;inanim-card-unit := card-unit & inanfull-thing.
number-unit := measure-item.
;number-unit := measure-item & referential-thing.
path-as-number-unit := path-unit & number-unit.
time-as-number-unit := time-item & number-unit.
length-as-number-unit := length-unit & number-unit.
anim-number-unit := number-unit & anim-thing.
inanim-number-unit := number-unit & inan-thing.
;anim-number-unit := number-unit & animfull-thing.
;inanim-number-unit := number-unit & inanfull-thing.

body-part := item-specification.
relatum := referential-thing.
init-und := item-specification.
init-or-actor := init-und.
init := init-or-actor.
und-or-theme := init-und.
und := und-or-theme.
actor := init-or-actor.
theme := und-or-theme.
endtime-of-motion := item-specification.
one-dim-thing := referential-thing.
one-dim-thing-path := one-dim-thing.
one-dim-thing-vehicle := one-dim-thing.
xdim-thing := full-thing.
referential-thing := item-specification.
inher-compl := referential-thing.
full-thing := referential-thing.
anim-thing := referential-thing.
inan-thing := referential-thing.
indiv-kind := full-thing.
correlate := full-thing.
animfull-thing := full-thing & anim-thing.
inanfull-thing := full-thing & inan-thing.
anim-relatum := relatum & anim-thing.
inan-relatum := relatum & inan-thing.

anim-relatum-endpnt-of-path := anim-relatum & endpnt-of-path.
inan-relatum-endpnt-of-path := inan-relatum & endpnt-of-path.
anim-relatum-viapnt-of-path := anim-relatum & via-pnt-of-path.
inan-relatum-viapnt-of-path := inan-relatum & via-pnt-of-path.
anim-relatum-startpnt-of-path := anim-relatum & startpnt-of-path.
inan-relatum-startpnt-of-path := inan-relatum & startpnt-of-path.
anim-relatum-path-followed := anim-relatum & path-followed.
inan-relatum-path-followed := inan-relatum & path-followed.


speaker := correlate.
hearer := correlate.
landmark := correlate.
cntxt-given := correlate.


indirquest-prep := semsort-reg.



; SORT values (for verbs)

semsort-reg := semsort.
verb-act-specification := semsort-reg.
non-fix-point := verb-act-specification.
direction := verb-act-specification.
fix-point-motion := verb-act-specification.
path-related-motion := direction.
orientation := non-fix-point & direction.
end-of-path-motion := path-related-motion & fix-point-motion.
beg-of-path-motion := path-related-motion & fix-point-motion.
via-path-motion := path-related-motion & fix-point-motion.
along-path-motion := path-related-motion & non-fix-point.
place := non-fix-point.
time := non-fix-point.

telmarking := semsort.
accomplishment-time := telmarking.
duration-time := telmarking.

correlated-event := non-fix-point.

correlated-event-time := correlated-event.
correlated-event-place := correlated-event.
correlated-event-condition := correlated-event.
correlated-irrealis := correlated-event.

orientsort := avm.
orient := orientsort.
in-or-out := orient.
to-in := in-or-out.
to-out := in-or-out.
up-or-down := orient.
to-up := up-or-down.
to-down := up-or-down.
close-or-far := orient.
to-close := close-or-far.
to-far := close-or-far.
to-forth := close-or-far.
to-home := close-or-far.
ahead-or-back := orient.
to-ahead := ahead-or-back.
to-back := ahead-or-back.
at-or-awayfrom-salientpoint := orient.
to-at-salientpoint := at-or-awayfrom-salientpoint.
to-awayfrom-salientpoint := at-or-awayfrom-salientpoint.
to-right-or-left := orient.
to-right := to-right-or-left.
to-left := to-right-or-left.
to-along := orient.
in-compass-direction := orient.
to-south := in-compass-direction.
to-north := in-compass-direction.
to-east := in-compass-direction.
to-west := in-compass-direction.


place-param := place.
at-in-or-out := place-param.
at-in := at-in-or-out.
at-out := at-in-or-out.
at-up-or-down := place-param.
at-up := at-up-or-down.
at-down := at-up-or-down.
at-close-or-far := place-param.
at-close := at-close-or-far.
at-far := at-close-or-far.
at-home := at-close-or-far.
at-ahead-or-back := place-param.
at-ahead := at-ahead-or-back.
at-back := at-ahead-or-back.
at-on-or-awayfrom-salientpoint := place-param.
at-salientpoint := at-on-or-awayfrom-salientpoint.
at-awayfrom-salientpoint := at-on-or-awayfrom-salientpoint.
at-right-or-left := place-param.
at-right := at-right-or-left.
at-left := at-right-or-left.
at-compass-direction := place-param.
at-south := at-compass-direction.
at-north := at-compass-direction.
at-east := at-compass-direction.
at-west := at-compass-direction.

startpnt-at-in := at-in & startpnt-of-path.
startpnt-at-out := at-out & startpnt-of-path.
startpnt-at-up := at-up & startpnt-of-path.
startpnt-at-down := at-down & startpnt-of-path.
startpnt-at-close := at-close & startpnt-of-path.
startpnt-at-far := at-far & startpnt-of-path.
startpnt-at-home := at-home & startpnt-of-path.
startpnt-at-ahead := at-ahead & startpnt-of-path.
startpnt-at-back := at-back & startpnt-of-path.
startpnt-at-salientpoint := at-salientpoint & startpnt-of-path.
startpnt-at-awayfrom-salientpoint := at-awayfrom-salientpoint.
startpnt-at-right := at-right & startpnt-of-path.
startpnt-at-left := at-left & startpnt-of-path.
startpnt-at-south := at-south & startpnt-of-path.
startpnt-at-north := at-north & startpnt-of-path.
startpnt-at-east := at-east & startpnt-of-path.
startpnt-at-west := at-west & startpnt-of-path.

; for use on EXTRINSIC-ORD:
noncomplete-imp := sort.
complete-imp := sort.


;;; for use in KEYS.KEY:

adhoc-norm := predsort.
adhoc-abnorm := propt.
som-cmpar := adhoc-abnorm.
enn-cmpar := adhoc-abnorm.
interr-word := non-measurnoun.
non-interr-word := non-measurnoun.
qkey := quantas.
posspcl := weaklic.
possprn := weaklic.
coordinator := adhoc-norm.
punctuator := adhoc-norm.
degreer := adhoc-norm.
weaklic := adhoc-norm.
adjquant-pre := adhoc-norm.
adjquant-fleste := adjquant-pre.
adjquant-f√¶rreste := adjquant-pre.
adjquant-post := adhoc-norm.

;;;;;;;
om-k := predsort.
p√•-k := predsort.
innp√•-k := predsort.
inni-k := predsort.
innenfor-k := predsort.
innafor-k := predsort.
inntil-k := predsort.
med-k := predsort.
mot-k := predsort.
imot-k := predsort.
overfor-k := predsort.
av-k := predsort.
til-k := predsort.
som-k := predsort.
for-k := predsort.
fremfor-k := predsort.
framfor-k := predsort.
over-k := predsort.
fremover-k := predsort.
framover-k := predsort.
i-k := predsort.
etter-k := predsort.
fra-k := predsort.
ut-fra-k := predsort.
der-n√•r-k := predsort.
ang√•ende-k := predsort.
bak-k := predsort.
blant-k := predsort.
rundt-k := predsort.
foran-k := predsort.
an-k := predsort.
bakut-k := predsort.
gjennom-k := predsort.
igjennom-k := predsort.
igjen-k := predsort.
langs-k := predsort.
under-k := predsort.
ved-k := predsort.
uten-k := predsort.
foruten-k := predsort.
fore-k := predsort.
borti-k := predsort.
unna-k := predsort.
ad-k := predsort.

; from ordbank_missing_prep
a-k := predsort.
a-la-k := predsort.
aktenom-k := predsort.
attmed-k := predsort.
attom-k := predsort.
attp√•-k := predsort.
austafor-k := predsort.
austafra-k := predsort.
austenom-k := predsort.
austetter-k := predsort.
austfra-k := predsort.
austover-k := predsort.
austp√•-k := predsort.
bakafor-k := predsort.
bakenfor-k := predsort.
bakenfra-k := predsort.
bakenifra-k := predsort.
bakenom-k := predsort.
baki-k := predsort.
bakom-k := predsort.
bakp√•-k := predsort.
bl-k := predsort.
bortefra-k := predsort.
bortenom-k := predsort.
bortetter-k := predsort.
bortigjennom-k := predsort.
bortmed-k := predsort.
bortover-k := predsort.
bortp√•-k := predsort.
borttil-k := predsort.
bortunder-k := predsort.
bortved-k := predsort.
contra-k := predsort.
de-k := predsort.
efterp√•-k := predsort.
endelangs-k := predsort.
enn-k := predsort.
ex-k := predsort.
formedelst-k := predsort.
frammafor-k := predsort.
frammenfor-k := predsort.
framom-k := predsort.
fremmenfor-k := predsort.
fremom-k := predsort.
grunnet-k := predsort.
heimanfra-k := predsort.
hj√•-k := predsort.
iblant-k := predsort.
ikring-k := predsort.
innad√∏rs-k := predsort.
innatt-k := predsort.
innefra-k := predsort.
innend√∏rs-k := predsort.
innenifra-k := predsort.
innfor-k := predsort.
inniblant-k := predsort.
innigjennom-k := predsort.
innmed-k := predsort.
innved-k := predsort.
inn√•t-k := predsort.
kontra-k := predsort.
kring-k := predsort.
kringom-k := predsort.
langsetter-k := predsort.
langsmed-k := predsort.
langtfra-k := predsort.
nedafor-k := predsort.
nedafra-k := predsort.
nedefra-k := predsort.
nedenfor-k := predsort.
nedenfra-k := predsort.
nedenifra-k := predsort.
nordafra-k := predsort.
nordenfra-k := predsort.
nordfra-k := predsort.
nordi-k := predsort.
nordmed-k := predsort.
nordover-k := predsort.
nordp√•-k := predsort.
nord√∏stover-k := predsort.
ombord-k := predsort.
omfram-k := predsort.
omframt-k := predsort.
oppetter-k := predsort.
oppfor-k := predsort.
oppgjennom-k := predsort.
oppigjennom-k := predsort.
oppmed-k := predsort.
oppom-k := predsort.
oppunder-k := predsort.
oppved-k := predsort.
ovafor-k := predsort.
ovafra-k := predsort.
ovap√•-k := predsort.
ovenfra-k := predsort.
ovenom-k := predsort.
overbord-k := predsort.
per-k := predsort.
post-k := predsort.
poste-restante-k := predsort.
pro-k := predsort.
pro-et-contra-k := predsort.
sydetter-k := predsort.
sydfra-k := predsort.
sydover-k := predsort.
sydp√•-k := predsort.
s√∏nnafra-k := predsort.
s√∏nnenfra-k := predsort.
s√∏retter-k := predsort.
s√∏rfra-k := predsort.
s√∏rover-k := predsort.
s√∏rp√•-k := predsort.
takket-v√¶re-k := predsort.
tillikemed-k := predsort.
trass-k := predsort.
tross-k := predsort.
utafor-k := predsort.
utafra-k := predsort.
utav-k := predsort.
utefra-k := predsort.
utend√∏rs-k := predsort.
utenfra-k := predsort.
utfor-k := predsort.
uti-k := predsort.
utifra-k := predsort.
utmed-k := predsort.
utover-k := predsort.
utved-k := predsort.
van-k := predsort.
versus-k := predsort.
vestafra-k := predsort.
vestenfra-k := predsort.
vestfra-k := predsort.
vestover-k := predsort.
vestp√•-k := predsort.
vis-a-vis-k := predsort.
vis-√†-vis-k := predsort.
von-k := predsort.
√†-k := predsort.
√†-la-k := predsort.
√•t-k := predsort.
√∏stafra-k := predsort.
√∏stenfra-k := predsort.
√∏stetter-k := predsort.
√∏stfra-k := predsort.
√∏stover-k := predsort.
√∏stp√•-k := predsort.




ut-k := predsort.
ute-k := predsort.
opp-k := predsort.
ned-k := predsort.
bort-k := predsort.
hen-k := predsort.
vill-k := predsort.
frem-k := predsort.
ifra-k := predsort.
full-k := predsort.
tom-k := predsort.
t√∏rr-k := predsort.
varm-k := predsort.
fremp√•-k := predsort.
fram-k := predsort.
framp√•-k := predsort.
inn-k := predsort.
inne-k := predsort.
ferdig-k := predsort.
ihjel-k := predsort.
sammen-k := predsort.
fast-k := predsort.
hit-k := predsort.
dit-k := predsort.
vekk-k := predsort.
istykker-k := predsort.
l√∏s-k := predsort.
tilbake-k := predsort.
lykkelig-k := predsort.
akterut-k := predsort.

s√•-k := predsort.
videre-k := predsort.
deretter-k := predsort.
halvveis-k := predsort.
og-k := predsort.
ikke-k := predsort.
ei-k := predsort.
egentlig-k := predsort.
kanskje-k := predsort.
selv-k := predsort.
bare-sadv-k := predsort.
til-og-med-k := predsort.
heller-k := predsort.
neppe-k := predsort.
overhodet-k := predsort.
sannsynligvis-k := predsort.
virkelig-k := predsort.
antakeligvis-k := predsort.
antageligvis-k := predsort.
antagelig-k := predsort.
antakelig-k := predsort.
trolig-k := predsort.
aldri-k := predsort.
aldri-noensinne-k := predsort.
noensinne-k := predsort.
forh√•pentligvis-k := predsort.
forh√•pentlig-k := predsort.
alltid-k := predsort.
sjelden-k := predsort.
tidligere-k := predsort.
en-gang-iblant-k := predsort.
ofte-k := predsort.
heldigvis-k := predsort.
eksempelvis-k := predsort.
for-eksempel-k := predsort.
nettopp-k := predsort.
allerede-k := predsort.
ensidig-k := predsort.
akkurat-k := predsort.
imidlertid-k := predsort.
dog-k := predsort.
nylig-k := predsort.
jevnlig-k := predsort.
selvf√∏lgelig-k := predsort.
selvsagt-k := predsort.
dermed-k := predsort.
slik-k := predsort.
alts√•-k := predsort.
uansett-k := predsort.
fremdeles-k := predsort.
mon-k := predsort.
;s√•-k := predsort.



ogs√•-k := predsort.
forresten-k := predsort.
faktisk-k := predsort.
just-k := predsort.
likevel-k := predsort.
allikevel-k := predsort.
vel-k := predsort.
ellers-k := predsort.
derfor-k := predsort.
muligvis-k := predsort.
naturligvis-k := predsort.
n√∏dvendigvis-k := predsort.
muligens-k := predsort.
;mon-k := predsort.
riktignok-k := predsort.
nemlig-k := predsort.
for-s√•-vidt-k := predsort.
for√∏vrig-k := predsort.
f√∏lgelig-k := predsort.
bare-k := predsort.
kun-k := predsort.
helst-k := predsort.
likeledes-k := predsort.
likes√•-k := predsort.
istedet-k := predsort.
ingenlunde-k := predsort.
iallfall-k := predsort.
hittil-k := predsort.
herved-k := predsort.
fortrinnsvis-k := predsort.
gjerne-k := predsort.
alternativt-k := predsort.
dessverre-k := predsort.
dessuten-k := predsort.
dernest-k := predsort.
derimot-k := predsort.
tydeligvis-k := predsort.
nok-k := predsort.
ergo-k := predsort.
endatil-k := predsort.
attp√•til-k := predsort.
endog-k := predsort.
deriblant-k := predsort.
engang-k := predsort.
for-det-meste-k := predsort.
f√∏r-k := predsort.
noen-ganger-k := predsort.
hinsides-k := predsort.
hos-k := predsort.
mellom-k := predsort.
n√¶r-k := predsort.
omkring-k := predsort.
oppi-k := predsort.

selve-k := propt.



; nom-k is the leaf of leaves!
;leir-k := nom-k.
;fl√∏yten-k := nom-k.
;has-k := nom-k.
leir-k := predsort.
fl√∏yten-k := predsort.
has-k := predsort.
m√•l-k := predsort.
d√∏d-k := predsort.
smil-k := predsort.
latter-k := predsort.
dagtid-k := predsort.
s√∏vn-k := predsort.
ting-k := predsort.
bryllup-k := predsort.
m√•te-k := relinan.
fare-k := relinan.
sang-k := relinan.
vakt-k := relinan.
tur-k := relinan.
g√•tur-k := tur-k.
busstur-k := tur-k.
fjelltur-k := tur-k.
biltur-k := tur-k.
rundtur-k := tur-k.
topptur-k := tur-k.
klatretur-k := tur-k.
bytur-k := tur-k.
reise-k := relinan.
flyreise-k := reise-k.
flight-k := reise-k.
bussreise-k := reise-k.
togreise-k := reise-k.
b√•treise-k := reise-k.
skyss-k := reise-k.
standard-k := relinan.
frist-k := relinan.
;m√∏te-k := relinan.
eksempel-k := relinan.
meet-k := relinan.
enighet-k := relinan.
plikt-k := relinan.

vehicle-k := relinan.
buss-k := vehicle-k.
bil-k := vehicle-k.
b√•t-k := vehicle-k.
fly-k := vehicle-k.
tog-k := vehicle-k.
ferje-k := vehicle-k.

path-k := relinan.
vei-k := path-k.
gate-k := path-k.
sti-k := path-k.
fortau-k := path-k.
motorvei-k := path-k.
bane-pth-k := path-k.
rute-k := path-k.
bro-k := path-k.
tunnel-k := path-k.
bakke-pth-k := path-k.
trapp-k := path-k.
linje-k := path-k.
spor-k := path-k.

; these are included in type-file STEMonly_sorted.txt
beg√•-k := predsort.
;falle-k := predsort.
;hoppe-k := predsort.
la-sangen-synge-k := predsort.
 ;;;;;;;

selct := adhoc-norm.
non-selct := adhoc-norm.
; for detach-poss
detch := actv-prep & prim-mod.
p√•-detch := detch & p√•-k.
i-detch := detch & i-k.

fct-spec := index-sitA.
actv-prep := adhoc-norm.
pass-prep := adhoc-norm.
fct-actv-spec := fct-spec & actv-prep.
fct-pass-spec := fct-spec & pass-prep.

om-fct-spec := fct-spec & om-k.
p√•-fct-spec := fct-spec & p√•-k.
innp√•-fct-spec := fct-spec & innp√•-k.
inni-fct-spec := fct-spec & inni-k.
innenfor-fct-spec := fct-spec & innenfor-k.
innafor-fct-spec := fct-spec & innafor-k.
med-fct-spec := fct-spec & med-k.
mot-fct-spec := fct-spec & mot-k.
imot-fct-spec := fct-spec & imot-k.
overfor-fct-spec := fct-spec & overfor-k.
av-fct-spec := fct-spec & av-k.
gjennom-fct-spec := fct-spec & gjennom-k.
igjennom-fct-spec := fct-spec & igjennom-k.
til-fct-spec := fct-spec & til-k.
som-fct-spec := fct-spec & som-k.
for-fct-spec := fct-spec & for-k.
fremfor-fct-spec := fct-spec & fremfor-k.
framfor-fct-spec := fct-spec & framfor-k.
over-fct-spec := fct-spec & over-k.
i-fct-spec := fct-spec & i-k.
borti-fct-spec := fct-spec & borti-k.
oppi-fct-spec := fct-spec & oppi-k.
under-fct-spec := fct-spec & under-k.
unna-fct-spec := fct-spec & unna-k.
bak-fct-spec := fct-spec & bak-k.
foran-fct-spec := fct-spec & foran-k.
rundt-fct-spec := fct-spec & rundt-k.
etter-fct-spec := fct-spec & etter-k.
fra-fct-spec := fct-spec & fra-k.
der-n√•r-fct-spec := fct-spec & der-n√•r-k.
ang√•ende-fct-spec := fct-spec & ang√•ende-k.
mellom-fct-spec := fct-spec & mellom-k.
ved-fct-spec := fct-spec & ved-k.
ad-fct-spec := fct-spec & ad-k.

om-fctactv-spec := fct-actv-spec & om-fct-spec & non-clse.
p√•-fctactv-spec := fct-actv-spec & p√•-fct-spec & non-clse.
med-fctactv-spec := fct-actv-spec & med-fct-spec & non-clse.
mot-fctactv-spec := fct-actv-spec & mot-fct-spec & non-clse.
overfor-fctactv-spec := fct-actv-spec & overfor-fct-spec & non-clse.
for-fctactv-spec := fct-actv-spec & for-fct-spec & non-clse.
fremfor-fctactv-spec := fct-actv-spec & fremfor-fct-spec & non-clse.
framfor-fctactv-spec := fct-actv-spec & framfor-fct-spec & non-clse.
av-fctactv-spec := fct-actv-spec & av-fct-spec & non-clse.
til-fctactv-spec := fct-actv-spec & til-fct-spec & non-clse.
som-fctactv-spec := fct-actv-spec & som-fct-spec & non-clse.
over-fctactv-spec := fct-actv-spec & over-fct-spec & non-clse.
i-fctactv-spec := fct-actv-spec & i-fct-spec & non-clse.
borti-fctactv-spec := fct-actv-spec & borti-fct-spec & non-clse.
der-n√•r-fctactv-spec := fct-actv-spec & der-n√•r-fct-spec & non-clse.
etter-fctactv-spec := fct-actv-spec & etter-fct-spec & non-clse.
ved-fctactv-spec := fct-actv-spec & ved-fct-spec & non-clse.
mellom-fctactv-spec := fct-actv-spec & mellom-fct-spec & non-clse.
ang√•ende-fctactv-spec := fct-actv-spec & ang√•ende-fct-spec & non-clse.
gjennom-fctactv-spec := fct-actv-spec & gjennom-fct-spec & non-clse.

om-fctpass-spec := fct-pass-spec & om-fct-spec.
p√•-fctpass-spec := fct-pass-spec & p√•-fct-spec.
med-fctpass-spec := fct-pass-spec & med-fct-spec.
mot-fctpass-spec := fct-pass-spec & mot-fct-spec.
overfor-fctpass-spec := fct-pass-spec & overfor-fct-spec.
av-fctpass-spec := fct-pass-spec & av-fct-spec.
til-fctpass-spec := fct-pass-spec & til-fct-spec.
som-fctpass-spec := fct-pass-spec & som-fct-spec.
over-fctpass-spec := fct-pass-spec & over-fct-spec.
i-fctpass-spec := fct-pass-spec & i-fct-spec.
borti-fctpass-spec := fct-pass-spec & borti-fct-spec.
der-n√•r-fctpass-spec := fct-pass-spec & der-n√•r-fct-spec.
etter-fctpass-spec := fct-pass-spec & etter-fct-spec.
ved-fctpass-spec := fct-pass-spec & ved-fct-spec.
mellom-fctpass-spec := fct-pass-spec & mellom-fct-spec.
ang√•ende-fctpass-spec := fct-pass-spec & ang√•ende-fct-spec.
gjennom-fctpass-spec := fct-pass-spec & gjennom-fct-spec.

con-communic-act := fct-spec.
med-concumm := con-communic-act & med-fct-spec.
om-concumm := con-communic-act & om-fct-spec.
instr := fct-spec.
med-instr := instr & med-fct-spec.
topic-of := fct-spec. 
om-topic-of := topic-of & om-fct-spec.
p√•-topic-of := topic-of & p√•-fct-spec.
adverse := fct-spec.
mot-adverse := adverse & mot-fct-spec.
overfor-adverse := adverse & overfor-fct-spec.
basis-of := fct-spec.
p√•-basis-of := basis-of & p√•-fct-spec.

assoc-act := fct-spec.
med-assoc := assoc-act & med-fct-spec.
p√•-assoc := assoc-act & p√•-fct-spec.
til-assoc := assoc-act & til-fct-spec.
for-assoc := assoc-act & for-fct-spec.
av-assoc := assoc-act & av-fct-spec.
i-assoc := assoc-act & i-fct-spec.

med-act-assoc := med-assoc & med-fctactv-spec.
p√•-act-assoc := p√•-assoc & p√•-fctactv-spec.
til-act-assoc := til-assoc & til-fctactv-spec.
for-act-assoc := for-assoc & for-fctactv-spec.
av-act-assoc := av-assoc & av-fctactv-spec.
i-act-assoc := i-assoc & i-fctactv-spec.


med-act-concumm := med-concumm & med-fctactv-spec.
med-act-instr := med-instr & med-fctactv-spec.
om-act-topic-of := om-topic-of & om-fctactv-spec.
p√•-act-topic-of := p√•-topic-of & p√•-fctactv-spec.
mot-act-adverse := mot-adverse & mot-fctactv-spec.
overfor-act-adverse := overfor-adverse & overfor-fctactv-spec.
p√•-act-basis-of := p√•-basis-of & p√•-fctactv-spec.


med-pass-concumm := med-concumm & med-fctpass-spec & non-clse.
med-pass-instr := med-instr & med-fctpass-spec & non-clse.
om-pass-topic-of := om-topic-of & om-fctpass-spec & non-clse.
p√•-pass-topic-of := p√•-topic-of & p√•-fctpass-spec & non-clse.
mot-pass-adverse := mot-adverse & mot-fctpass-spec & non-clse.
overfor-pass-adverse := overfor-adverse & overfor-fctpass-spec & non-clse.
p√•-pass-basis-of := p√•-basis-of & p√•-fctpass-spec & non-clse.

med-pass-assoc := med-assoc & med-fctpass-spec.
p√•-pass-assoc := p√•-assoc & p√•-fctpass-spec.
til-pass-assoc := til-assoc & til-fctpass-spec.

preprel := actv-prep & prim-mod & non-clse.
om-rel := preprel & om-k.
p√•-rel := preprel & p√•-k.
over-rel := preprel & over-k.
av-rel := preprel & av-k.
med-rel := preprel & med-k.
til-rel := preprel & til-k.
sem-rel := preprel & som-k.
for-rel := preprel & for-k.
i-rel := preprel & i-k.
mot-rel := preprel & i-k.
#|

om-rel := preprel & om-fct-spec.
p√•-rel := preprel & p√•-fct-spec.
over-rel := preprel & over-fct-spec.
av-rel := preprel & av-fct-spec.
med-rel := preprel & med-fct-spec.
til-rel := preprel & til-fct-spec.
for-rel := preprel & for-fct-spec.
i-rel := preprel & i-fct-spec.
|#

; for prep-clause-word
clausal-yes := adhoc-norm.
clausal-no := adhoc-norm.
clse := fct-actv-spec & clausal-yes.
non-clse := clausal-no.
om-clse := clse & om-fct-spec.
mot-clse := clse & mot-fct-spec.
imot-clse := clse & imot-fct-spec.
p√•-clse := clse & p√•-fct-spec.
over-clse := clse & over-fct-spec.
under-clse := clse & under-fct-spec.
av-clse := clse & av-fct-spec.
i-clse := clse & i-fct-spec.
med-clse := clse & med-fct-spec.
ved-clse := clse & ved-fct-spec.
som-clse := clse & som-fct-spec.
til-clse := clse & til-fct-spec.
fra-clse := clse & fra-fct-spec.
for-clse := clse & for-fct-spec.
etter-clse := clse & etter-fct-spec.
ang√•ende-clse := clse & ang√•ende-fct-spec.


atelic-operation := prim-mod.
p√•-atelop := atelic-operation & p√•-k.
av-atelop := atelic-operation & av-k.
med-atelop := atelic-operation & med-k.
ved-atelop := atelic-operation & ved-k.

; med-fctactv-spec
p√•-act-atelop := p√•-atelop & actv-prep.
av-act-atelop := av-atelop & actv-prep.
med-act-atelop := med-atelop & actv-prep.

p√•-pass-atelop := p√•-atelop & pass-prep.
av-pass-atelop := av-atelop & pass-prep.
med-pass-atelop := med-atelop & pass-prep.

; for prep-indirwhquest-word
indirqu := fct-spec.
p√•-indirqu := indirqu & p√•-fct-spec & fct-actv-spec.
om-indirqu := indirqu & om-fct-spec & fct-actv-spec.
ang√•ende-indirqu := indirqu & ang√•ende-fct-spec & fct-actv-spec.

; for prep-rais-word
rais := prim-mod.
p√•-rais := rais & p√•-k.
om-rais := rais & om-k.
som-rais := rais & som-k.
til-rais := rais & til-k.
med-rais := rais & med-k.
mot-rais := rais & mot-k.
imot-rais := rais & imot-k.
fra-rais := rais & fra-k.
framfor-rais := rais & framfor-k.
fremfor-rais := rais & fremfor-k.
uten-rais := rais & uten-k.
av-rais := rais & av-k.
for-rais := rais & for-k.
over-rais := rais & over-k.
overfor-rais := rais & overfor-k.
i-rais := rais & i-k.
etter-rais := rais & etter-k.
unna-rais := rais & unna-k.
under-rais := rais & under-k.
ved-rais := rais & ved-k.
mellom-rais := rais & mellom-k.


; for prep-delimit-fix
delimfix := non-selct & actv-prep.
p√•-delimfix := delimfix & p√•-k.
i-delimfix := delimfix & i-k.
; for prep-tel-fix
telfix := non-selct & actv-prep.
p√•-telfix := telfix & p√•-k & canbefirstafterverb-index-sit1.
i-telfix := telfix & i-k & canbefirstafterverb-index-sit1.
; for prep-word-reg/dir
reg := selct.
prim-mod := reg.
sec-mod := reg.
non-dir := reg.
;relprep := non-dir.
index-sit := non-dir & nonfixpt.
index-sitA := index-sit & prim-mod.
index-sit1 := index-sitA & actv-prep.
index-sit2 := index-sit & sec-mod & actv-prep.



uten-indxsit := canbefirstafterverb-index-sit1 & uten-k.
etter-indxsit := canbefirstafterverb-index-sit1 & etter-k.
p√•-indxsit := canbefirstafterverb-index-sit1 & p√•-k.
i-indxsit := canbefirstafterverb-index-sit1 & i-k.
ved-indxsit := canbefirstafterverb-index-sit1 & ved-k.
med-indxsit := canbefirstafterverb-index-sit1 & med-k.
under-indxsit := canbefirstafterverb-index-sit1 & under-k.
bak-indxsit := canbefirstafterverb-index-sit1 & bak-k.
over-indxsit := canbefirstafterverb-index-sit1 & over-k.
foran-indxsit := canbefirstafterverb-index-sit1 & foran-k.
innenfor-indxsit := canbefirstafterverb-index-sit1 & innenfor-k.
innafor-indxsit := canbefirstafterverb-index-sit1 & innafor-k.
n√¶r-indxsit := canbefirstafterverb-index-sit1 & n√¶r-k.
til-indxsit := canbefirstafterverb-index-sit1 & til-k.
hos-indxsit := canbefirstafterverb-index-sit1 & hos-k.
rundt-indxsit := canbefirstafterverb-index-sit1 & rundt-k.
blant-indxsit := canbefirstafterverb-index-sit1 & blant-k.
om-indxsit := canbefirstafterverb-index-sit1 & om-k.
som-indxsit := canbefirstafterverb-index-sit1 & som-k.
fra-indxsit := canbefirstafterverb-index-sit1 & fra-k.
ut-fra-indxsit := canbefirstafterverb-index-sit1 & ut-fra-k.
ang√•ende-indxsit := canbefirstafterverb-index-sit1 & ang√•ende-k.
omkring-indxsit := canbefirstafterverb-index-sit1 & omkring-k.
mellom-indxsit := canbefirstafterverb-index-sit1 & mellom-k.
for-indxsit := canbefirstafterverb-index-sit1 & for-k.
fremfor-indxsit := canbefirstafterverb-index-sit1 & fremfor-k.
framfor-indxsit := canbefirstafterverb-index-sit1 & framfor-k.
oppi-indxsit := canbefirstafterverb-index-sit1 & oppi-k.
inni-indxsit := canbefirstafterverb-index-sit1 & inni-k.
f√∏r-indxsit := canbefirstafterverb-index-sit1 & f√∏r-k.
mot-indxsit := canbefirstafterverb-index-sit1 & mot-k.
hinsides-indxsit := canbefirstafterverb-index-sit1 & hinsides-k.
;i-indxsit := canbefirstafterverb-index-sit1 & i-k.
;i-indxsit := canbefirstafterverb-index-sit1 & i-k.

;from ordbank_missing_prep

a-indxsit := canbefirstafterverb-index-sit1 & a-k.
a-la-indxsit := canbefirstafterverb-index-sit1 & a-la-k.
aktenom-indxsit := canbefirstafterverb-index-sit1 & aktenom-k.
attmed-indxsit := canbefirstafterverb-index-sit1 & attmed-k.
attom-indxsit := canbefirstafterverb-index-sit1 & attom-k.
attp√•-indxsit := canbefirstafterverb-index-sit1 & attp√•-k.
austafor-indxsit := canbefirstafterverb-index-sit1 & austafor-k.
austafra-indxsit := canbefirstafterverb-index-sit1 & austafra-k.
austenom-indxsit := canbefirstafterverb-index-sit1 & austenom-k.
austetter-indxsit := canbefirstafterverb-index-sit1 & austetter-k.
austfra-indxsit := canbefirstafterverb-index-sit1 & austfra-k.
austover-indxsit := canbefirstafterverb-index-sit1 & austover-k.
austp√•-indxsit := canbefirstafterverb-index-sit1 & austp√•-k.
bakafor-indxsit := canbefirstafterverb-index-sit1 & bakafor-k.
bakenfor-indxsit := canbefirstafterverb-index-sit1 & bakenfor-k.
bakenfra-indxsit := canbefirstafterverb-index-sit1 & bakenfra-k.
bakenifra-indxsit := canbefirstafterverb-index-sit1 & bakenifra-k.
bakenom-indxsit := canbefirstafterverb-index-sit1 & bakenom-k.
baki-indxsit := canbefirstafterverb-index-sit1 & baki-k.
bakom-indxsit := canbefirstafterverb-index-sit1 & bakom-k.
bakp√•-indxsit := canbefirstafterverb-index-sit1 & bakp√•-k.
bl-indxsit := canbefirstafterverb-index-sit1 & bl-k.
bortefra-indxsit := canbefirstafterverb-index-sit1 & bortefra-k.
bortenom-indxsit := canbefirstafterverb-index-sit1 & bortenom-k.
bortetter-indxsit := canbefirstafterverb-index-sit1 & bortetter-k.
bortigjennom-indxsit := canbefirstafterverb-index-sit1 & bortigjennom-k.
bortmed-indxsit := canbefirstafterverb-index-sit1 & bortmed-k.
bortover-indxsit := canbefirstafterverb-index-sit1 & bortover-k.
bortp√•-indxsit := canbefirstafterverb-index-sit1 & bortp√•-k.
borttil-indxsit := canbefirstafterverb-index-sit1 & borttil-k.
bortunder-indxsit := canbefirstafterverb-index-sit1 & bortunder-k.
bortved-indxsit := canbefirstafterverb-index-sit1 & bortved-k.
contra-indxsit := canbefirstafterverb-index-sit1 & contra-k.
de-indxsit := canbefirstafterverb-index-sit1 & de-k.
efterp√•-indxsit := canbefirstafterverb-index-sit1 & efterp√•-k.
endelangs-indxsit := canbefirstafterverb-index-sit1 & endelangs-k.
ex-indxsit := canbefirstafterverb-index-sit1 & ex-k.
formedelst-indxsit := canbefirstafterverb-index-sit1 & formedelst-k.
frammafor-indxsit := canbefirstafterverb-index-sit1 & frammafor-k.
frammenfor-indxsit := canbefirstafterverb-index-sit1 & frammenfor-k.
framom-indxsit := canbefirstafterverb-index-sit1 & framom-k.
framp√•-indxsit := canbefirstafterverb-index-sit1 & framp√•-k.
fremmenfor-indxsit := canbefirstafterverb-index-sit1 & fremmenfor-k.
fremom-indxsit := canbefirstafterverb-index-sit1 & fremom-k.
fremover-indxsit := canbefirstafterverb-index-sit1 & fremover-k.
fremp√•-indxsit := canbefirstafterverb-index-sit1 & fremp√•-k.
grunnet-indxsit := canbefirstafterverb-index-sit1 & grunnet-k.
heimanfra-indxsit := canbefirstafterverb-index-sit1 & heimanfra-k.
hj√•-indxsit := canbefirstafterverb-index-sit1 & hj√•-k.
iblant-indxsit := canbefirstafterverb-index-sit1 & iblant-k.
ikring-indxsit := canbefirstafterverb-index-sit1 & ikring-k.
innad√∏rs-indxsit := canbefirstafterverb-index-sit1 & innad√∏rs-k.
innatt-indxsit := canbefirstafterverb-index-sit1 & innatt-k.
innefra-indxsit := canbefirstafterverb-index-sit1 & innefra-k.
innend√∏rs-indxsit := canbefirstafterverb-index-sit1 & innend√∏rs-k.
innenifra-indxsit := canbefirstafterverb-index-sit1 & innenifra-k.
innfor-indxsit := canbefirstafterverb-index-sit1 & innfor-k.
inniblant-indxsit := canbefirstafterverb-index-sit1 & inniblant-k.
innigjennom-indxsit := canbefirstafterverb-index-sit1 & innigjennom-k.
innmed-indxsit := canbefirstafterverb-index-sit1 & innmed-k.
innved-indxsit := canbefirstafterverb-index-sit1 & innved-k.
inn√•t-indxsit := canbefirstafterverb-index-sit1 & inn√•t-k.
kontra-indxsit := canbefirstafterverb-index-sit1 & kontra-k.
kring-indxsit := canbefirstafterverb-index-sit1 & kring-k.
kringom-indxsit := canbefirstafterverb-index-sit1 & kringom-k.
langsetter-indxsit := canbefirstafterverb-index-sit1 & langsetter-k.
langsmed-indxsit := canbefirstafterverb-index-sit1 & langsmed-k.
langtfra-indxsit := canbefirstafterverb-index-sit1 & langtfra-k.
nedafor-indxsit := canbefirstafterverb-index-sit1 & nedafor-k.
nedafra-indxsit := canbefirstafterverb-index-sit1 & nedafra-k.
nedefra-indxsit := canbefirstafterverb-index-sit1 & nedefra-k.
nedenfor-indxsit := canbefirstafterverb-index-sit1 & nedenfor-k.
nedenfra-indxsit := canbefirstafterverb-index-sit1 & nedenfra-k.
nedenifra-indxsit := canbefirstafterverb-index-sit1 & nedenifra-k.
nordafra-indxsit := canbefirstafterverb-index-sit1 & nordafra-k.
nordenfra-indxsit := canbefirstafterverb-index-sit1 & nordenfra-k.
nordfra-indxsit := canbefirstafterverb-index-sit1 & nordfra-k.
nordi-indxsit := canbefirstafterverb-index-sit1 & nordi-k.
nordmed-indxsit := canbefirstafterverb-index-sit1 & nordmed-k.
nordover-indxsit := canbefirstafterverb-index-sit1 & nordover-k.
nordp√•-indxsit := canbefirstafterverb-index-sit1 & nordp√•-k.
nord√∏stover-indxsit := canbefirstafterverb-index-sit1 & nord√∏stover-k.
ombord-indxsit := canbefirstafterverb-index-sit1 & ombord-k.
omfram-indxsit := canbefirstafterverb-index-sit1 & omfram-k.
omframt-indxsit := canbefirstafterverb-index-sit1 & omframt-k.
oppetter-indxsit := canbefirstafterverb-index-sit1 & oppetter-k.
oppfor-indxsit := canbefirstafterverb-index-sit1 & oppfor-k.
oppgjennom-indxsit := canbefirstafterverb-index-sit1 & oppgjennom-k.
oppigjennom-indxsit := canbefirstafterverb-index-sit1 & oppigjennom-k.
oppmed-indxsit := canbefirstafterverb-index-sit1 & oppmed-k.
oppom-indxsit := canbefirstafterverb-index-sit1 & oppom-k.
oppunder-indxsit := canbefirstafterverb-index-sit1 & oppunder-k.
oppved-indxsit := canbefirstafterverb-index-sit1 & oppved-k.
ovafor-indxsit := canbefirstafterverb-index-sit1 & ovafor-k.
overfor-indxsit := canbefirstafterverb-index-sit1 & overfor-k.
ovafra-indxsit := canbefirstafterverb-index-sit1 & ovafra-k.
ovap√•-indxsit := canbefirstafterverb-index-sit1 & ovap√•-k.
ovenfra-indxsit := canbefirstafterverb-index-sit1 & ovenfra-k.
ovenom-indxsit := canbefirstafterverb-index-sit1 & ovenom-k.
overbord-indxsit := canbefirstafterverb-index-sit1 & overbord-k.
per--indxsit := canbefirstafterverb-index-sit1 & per-k.
post-indxsit := canbefirstafterverb-index-sit1 & post-k.
poste-restante-indxsit := canbefirstafterverb-index-sit1 & poste-restante-k.
pro-indxsit := canbefirstafterverb-index-sit1 & pro-k.
pro-et-contra-indxsit := canbefirstafterverb-index-sit1 & pro-et-contra-k.
sydetter-indxsit := canbefirstafterverb-index-sit1 & sydetter-k.
sydfra-indxsit := canbefirstafterverb-index-sit1 & sydfra-k.
sydover-indxsit := canbefirstafterverb-index-sit1 & sydover-k.
sydp√•-indxsit := canbefirstafterverb-index-sit1 & sydp√•-k.
s√∏nnafra-indxsit := canbefirstafterverb-index-sit1 & s√∏nnafra-k.
s√∏nnenfra-indxsit := canbefirstafterverb-index-sit1 & s√∏nnenfra-k.
s√∏retter-indxsit := canbefirstafterverb-index-sit1 & s√∏retter-k.
s√∏rfra-indxsit := canbefirstafterverb-index-sit1 & s√∏rfra-k.
s√∏rover-indxsit := canbefirstafterverb-index-sit1 & s√∏rover-k.
s√∏rp√•-indxsit := canbefirstafterverb-index-sit1 & s√∏rp√•-k.
takket-v√¶re-indxsit := canbefirstafterverb-index-sit1 & takket-v√¶re-k.
tillikemed-indxsit := canbefirstafterverb-index-sit1 & tillikemed-k.
trass-indxsit := canbefirstafterverb-index-sit1 & trass-k.
tross-indxsit := canbefirstafterverb-index-sit1 & tross-k.
uansett-indxsit := canbefirstafterverb-index-sit1 & uansett-k.
unna-indxsit := canbefirstafterverb-index-sit1 & unna-k.
utafor-indxsit := canbefirstafterverb-index-sit1 & utafor-k.
utafra-indxsit := canbefirstafterverb-index-sit1 & utafra-k.
utav-indxsit := canbefirstafterverb-index-sit1 & utav-k.
utefra-indxsit := canbefirstafterverb-index-sit1 & utefra-k.
utend√∏rs-indxsit := canbefirstafterverb-index-sit1 & utend√∏rs-k.
utenfra-indxsit := canbefirstafterverb-index-sit1 & utenfra-k.
utfor-indxsit := canbefirstafterverb-index-sit1 & utfor-k.
uti-indxsit := canbefirstafterverb-index-sit1 & uti-k.
utifra-indxsit := canbefirstafterverb-index-sit1 & utifra-k.
utmed-indxsit := canbefirstafterverb-index-sit1 & utmed-k.
utover-indxsit := canbefirstafterverb-index-sit1 & utover-k.
utved-indxsit := canbefirstafterverb-index-sit1 & utved-k.
van-indxsit := canbefirstafterverb-index-sit1 & van-k.
versus-indxsit := canbefirstafterverb-index-sit1 & versus-k.
vestafra-indxsit := canbefirstafterverb-index-sit1 & vestafra-k.
vestenfra-indxsit := canbefirstafterverb-index-sit1 & vestenfra-k.
vestfra-indxsit := canbefirstafterverb-index-sit1 & vestfra-k.
vestover-indxsit := canbefirstafterverb-index-sit1 & vestover-k.
vestp√•-indxsit := canbefirstafterverb-index-sit1 & vestp√•-k.
vis-a-vis-indxsit := canbefirstafterverb-index-sit1 & vis-a-vis-k.
vis-√†-vis-indxsit := canbefirstafterverb-index-sit1 & vis-√†-vis-k.
von-indxsit := canbefirstafterverb-index-sit1 & von-k.
√†-indxsit := canbefirstafterverb-index-sit1 & √†-k.
√†-la-indxsit := canbefirstafterverb-index-sit1 & √†-la-k.
√•t-indxsit := canbefirstafterverb-index-sit1 & √•t-k.
√∏stafra-indxsit := canbefirstafterverb-index-sit1 & √∏stafra-k.
√∏stenfra-indxsit := canbefirstafterverb-index-sit1 & √∏stenfra-k.
√∏stetter-indxsit := canbefirstafterverb-index-sit1 & √∏stetter-k.
√∏stfra-indxsit := canbefirstafterverb-index-sit1 & √∏stfra-k.
√∏stover-indxsit := canbefirstafterverb-index-sit1 & √∏stover-k.
√∏stp√•-indxsit := canbefirstafterverb-index-sit1 & √∏stp√•-k.





der-n√•r := index-sit1 & der-n√•r-k.

nofirstafterverb := index-sit1.
canbefirstafterverb-index-sit1 := index-sit1.

p√•-adv-indxsit := nofirstafterverb & p√•-k.
i-adv-indxsit := nofirstafterverb & i-k.
ved-adv-indxsit := nofirstafterverb & ved-k.
under-adv-indxsit := nofirstafterverb & under-k.
bak-adv-indxsit := nofirstafterverb & bak-k.
over-adv-indxsit := nofirstafterverb & over-k.
foran-adv-indxsit := nofirstafterverb & foran-k.
bakut-adv-indxsit := nofirstafterverb & bakut-k.

; ? to mark off adv-word-2-reg from adv-word-reg. eg for "han er her"
sec-index-sit := non-dir.

dir-sup := actv-prep.
dir := dir-sup & prim-mod.
fixpt := dir-sup.
nonfixpt := reg.
nonfixpt-dir := dir & nonfixpt.
orient-dir := nonfixpt-dir.
mot-orient-dir := orient-dir & mot-k.
imot-orient-dir := orient-dir & imot-k.
langs-orient-dir := orient-dir & langs-k.
fra-orient-dir := orient-dir & fra-k.
gjennom-orient-dir := orient-dir & gjennom-k.
dir2 := dir-sup & sec-mod.
nonfixpt-dir2 := dir2 & nonfixpt.

pathconsumpt-dir := dir.
fixpt-dir := dir & fixpt.
nonfixptconsumpt-dir := pathconsumpt-dir & nonfixpt-dir.
fixptconsumpt-dir := pathconsumpt-dir & fixpt-dir.
mot-pathconsumpt-dir := nonfixptconsumpt-dir & mot-k.
imot-pathconsumpt-dir := nonfixptconsumpt-dir & imot-k.
langs-pathconsumpt-dir := nonfixptconsumpt-dir & langs-k.
til-pathconsumpt-dir := fixptconsumpt-dir & til-k.
fra-pathconsumpt-dir := fixptconsumpt-dir & fra-k.
gjennom-pathconsumpt-dir := fixptconsumpt-dir & gjennom-k.
etter-pathconsumpt-dir := nonfixptconsumpt-dir & etter-k.
om-pathconsumpt-dir := fixptconsumpt-dir & om-k.
pathconsumpt-dir2 := dir2.
fixpt-dir2 := dir2 & fixpt.
nonfixptconsumpt-dir2 := pathconsumpt-dir2 & nonfixpt-dir2.
fixptconsumpt-dir2 := pathconsumpt-dir2 & fixpt-dir2.

partitive := non-measurnoun.
av-partitive := partitive & av-k.
blant-partitive := partitive & blant-k.
measout := non-selct.
av-measout := measout & av-k.
med-measout := measout & med-k.
possprep := index-sit1.
til-poss := possprep & til-k.
av-poss := possprep & av-k.
for-poss := possprep & for-k.
fra-poss := possprep & fra-k.     


adj-selct := selct.
;seems never used:
;adj-k := absadj0 & adj-decl-selct & adj-quest-selct & propt.
; the next three only on abs-adj
abbr := adj-selct.
adj-decl-selct := adj-selct.
adj-quest-selct := adj-selct.
absadj0 := adj-selct.
absadj0-tough := absadj0.
absadj0-epon := absadj0.
; this one only on adj-lxm (ie, non-abs)
propt := adj-selct & predcomp.
color := propt.
designated-pseudoweak := propt.
riktig-k := predsort.
rett-k := predsort.
heldig-k := predsort.
avgj√∏rende-k := predsort.
hel-k := predsort.
samme-k := predsort.
egen-k := predsort.
eget-k := predsort.

riktig-pseudoweak := riktig-k & designated-pseudoweak.
rett-pseudoweak := rett-k & designated-pseudoweak.
heldig-pseudoweak := heldig-k & designated-pseudoweak.
avgj√∏rende-pseudoweak := avgj√∏rende-k & designated-pseudoweak.
hel-pseudoweak := hel-k & designated-pseudoweak.
selve-pseudoweak := selve-k & designated-pseudoweak.
samme-pseudoweak := samme-k & designated-pseudoweak.
egen-pseudoweak := egen-k & designated-pseudoweak.
eget-pseudoweak := eget-k & designated-pseudoweak.

adv-selct := selct.
pcl := adv-selct.
ut-pcl := pcl & ut-k.
ifra-pcl := pcl & ifra-k.
full-pcl := pcl & full-k.
tom-pcl := pcl & tom-k.
t√∏rr-pcl := pcl & t√∏rr-k.
varm-pcl := pcl & varm-k.
ute-pcl := pcl & ute-k.
opp-pcl := pcl & opp-k.
ned-pcl := pcl & ned-k.
til-pcl := pcl & til-k.
an-pcl := pcl & an-k.

bort-pcl := pcl & bort-k.
hen-pcl := pcl & hen-k.
under-pcl := pcl & under-k.
vill-pcl := pcl & vill-k.
p√•-pcl := pcl & p√•-k.
over-pcl := pcl & over-k.
fremover-pcl := pcl & fremover-k.
framover-pcl := pcl & framover-k.
gjennom-pcl := pcl & gjennom-k.
igjennom-pcl := pcl & igjennom-k.
frem-pcl := pcl & frem-k.
fram-pcl := pcl & fram-k.
etter-pcl := pcl & etter-k.
framp√•-pcl := pcl & framp√•-k.
fremp√•-pcl := pcl & fremp√•-k.
fra-pcl := pcl & fra-k.
ferdig-pcl := pcl & ferdig-k.
om-pcl := pcl & om-k.
imot-pcl := pcl & imot-k.
inn-pcl := pcl & inn-k.
inne-pcl := pcl & inne-k.
med-pcl := pcl & med-k.
rundt-pcl := pcl & rundt-k.
av-pcl := pcl & av-k.
ad-pcl := pcl & ad-k.
ved-pcl := pcl & ved-k.
fore-pcl := pcl & fore-k.
igjen-pcl := pcl & igjen-k.
istykker-pcl := pcl & istykker-k.
l√∏s-pcl := pcl & l√∏s-k.
fast-pcl := pcl & fast-k.
unna-pcl := pcl & unna-k.
tilbake-pcl := pcl & tilbake-k.
lykkelig-pcl := pcl & lykkelig-k.
akterut-pcl := pcl & akterut-k.
sammen-pcl := pcl & sammen-k.
omkring-pcl := pcl & omkring-k.
overfor-pcl := pcl & overfor-k.

comptizer := selct.
predcomp := comptizer & prim-mod.
predcomp-inf := predcomp.
predcomp-adj := predcomp.
predcomp-n := predcomp.
predcomp-som := predcomp & som-k.
predcomp-for := predcomp & for-k.
predcomp-til := predcomp & til-k.
for-pred-inf := predcomp-inf & predcomp-for.
som-pred-inf := predcomp-inf & predcomp-som.
til-pred-inf := predcomp-inf & predcomp-til.
som-pred-adj := predcomp-adj & predcomp-som & actv-prep.
som-om-pred-adj := predcomp-adj & predcomp-som & actv-prep.
som-pred-n := predcomp-n & predcomp-som & actv-prep.
til-pred-n := predcomp-n & predcomp-til.
fin-infin-comp := comptizer.
finit-comp := fin-infin-comp.
finit-comp-at := finit-comp.
finit-comp-som := finit-comp.
infinit-comp := fin-infin-comp.
infinit-comp-eq := infinit-comp.
infinit-comp-arb := infinit-comp.
pre-comp := fin-infin-comp.

connadv := non-selct.
s√•-conn := connadv & s√•-k.
videre-conn := connadv & videre-k.
deretter-conn := connadv & deretter-k.
og-conn := connadv & og-k.

adv-s := non-selct.
ikke-adv-s := adv-s & ikke-k.
egentlig-adv-s := adv-s & egentlig-k.
kanskje-adv-s := adv-s & kanskje-k.
s√•-adv-s := adv-s & s√•-k.
mon-adv-s := adv-s & mon-k.
neppe-adv-s := adv-s & neppe-k.
overhodet-adv-s := adv-s & overhodet-k.
heller-adv-s := adv-s & heller-k.
sannsynligvis-adv-s := adv-s & sannsynligvis-k.
virkelig-adv-s := adv-s & virkelig-k.
antakeligvis-adv-s := adv-s & antakeligvis-k.
antageligvis-adv-s := adv-s & antageligvis-k.
antagelig-adv-s := adv-s & antagelig-k.
antakelig-adv-s := adv-s & antakelig-k.
trolig-adv-s := adv-s & trolig-k.
aldri-adv-s := adv-s & aldri-k.
aldri-noensinne-adv-s := adv-s & aldri-noensinne-k.
noensinne-adv-s := adv-s & noensinne-k.
forh√•pentligvis-adv-s := adv-s & forh√•pentligvis-k.
forh√•pentlig-adv-s := adv-s & forh√•pentlig-k.
alltid-adv-s := adv-s & alltid-k.
sjelden-adv-s := adv-s & sjelden-k.
tidligere-adv-s := adv-s & tidligere-k.
ofte-adv-s := adv-s & ofte-k.
heldigvis-adv-s := adv-s & heldigvis-k.
eksempelvis-adv-s := adv-s & eksempelvis-k.
for-eksempel-adv-s := adv-s & for-eksempel-k.
nettopp-adv-s := adv-s & nettopp-k.
ensidig-adv-s := adv-s & ensidig-k.
akkurat-adv-s := adv-s & akkurat-k.
allerede-adv-s := adv-s & allerede-k.
ogs√•-adv-s := adv-s & ogs√•-k.
og-adv-s := adv-s & og-k.
alts√•-adv-s := adv-s & alts√•-k.
fremdeles-adv-s := adv-s & fremdeles-k.
uansett-adv-s := adv-s & uansett-k.
forresten-adv-s := adv-s & forresten-k.
faktisk-adv-s := adv-s & faktisk-k.
just-adv-s := adv-s & just-k.
igjen-adv-s := adv-s & igjen-k.
likevel-adv-s := adv-s & likevel-k.
allikevel-adv-s := adv-s & allikevel-k.
vel-adv-s := adv-s & vel-k.
ei-adv-s := adv-s & ei-k.
ellers-adv-s := adv-s & ellers-k.
derfor-adv-s := adv-s & derfor-k.
muligvis-adv-s := adv-s & muligvis-k.
dermed-adv-s := adv-s & dermed-k.
endatil-adv-s := adv-s & endatil-k.
attp√•til-adv-s := adv-s & attp√•til-k.
ergo-adv-s := adv-s & ergo-k.
selvsagt-adv-s := adv-s & selvsagt-k.
;bare-adv-s := adv-s & bare-sadv-k.
bare-adv-s := adv-s & bare-k.
kun-adv-s := adv-s & kun-k.
selv-adv-s := adv-s & selv-k.
til-og-med-adv-s := adv-s & til-og-med-k.

selvf√∏lgelig-adv-s := adv-s & selvf√∏lgelig-k.

dog-adv-s := adv-s & dog-k.
nylig-adv-s := adv-s & nylig-k.
jevnlig-adv-s := adv-s & jevnlig-k.
endog-adv-s := adv-s & endog-k.
slik-adv-s := adv-s & slik-k.
imidlertid-adv-s := adv-s & imidlertid-k.

n√∏dvendigvis-adv-s := adv-s & n√∏dvendigvis-k.
naturligvis-adv-s := adv-s & naturligvis-k.
muligens-adv-s := adv-s & muligens-k.
;mon-adv-s := adv-s & mon-k.
riktignok-adv-s := adv-s & riktignok-k.
nemlig-adv-s := adv-s & nemlig-k.
for-s√•-vidt-adv-s := adv-s & for-s√•-vidt-k.
for√∏vrig-adv-s := adv-s & for√∏vrig-k.
f√∏lgelig-adv-s := adv-s & f√∏lgelig-k.
;bare-adv-s := adv-s & bare-k.
helst-adv-s := adv-s & helst-k.
likeledes-adv-s := adv-s & likeledes-k.
likes√•-adv-s := adv-s & likes√•-k.
istedet-adv-s := adv-s & istedet-k.
ingenlunde-adv-s := adv-s & ingenlunde-k.
iallfall-adv-s := adv-s & iallfall-k.
hittil-adv-s := adv-s & hittil-k.
herved-adv-s := adv-s & herved-k.
fortrinnsvis-adv-s := adv-s & fortrinnsvis-k.

gjerne-adv-s := adv-s & gjerne-k.
alternativt-adv-s := adv-s & alternativt-k.
dessverre-adv-s := adv-s & dessverre-k.
dessuten-adv-s := adv-s & dessuten-k.
dernest-adv-s := adv-s & dernest-k.
derimot-adv-s := adv-s & derimot-k.
tydeligvis-adv-s := adv-s & tydeligvis-k.
nok-adv-s := adv-s & nok-k.
noen-ganger-adv-s := adv-s & noen-ganger-k.
deriblant-adv-s := adv-s & deriblant-k.
engang-adv-s := adv-s & engang-k.
for-det-meste-adv-s := adv-s & for-det-meste-k.
videre-adv-s := adv-s & videre-k.
deretter-adv-s := adv-s & deretter-k.
halvveis-adv-s := adv-s & halvveis-k.




adv-m := selct.

relprn := adhoc-abnorm & non-measurnoun.
som-subjgap := relprn & som-k.
som-subjrelprn := relprn & som-k.
hvilket-subjrelprn := relprn & som-k.
som-fillerrelprn := relprn & som-k.
hvilket-fillerrelprn := relprn & som-k.

quantas := non-selct.
name-of-card := quantas.
crdfix := quantas.
klokkfix := name-of-card & crdfix.
; 'measnoun' to enable "Jon g√•r to femti", as length,
; and 'meastimenoun' to enable "Jon g√•r p√• to femti", as time spent
crdnum := crdfix & weaklic & measnoun & meastimenoun.

adv-nonselct := non-selct.

measurnoun := non-selct.
non-measurnoun := non-selct.
measnoun := measurnoun. ; & takes-sg-spc.
meastimenoun := measurnoun.
meastime-takes-pl-sp := meastimenoun & msr-takes-pl-spc.
meastime-takes-sg-sp := meastimenoun & msr-takes-sg-spc.
regnoun := non-measurnoun.
propnoun := non-measurnoun.
animnoun:= non-selct.
inanimnoun:= non-selct.
relnoun := regnoun.
absnoun := regnoun.
langage := inhr-comp. ;reginan. ;regnoun.
reganim := animnoun & absnoun.
reginan := inanimnoun & absnoun.
relanim := animnoun & relnoun.
relinan-sup := inanimnoun & relnoun.
relinan := relinan-sup.
fact := relinan-sup.
hensyn_n-k := predsort.
rel-hensyn := relinan & hensyn_n-k.
grense_n-k := predsort.
rel-grense := relinan & grense_n-k.
sikkerhet_n-k := predsort.
rel-sikkerhet := relinan & sikkerhet_n-k.
mot_n-k := predsort.
rel-mot := relinan & mot_n-k.
bak_n-k := predsort.
rel-bak := relinan & bak_n-k.
under_n-k := predsort.
rel-under := relinan & under_n-k.
ved_n-k := predsort.
reg-ved := reginan & ved_n-k.
t√∏ys_n-k := predsort.
tull_n-k := predsort.
snakk_n-k := predsort.
snikksnakk_n-k := predsort.
bullshit_n-k := predsort.

t√∏ys-inhcmp := inhr-comp & t√∏ys_n-k.
tull-inhcmp := inhr-comp & tull_n-k.
snakk-inhcmp := inhr-comp & snakk_n-k.
snikksnakk-inhcmp := inhr-comp & snikksnakk_n-k.
bullshit-inhcmp := inhr-comp & bullshit_n-k.

takes-pl-spc := measurnoun.
takes-sg-spc := measurnoun.
takes-adj := measurnoun.
msr-takes-pl-spc := measnoun & takes-pl-spc.
msr-takes-sg-spc := measnoun & takes-sg-spc.
msr-takes-adj := measnoun & takes-adj.
timemeas-noun:= meastimenoun & crdfix. 
tmsr-takes-pl-spc := timemeas-noun & takes-pl-spc.
tmsr-takes-sg-spc := timemeas-noun & takes-sg-spc.
tmsr-takes-adj := timemeas-noun & takes-adj.
;weekday-noun:= meastimenoun. 
weekday-noun:= timemeas-noun & takes-sg-spc. 
;daytime-noun:= meastimenoun. 
daytime-noun:= timemeas-noun & takes-sg-spc. 
;year-noun:= meastimenoun & crdfix. 
year-noun:= timemeas-noun & takes-sg-spc. 
week-noun:= timemeas-noun & takes-sg-spc. 
timeperiod-noun:= meastimenoun & crdfix. 
;dirnoun := non-measurnoun.
dirnoun := relnoun.
propanim := animnoun & propnoun.
propinan := inanimnoun & propnoun.
persprn := non-measurnoun.
explprn := non-measurnoun.

mealnoun := adhoc-norm.
; Commented out REGINAN, to hinder pres-participle from being applied to measure rules.
; EAA030811.
day-and-meal := mealnoun & daytime-noun. ; & reginan.
;day-and-meal := reginan.
;LH 050811: commented in again, needed for restraining "til" for "til lunsj"
;LH200811 - and out again, it yields 'en' combining by measure-np-rule in caes where it shouldnt (like 'en st√∏rre' in 'en st√∏rre mann enn...' 'til lunsj' will requirw other means...
;day-and-meal := mealnoun & daytime-noun & reginan.

inhr-comp := non-selct. ;non-measurnoun.
leir-inhcmp := inhr-comp & leir-k.
d√∏d-inhcmp := inhr-comp & d√∏d-k.
smil-inhcmp := inhr-comp & smil-k.
latter-inhcmp := inhr-comp & latter-k.
s√∏vn-inhcmp := inhr-comp & s√∏vn-k.
ting-inhcmp := inhr-comp & ting-k.
;rundtur-inhcmp := inhr-comp.
fl√∏yten-inhcmp := inhr-comp & fl√∏yten-k.
has-inhcmp := inhr-comp & has-k.
vakt-inhcmp := inhr-comp & vakt-k.
dagtid-inhcmp := inhr-comp & dagtid-k.

locomotion-event-inhcmp := inhr-comp & dirnoun.
tur-inhcmp-sup := locomotion-event-inhcmp.
reise-inhcmp-sup := locomotion-event-inhcmp.
tur-inhcmp := tur-inhcmp-sup & tur-k.
g√•tur-inhcmp := tur-inhcmp-sup & g√•tur-k.
busstur-inhcmp := tur-inhcmp-sup & busstur-k.
fjelltur-inhcmp := tur-inhcmp-sup & fjelltur-k.
biltur-inhcmp := tur-inhcmp-sup & biltur-k.
bytur-inhcmp := tur-inhcmp-sup & bytur-k.
rundtur-inhcmp := tur-inhcmp-sup & rundtur-k.
klatretur-inhcmp := tur-inhcmp-sup & klatretur-k.
topptur-inhcmp := tur-inhcmp-sup & topptur-k.
reise-inhcmp := reise-inhcmp-sup & reise-k.
flyreise-inhcmp := reise-inhcmp-sup & flyreise-k.
flight-inhcmp := reise-inhcmp-sup & flight-k.
bussreise-inhcmp := reise-inhcmp-sup & bussreise-k.
togreise-inhcmp := reise-inhcmp-sup & togreise-k.
b√•treise-inhcmp := reise-inhcmp-sup & b√•treise-k.
skyss-inhcmp := reise-inhcmp-sup & skyss-k.

vehicle-for-locomotion-inhcmp := inhr-comp & dirnoun.
buss-inhcmp-sup := vehicle-for-locomotion-inhcmp.
buss-inhcmp := buss-inhcmp-sup & buss-k.
bil-inhcmp-sup := vehicle-for-locomotion-inhcmp.
bil-inhcmp := bil-inhcmp-sup & bil-k.
b√•t-inhcmp-sup := vehicle-for-locomotion-inhcmp.
b√•t-inhcmp := b√•t-inhcmp-sup & b√•t-k.
fly-inhcmp-sup := vehicle-for-locomotion-inhcmp.
fly-inhcmp := fly-inhcmp-sup & fly-k.
tog-inhcmp-sup := vehicle-for-locomotion-inhcmp.
tog-inhcmp := tog-inhcmp-sup & tog-k.
ferje-inhcmp-sup := vehicle-for-locomotion-inhcmp.
ferje-inhcmp := ferje-inhcmp-sup & ferje-k.


path-of-locomotion-inhcmp := inhr-comp & dirnoun.
vei-inhcmp-sup := path-of-locomotion-inhcmp.
vei-inhcmp := vei-inhcmp-sup & vei-k.
gate-inhcmp-sup := path-of-locomotion-inhcmp.
gate-inhcmp := gate-inhcmp-sup & gate-k.
sti-inhcmp-sup := path-of-locomotion-inhcmp.
sti-inhcmp := sti-inhcmp-sup & sti-k.
fortau-inhcmp-sup := path-of-locomotion-inhcmp.
fortau-inhcmp := fortau-inhcmp-sup & fortau-k.
motorvei-inhcmp-sup := path-of-locomotion-inhcmp.
motorvei-inhcmp := motorvei-inhcmp-sup & motorvei-k.
bane-inhcmp-sup := path-of-locomotion-inhcmp.
bane-inhcmp := bane-inhcmp-sup & bane-pth-k.
rute-inhcmp-sup := path-of-locomotion-inhcmp.
rute-inhcmp := rute-inhcmp-sup & rute-k.
bro-inhcmp-sup := path-of-locomotion-inhcmp.
bro-inhcmp := bro-inhcmp-sup & bro-k.
tunnel-inhcmp-sup := path-of-locomotion-inhcmp.
tunnel-inhcmp := tunnel-inhcmp-sup & tunnel-k.
bakke-inhcmp-sup := path-of-locomotion-inhcmp.
bakke-inhcmp := bakke-inhcmp-sup & bakke-pth-k.
trapp-inhcmp-sup := path-of-locomotion-inhcmp.
trapp-inhcmp := trapp-inhcmp-sup & trapp-k.
linje-inhcmp-sup := path-of-locomotion-inhcmp.
linje-inhcmp := linje-inhcmp-sup & linje-k.
spor-inhcmp-sup := path-of-locomotion-inhcmp.
spor-inhcmp := spor-inhcmp-sup & spor-k.


nom-k := reganim & reginan & relinan & relanim & dirnoun.
anonym-k := reganim & reginan & relinan & relanim & dirnoun & propt. 
propnoun-k := propnoun.

vb := adhoc-norm.
mainvb := vb.
; 'resultvb' is used in one rule only: pastparticpl-from-active-adj-word. The lextypes where it is used are v-intrResult (ca 10 verbs), v-presResult (less tha 10).
resultvb := vb.
; if we have this one, we need 70...
gapping-conj := vb.
; used in one rule - head-verb-mannadverb-comp-phrase, and in one lex-type: v-intrOblAdv with 1 verb.
advoblvb := mainvb.
; used in one rule: adjective-mod-vp-phrase
mainvb-norm := mainvb.
mainvb-1 := mainvb.
; used in one verb, namely ha_tr_vlxm. No rule includes the feature.
mainvb-nofreepred := mainvb.

beg√•-vb := beg√•_v-k & mainvb.
falle-vb := falle_v-k & mainvb.
hoppe-vb := hoppe_v-k & mainvb.
falle-hoppe-vb := falle-vb & hoppe-vb.
la-sangen-synge-vb := la-sangen-synge-k & mainvb.
auxvb := vb.
interjct := vb.

start-parenth := adhoc-norm.
end-parenth := adhoc-norm.
start-quote := adhoc-norm.
end-quote := adhoc-norm.

; TENSE values
non-finite := tense.
finite := tense.
s-pass-tenses := tense.
pres := finite & s-pass-tenses.
pret := finite & s-pass-tenses.
infin := non-finite & s-pass-tenses.
perf := non-finite.
prespartcpl := non-finite.

imperative := mood.

indicative := mood.
hortative := mood.


; DEGREE values
degree := avm.
positive := degree.
comparative := degree.
superlative := degree.

;; HEAD values

poss-subj-head := head &
  [ RELATIVPRON bool,
    TRANSPAR bool ].
card-nom := head.

np-head := poss-subj-head & 
  [ COORDINABLE bool,
    PRESENTED bool,
    DEFINITE bool,
    DEF bool ].

allquant := np-head &
  [ COORDINABLE + ] & [POS tag-QUANT].
headx := head.
interjection := head &
  [KEYS.KEY interjct,
   INTERJECT bool] & [POS tag-Interjct].
cl-adjct := headx.
headz := headx.
possparticle := poss.
poss := headx & [POS tag-PNposs].
; SELECTED is brought higher up in the system than one might
; think necessary, but we need it for adv and prep and comp, and
; for now, this is the lowest possible
heady := headz &
  [ SELECTED bool,
    DEGREE degree].
; sic, to rstrict measure-np-cmpar-phrase
verb-all-or-noun := heady.; &
; [DEGREE positive].
verb-or-noun := verb-all-or-noun.
posspron := poss.
postposspron := poss.
;possnoun := nom &
;  [ COORDINABLE + ]. ; LH050214  was never used, it seems
prep-or-verb := heady &
 [ MODALITY modality ].
nominal := heady & nominal-or-connect-n.

nominal-or-connect-n := np-head.


nom := nominal &
  [CAN-MAIN-CLAUSE bool].
expl-pron := nom &
  [ COORDINABLE -,
    EXPLETIVE +,
    POS tag-EXPL].
pers-pron := nom &
  [ COORDINABLE + ,
    EXPLETIVE - ] & [POS tag-PN].
rel-filler := np-head & [RELATIVPRON bool].
rel-pron := poss-subj-head & comp &
  [ RELATIVPRON +,
    EXPLETIVE - ] & [POS tag-PNrel].
resumpt-pron := nom &
  [ COORDINABLE -,
    EXPLETIVE - ].
; attachment points of cmpar-clauses
n-or-adj-or-adv := head.
n-or-adj := head & [COMPAR-DEP adhoc-abnorm].

; n-or-adj-or-adv
noun := nom & verb-or-noun & n-or-adj-or-adv & n-or-adj & card-nom & 
  [ BARE bool,
;    COORDINABLE +,
    EXPLETIVE - ].
comm-noun := noun & [POS tag-N,
		     RELATIONAL bool].
prop-noun := noun & [POS tag-Nprop].
;; nb! check all partitive expressions!
part-prep := nom &
  [ COORDINABLE -, POS tag-P].
modality := avm.
deontic := modality.
non-deontic := modality.
volitional := non-deontic.
epistemic := non-deontic.
ability := non-deontic.
faa-deontic := deontic.
non-faa-deontic := deontic.
voice := avm.
active := voice.
passive := voice.
s-pass := passive.
ptc-pass := passive.
;verb-or-comp := prep-or-verb & poss-subj-head &
verb-or-comp := prep-or-verb & 
  [ MAIN-CL bool,
    INV bool,
    IMPERATIVE bool,
    DECL bool,
    CONDITIONAL bool,
    VOICE voice,
    WH-COMPLETE bool,
    WH-MOVED bool].
verb-all := verb-or-comp & verb-all-or-noun &
 [ COP bool] & [POS tag-V].

copula := verb-all &
	  [ COP + ].     ; can only be copula
non-copula := verb-all &
	      [ COP - ].
;non-copula := verb-aux-or-stndrd &
;	      [ COP - ].
verb-aux := non-copula.  ; can only be aux
verb := non-copula & verb-or-noun.  ; can be standard verb or aux

;verb-or-comp-or-prep := verb-or-comp.

#|
verb-cop-or-stndrd := verb-all.   ; can be standard verb or copula
verb-aux-or-stndrd := verb-all.   ; can be standard verb or aux
verb-aux := verb-aux-or-stndrd.  ; can only be aux
verb := verb-aux-or-stndrd & verb-or-noun.    ; can be standard verb
verb-stndrd := verb-aux-or-stndrd & verb-cop-or-stndrd.


copula := verb-all &
	  [ COP + ].     ; can only be copula
non-copula := verb-all &  ; stnd or aux
	      [ COP - ].
verb-aux := non-copula.
verb := non-copula & verb-or-noun.  ; can be standard verb only
; we need also stnd or cop
verb-or-cop := copula & verb.


verb-non-aux := verb-all.
verb-stnd := verb-all.
verb-stnd-or-aux := verb-stnd & verb-aux.
verb-stnd-or-cop := verb-stnd & copula.
|#

det := q &
  [ MOD <>,
    PROXIM bool ] & [POS tag-DET].

;LH050513 - hvor mange/mye/stor
q := nominal & adjectival &
  [COORDINABLE + ].
art := q & [POS tag-ART].
;possart := art & possparticle.
quantor := q & [POS tag-QUANT].
quant:= quantor & comparative-adv.
adj-quant := quant.
n-quant := quant.
prep-or-adj-or-adv := heady.
prep-or-adj := prep-or-adj-or-adv.
adjectival := heady.
; n-or-adj-or-adv
;adjectival & 
; this leads to head-cop-prepadv-comp-phrase combining random forms of adj with copula, in violation of agreement. Therfore going back to previous, and be prepared to solve what prompted this definition by other means. see massifcentral-testsuites and test-ch1-6, from around 10th of July.
;adj := n-or-adj-or-adv & n-or-adj & comparative-adv &
;  [ WEAK bool ] is introduced higher up, to facilitate rule subsumption.
adj := n-or-adj-or-adv & n-or-adj & adjectival &
[ WEAK bool,
  ORDINAL bool ].
adj-reg := adj & prep-or-adj & [POS tag-ADJ].
degspr := adjectival & [KEYS.KEY degreer] & [POS tag-DEG].
card := adjectival & card-nom & [POS tag-CARD].
ord := adj & [POS tag-ORD] & [ORDINAL +].
cardnum := card & np-head.
cardquant := card & np-head.
; feb18-06: was earlier := adjectival, and probl with "tre cm mer enn to meter
; h√∏yere enn"
comparative-adv := prep-or-adv & adjectival.
cmpar-reg-adv := comparative-adv & [POS tag-ADV].
cmpar-close-adv := comparative-adv & quantor.
cmpar-dep := head & [POS tag-PRTcmpr].
cmpar-dep-close := cmpar-dep.
cmpar-dep-reg := cmpar-dep.
;prep := prep-or-verb.
prep-or-comp := heady &
  [ TEL-FIXING bool ].
comp := prep-or-comp & verb-or-comp.
glob-comp := comp & np-head.
;  poss-subj-head &
fin-comp := glob-comp &
  [ TRANSPAR - ] & [POS tag-COMP].
; poss-subj-head & 
infin-comp := glob-comp & [POS tag-COMP].
adjct-comp := comp & [POS tag-COMP].

som-or-for := prep-ultra.; & verb-or-comp.
for-cmp := glob-comp & [POS tag-COMP].
prep-or-adv := prep-or-adj-or-adv &
  [ LEG-SWITCH bool ].
adv-super := prep-or-adv.
; n-or-adj-or-adv
adv := adv-super & prep-adv & n-or-adj-or-adv & adjectival.
a := adj & adv.
adv-reg := adv &
  [ DEGREE positive ] & [POS tag-ADV].
refl-adv := head & [POS tag-ADV].
adv-particle := adv-super & [POS tag-ADVprt].
; should be := adv-super, but accidents with head-comp-expl-...-rule ...
s-adv := cl-adjct & [POS tag-ADVs].
prep-adv := cl-adjct.
prep-ultra := prep-or-adv & prep-or-comp & prep-or-adj & [POS tag-P]. ;& verb-or-comp-or-prep 
;prep-super := prep-ultra.
prep := prep-ultra & prep-adv & [N-to-N-RELATIONAL-P bool].
;prep-contr := prep-super.
prep-comp := prep-ultra.

connect := headz & [POS tag-CONJ].
punct := connect & [KEYS.KEY punctuator].
conn-pos := connect.
conn-adv := conn-pos.
conn-coord := conn-pos.
coord := conn-pos & [KEYS.KEY coordinator].
word-coord := coord & [POS tag-CONJ].
comma-coord := coord & [POS tag-CONJ].
correl-coord := conn-pos.
enclosing-mark := headz.
parenthesis := enclosing-mark & [POS tag-PUNCT].
quotation-mark := enclosing-mark & [POS tag-PUNCT].

comma-punctuation := punctuator.
period-punctuation := punctuator.
colon-punctuation := punctuator.
semicolon-punctuation := punctuator.
questionmark-punctuation := punctuator.
exclamationmark-punctuation := punctuator.
gedankenmark-punctuation := punctuator.


connect-n := nominal-or-connect-n & [POS tag-CONJ].
;connect-n-or-nominal := np-head.

;connect-n := comm-noun.


; BASIC LEX-ITEMS TYPES

; on POS:
tag-pos := avm.
tag-ADJ := tag-pos.
tag-Interjct := tag-pos.
tag-INF := tag-pos.
tag-COMP := tag-pos.
tag-PNrel := tag-pos.
tag-PNrefl := tag-pos.
tag-PRTpred := tag-pos.
tag-ADV := tag-pos.
tag-ADVs := tag-pos.
tag-ADVprt := tag-pos.
tag-PRTcmpr := tag-pos.
tag-P := tag-pos.
tag-V := tag-pos.
tag-N := tag-pos.
tag-PNinterr := tag-pos.
tag-PN := tag-pos.
tag-Nprop := tag-pos.
tag-DEM := tag-pos.
tag-DET := tag-pos.
tag-EXPL := tag-pos.
tag-ART := tag-pos.
tag-PNposs := tag-pos.
tag-QUANTinterr := tag-pos.
tag-QUANT := tag-pos.
tag-DEG := tag-pos.
tag-CARD := tag-pos.
tag-ORD := tag-pos.
tag-PUNCT := tag-pos.
tag-CONJ := tag-pos.


lex-item-1rel := word-or-lexrule &
  [SYNSEM.LOCAL.CONT [RELS [ LIST.FIRST #2 & [ARG0 #1],
                             LIST.REST #rest,
                             LAST #rest ],
                      HOOK.INDEX #1],
   SYNSEM.LKEYS.KEYREL #2 & relation,
   SYNSEM.NON-LOCAL.SLASH diff-list  ].

lex-item-sinarg0-1rel := word-or-lexrule &
  [SYNSEM.LOCAL.CONT [RELS [ LIST.FIRST #2,
                             LIST.REST #rest,
                             LAST #rest ]],
   SYNSEM.LKEYS.KEYREL #2 & relation,
   SYNSEM.NON-LOCAL.SLASH diff-list  ].

; & [ ARG0 #1] 
;LIST.FIRST #key,
;SYNSEM.LKEYS.KEYREL #key & [ ARG0 #1], - in order to get index right for resultative secpred
lex-item-2rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST #rest],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key & [ ARG0 #1],
  SYNSEM.LKEYS.ALTKEYREL #relation].


  

lex-item-sinarg0-2rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST #rest],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation & [ ARG0 #1] ].

lex-item-openarg0-2rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST #rest],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].

lex-item-3rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST relation,             
                                      REST [FIRST relation,
                                            REST #rest]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key & [ ARG0 #1]].

lex-item-sinarg0-3rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST [FIRST relation,
                                            REST #rest]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation & [ ARG0 #1]].



lex-item-4rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,
                                      REST [FIRST relation,
                                            REST [FIRST relation,
                                                  REST  #rest]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].



lex-item-4rel-xtra := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key & [ ARG0 #1],
                           LIST.REST [FIRST relation,
                                      REST [FIRST #relation,
                                            REST [FIRST relation,
                                                  REST  #rest]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].

; the XARG a bit suspicious here - making new version below...
; this one was used in the directional-adverb-decomposition
; grammar, and should be saved for its reappearance

#|
lex-item-5rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM. LOCAL.CONT.HOOK.XARG #4,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [ FIRST #relation & [ ARG0 #1,
                                                          ARG1 #4],
                                       REST [ FIRST relation,
                                              REST [ FIRST relation,
                                                     REST [ FIRST relation,
                                                            REST #rest]]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].
|#

lex-item-5rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,
                                      REST [FIRST relation,
                                            REST [FIRST relation,
                                                  REST [FIRST relation,
                                                        REST #rest]]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].

lex-item-6rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.HOOK.XARG #4,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [ FIRST #relation & [ ARG0 #1,
                                                           ARG1 #4 ],
                                      REST [ FIRST relation,
                                             REST [ FIRST relation,
                                                    REST [ FIRST relation,
                                                           REST [ FIRST relation,
                                                                  REST #rest]]]]],
                           LAST #rest ],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].



; this (expanded) type is equiv to 'norm-lex-item' (apart from IDIOMOD -
; used with prep-reg-2-word and pp-mod-phrase2
lbl-ltop-lex-item-super := lex-item-1rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1,
    SYNSEM.IDIOMOD bool ].

lbl-ltop-lex-item-sinarg0 := lex-item-sinarg0-1rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1,
    SYNSEM.IDIOMOD - ].

lbl-ltop-lex-item := lbl-ltop-lex-item-super &
  [ SYNSEM.IDIOMOD - ].

lbl-ltop-lex-item-idio := lbl-ltop-lex-item-super &
  [ SYNSEM.IDIOMOD + ].

lbl-ltop-lex-item-2rel := lex-item-2rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 
#|
lbl-ltop-lex-item-2rel-lbltweak := word-or-lexrule &
  [ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ PRED #key,
					  ARG0 #1 ],
			     LIST.REST [FIRST [LBL #10,
					       PRED #11,
					       ARG0 #12],             
					REST #rest],
			     LAST #rest],
    SYNSEM.LKEYS.KEYREL [ PRED #key,
			  ARG0 #1],
    SYNSEM.LKEYS.ALTKEYREL [LBL #10,
			    PRED #11,
			    ARG0 #12]]. 
|#

lbl-ltop-lex-item-2rel-lbltweak := word-or-lexrule &
  [ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
 ;   SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ PRED #key,
					  ARG0 #1 ],
			     LIST.REST [FIRST [PRED #11,
					       ARG0 #12],             
					REST #rest],
			     LAST #rest],
    SYNSEM.LKEYS.KEYREL [ PRED #key,
			  ARG0 #1],
    SYNSEM.LKEYS.ALTKEYREL [PRED #11,
			    ARG0 #12]]. 

#|
lbl-ltop-lex-item-2rel-lbltweak-argOoblq := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-argOx := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 
|#

lbl-ltop-lex-item-2rel-lbltweak-arg1 := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARG1 #1 ],
			     LIST.REST [FIRST [ARG1 #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARG1 #1],
    SYNSEM.LKEYS.ALTKEYREL [ARG1 #2]]. 

#|
lbl-ltop-lex-item-2rel-lbltweak-arg1oblq := lbl-ltop-lex-item-2rel-lbltweak-arg1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg1x := lbl-ltop-lex-item-2rel-lbltweak-arg1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 
|#

lbl-ltop-lex-item-2rel-lbltweak-arg12 := lbl-ltop-lex-item-2rel-lbltweak-arg1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARG2 #1 ],
			     LIST.REST [FIRST [ARG2 #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARG2 #1],
    SYNSEM.LKEYS.ALTKEYREL [ARG2 #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST arg0-relation,
			     LIST.REST [FIRST [ ARG1 #0,
						ARG2 #1 ] ]],             
    SYNSEM.LKEYS.KEYREL arg0-relation,
    SYNSEM.LKEYS.ALTKEYREL [ ARG1 #0,
			     ARG2 #1] ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a1 := lbl-ltop-lex-item-2rel-lbltweak-arg12a &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARG1 #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARG1 #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12aObl := lbl-ltop-lex-item-2rel-lbltweak-arg12a &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGOBLQ #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGOBLQ #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a1Obl := lbl-ltop-lex-item-2rel-lbltweak-arg12a1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGOBLQ #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGOBLQ #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a12 := lbl-ltop-lex-item-2rel-lbltweak-arg12a1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARG2 #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARG2 #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a12Obl := lbl-ltop-lex-item-2rel-lbltweak-arg12a12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGOBLQ #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGOBLQ #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12ax := lbl-ltop-lex-item-2rel-lbltweak-arg12a &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGX #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGX #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a1x := lbl-ltop-lex-item-2rel-lbltweak-arg12a1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGX #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGX #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a12x := lbl-ltop-lex-item-2rel-lbltweak-arg12a12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGX #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGX #1 ]. 





#|
lbl-ltop-lex-item-2rel-lbltweak-arg12oblq := lbl-ltop-lex-item-2rel-lbltweak-arg12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12x := lbl-ltop-lex-item-2rel-lbltweak-arg12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg123 := lbl-ltop-lex-item-2rel-lbltweak-arg12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARG3 #1 ],
			     LIST.REST [FIRST [ARG3 #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARG3 #1],
    SYNSEM.LKEYS.ALTKEYREL [ARG3 #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg123oblq := lbl-ltop-lex-item-2rel-lbltweak-arg123 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg123x := lbl-ltop-lex-item-2rel-lbltweak-arg123 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 
|#


#|
lbl-ltop-lex-item-2rel-lbltweak := word-or-lexrule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.ALTKEYREL.LBL #1 ]. 
|#

lbl-ltop-lex-item-sinarg0-2rel := lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 

lbl-ltop-lex-item-openarg0-2rel := lex-item-openarg0-2rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 

lbl-ltop-lex-item-3rel := lex-item-3rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-sinarg0-3rel := lex-item-sinarg0-3rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 


lbl-ltop-lex-item-4rel := lex-item-4rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-4rel-xtra := lex-item-4rel-xtra &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-5rel := lex-item-5rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-6rel := lex-item-6rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.RELS <! [], [ LBL #1 ], [], [], [], [] !> ].

#|
SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
SYNSEM.LOCAL.CONT.HOOK.XARG #mod,
|#

;LH100713: removed within MOD: LOCAL.CONT.HOOK.INDEX #1   since that blocked combinations like 'over en bekk og under en bro', where 'og' mediates an adjunction between identical ARG0s, and the restriction forced a collision between 'xdim' and 'xdim-to-xdim'. ALERT then for all items inheriting from this type!
reg-mod-lex-item := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1 ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

dir-mod-lex-item := lbl-ltop-lex-item & norm-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.DIRARG #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS olist]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE line-to-xdim-spatial,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

dir-mod-lex-item-2 := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.DIRARG #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1,
                         LBL #2 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE line-to-xdim-spatial,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

xarg-mod-lex-item-2 := lbl-ltop-lex-item-idio &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.XARG #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1,
                                  LBL #2 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; ,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1
reg-mod-lex-item-2rel := lbl-ltop-lex-item-openarg0-2rel &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC <> ],
    SYNSEM.LOCAL.CONT.HCONS <! [] !> ].



;;; PRO FORMA TYPES, for the BIG LEXICON

unknown-lxm := lexeme & lbl-ltop-lex-item.
x-noun-lxm := noun-lexeme.

; LH030214: phantom category matching Tore's 'some-word' in the lexicons created off the RSS files. Provides analyses for any word - but with exploding forests. Perhaps something for shallow parsing, although not sure.
some-word := lbl-ltop-lex-item & word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD head,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

;; proforma types, now in lex3.prep-adv-nonass.tdl
prep-nonassigned-word := reg-mod-lex-item & prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] > ].
adv-nonassigned-word := reg-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] > ].

complementizer-word := basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL.SUBJ antilist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4]>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                               ARG1 #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].


cond-complementizer-word := basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4]>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                               ARG1 #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

co-conj-word := word & lbl-ltop-lex-item.

; WORD TYPES

;;; COORDINATORS

resumptive-gap := word &
  [ SYNSEM gap & [ LOCAL.CAT.HEAD rel-pron & [ACCUSATIVE - ]] ].

; verb-all -> head
end-punct := reg-mod-lex-item & const-ltow-rule &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD punct & [MOD <[ LOCAL.CAT.HEAD head,
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.IS-PUNCT +   ].

#|
punctuation-sign := reg-mod-lex-item & const-ltow-rule &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD punct & [MOD <[ LOCAL.CAT.HEAD head,
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.IS-PUNCT +   ].

comma-sign := punctuation-sign &
 [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY comma-punctuation ].
|#

decl-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY period-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL [ CAT.HEAD verb-all & [ DECL + ],
					    CONT.HOOK.INDEX.SF prop-or-comm ]] >],
     SYNSEM.LKEYS.KEYREL [ PRED "_period-punctuated_rel" ]].

interjct-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY period-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL.CAT.HEAD interjection ]> ]].

n-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY period-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL.CAT.HEAD np-head ]> ]].

adj-or-adv-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY period-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL.CAT.HEAD adjectival ]> ]].

prep-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY period-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL.CAT.HEAD prep-ultra ]> ]].

quest-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY questionmark-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL [ CAT.HEAD [ IMPERATIVE - ],
					   CONT.HOOK.INDEX.SF ques ]] > ],
     SYNSEM.LKEYS.KEYREL [ PRED "_quest-punctuated_rel" ]].

; exclamation mark goes well with declarative force, for expressing enthusiasm, surprise etc.
;commd-end-punct := end-punct &
;  [  SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL -,
;                                                    IMPERATIVE + ] ]>],
;     SYNSEM.LKEYS.KEYREL [PRED "_exclam-punctuated_rel"]].

commd-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY exclamationmark-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL [ CONT.HOOK.INDEX.SF prop-or-comm ]] > ],
     SYNSEM.LKEYS.KEYREL [PRED "_exclam-punctuated_rel"]].

colon-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY colon-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL + ] ]>],
     SYNSEM.LKEYS.KEYREL [PRED "_colon-punctuated_rel"]].

semicolon-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY semicolon-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL + ] ]>],
     SYNSEM.LKEYS.KEYREL [PRED "_semicolon-punctuated_rel"]].

gedankenstrech-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY gedankenmark-punctuation],
     SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL + ] ]>],
     SYNSEM.LKEYS.KEYREL [PRED "_gedankestrech-punctuated_rel"]].



p-adv-connector := reg-mod-lex-item & const-ltow-rule &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY reg],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

p-adv-clause-connector := reg-mod-lex-item & const-ltow-rule &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep-or-comp & [KEYS.KEY reg],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
;     SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

p-adv-dir-connector := reg-mod-lex-item & const-ltow-rule &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY dir],
                                             LOCAL.CAT.VAL.COMPS list ]>], ;<>
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

#|
n-connector := reg-mod-lex-item-2rel &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD np-head,
                                             LOCAL.CAT.VAL.COMPS <> ]>],
;     SYNSEM.LOCAL.XLBL #lbl,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
     SYNSEM.LKEYS.KEYREL [ ARG0 #ind ],
     SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [PRED "_udef_q_rel",
					      ARG0 #ind,
					      RSTR #rstr], 
			     [ PRED "_set_rel",
			       LBL #lbl,
			       ARG0 #ind ]  !>,
     SYNSEM.LOCAL.CONT.HCONS <! [HARG #rstr,
				 LARG #lbl] !>  ].
|#

n-connector-2 := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD np-head,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.COORD-RELEASED + ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

n-connector := lbl-ltop-lex-item-2rel &
  [  SYNSEM.LOCAL.CAT.HEAD np-head,
     SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD np-head,
				LOCAL.COORD-RELEASED -]>, 
     SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head,
				  LOCAL.DERIVED-BARE-N-FROM-ADJ -]>, ; to avoid "som ny" in oppfatte som ny to fall under this
     SYNSEM.LOCAL.CONT.HOOK.INDEX #ind, ; & [WH +], specification allowed, but no parses with the use of the rule
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LKEYS.KEYREL [ ARG0 #ind ],
     SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #ind,
					      RSTR #rstr], 
			     [ PRED "_set_rel",
			       LBL #lbl,
			       ARG0 #ind ]  !>,
     SYNSEM.LOCAL.CONT.HCONS <! [HARG #rstr,
				 LARG #lbl] !>  ].

p-clse-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep & [KEYS.KEY der-n√•r],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD verb-or-comp]>,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

rel-cl-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb,
                                                                        INV -],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

rel-cl-nonrestr-connector := lbl-ltop-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb,
                                                                        INV -],
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.LTOP #1 ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! adj_rel & [PRED "_nonrestr-comment_rel",
                                                ARG1 #1 ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

n-nonrestr-connector := lbl-ltop-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD np-head,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.COORD-RELEASED +,
                                             LOCAL.CONT.HOOK.LTOP #1 ]>],
     SYNSEM.LOCAL.CONT.RELS <! adj_rel & [PRED "_nonrestr-comment_rel",
                                                ARG1 #1 ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

vcond-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb],
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

vcond-connector-2 := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD adjct-comp,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

v-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >, 
     SYNSEM.LOCAL.CAT.VAL.SUBJ list, ;<>, ; these constraints in order to distinguish it from gapping-conjunction, which feeds on gobbling arguments LH111021 Too strong, blocks normal VP coordination LH251021
     SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod,
     SYNSEM.LOCAL.GAPPING -, 
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-or-comp & [KEYS.KEY vb], ;verb-all
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD mood ]>],
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

; not used
v-gap-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod,
     SYNSEM.LOCAL.GAPPING -, 
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-or-comp & [KEYS.KEY vb], ;verb-all
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD mood ]>], 
     SYNSEM.LOCAL.CAT.VAL.COMPS < [], [] >,
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

v-comp-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.GAPPING -,
;     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD fin-comp,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD mood ]>],
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

v-infin-comp-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
;     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD infin-comp,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD mood ]>],
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

a-connector := reg-mod-lex-item & const-ltow-rule &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD adj-reg ]>],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

p-adv-connect-punctuation := p-adv-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

p-adv-clause-connect-punctuation := p-adv-clause-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

p-clse-connect-punctuation := p-clse-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

vcond-connect-punctuation := vcond-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.RIGHT-ADJ-SITE-OPEN +] >],
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

vcond-hvis-punctuation := vcond-connector-2 &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD.INV -] >],
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

interject-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD < [LOCAL.CAT.HEAD interjection & [KEYS.KEY interjct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !> ].

interject-connect-punctuation := interject-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD interjection & [KEYS.KEY interjct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"] ].

interject-connect-word := interject-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

adj-interject-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD connect & [MOD < [LOCAL.CAT.HEAD adj & [KEYS.KEY adj-decl-selct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.GAPPING -,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !> ].

adj-interject-connect-punctuation := adj-interject-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD adj & [KEYS.KEY adj-decl-selct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"] ].

quotation-connect-punctuation := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD verb-all,
                                           LOCAL.CAT.VAL.COMPS <>]  >],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"] ].

rel-cl-connect-punctuation := rel-cl-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

rel-cl-nonrestr-punctuation := rel-cl-nonrestr-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

app-punctuation := n-connector-2 &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

app-nonrestr-punctuation := n-nonrestr-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-connect-word := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

v-gap-connect-word := v-gap-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

v-connect-comma := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-connect-gedankenstreich := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-connect-semikolon := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-connect-kolon := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

;;;
v-comp-connect-word := v-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

v-comp-connect-comma := v-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT + ].
;;;
v-infin-comp-connect-word := v-infin-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

v-infin-comp-connect-comma := v-infin-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT + ].

;;;
v-comp-connect-gedankenstreich := v-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-comp-connect-semikolon := v-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-comp-connect-kolon := v-comp-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT + ].




a-connect-word := a-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

a-connect-comma := a-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT + ].

n-connect-word := n-connector &
  [  SYNSEM.LOCAL.CAT.HEAD connect-n,
     SYNSEM.LOCAL.IS-PUNCT - ]. ;nominal-or-

n-connect-comma := n-connector &
  [  SYNSEM.LOCAL.CAT.HEAD nominal-or-connect-n,
     SYNSEM.LOCAL.IS-PUNCT + ].

p-adv-connect-word := p-adv-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

p-adv-dir-connect-word := p-adv-dir-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

p-adv-connect-adv-word := p-adv-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
     SYNSEM.LOCAL.IS-PUNCT - ].

coordinating-pos-v-dir-word := coordinating-v-dir-word.
; & coordinating-pospol-word.

;coordinating-v-comma := coordinating-v-word-sup &
;  [ SYNSEM.LOCAL.CAT.HEAD comma-coord ].

coordinating-relcl-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD word-coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7 ],
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #8 & verb-all & [WH-COMPLETE +],
                                 LOCAL.CONT.HOOK.INDEX #6 & [E.TENSE #11],
                                 LOCAL.CAT.VAL [ COMPS #9,
                                                 ICOMPS #10 ]] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.XCAT.HEAD #8 & verb-all & [WH-COMPLETE +],
                                  LOCAL.CAT.VAL [ COMPS #9,
                                                  ICOMPS #10 ],
                                  LOCAL.CONT.HOOK.INDEX #1 & [SORT #7,
                                                              E.TENSE #11],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-adj-word-sup := word &
  [ SYNSEM.LOCAL.CAT.HEAD coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7 ],
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6,
							  L-HNDL #12 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #8 & adj-reg,
                                 LOCAL.CONT.HOOK.INDEX #6,
								 LOCAL.CONT.HOOK.LTOP #12,
                                 LOCAL.CAT.VAL [ COMPS #9,
                                                 ICOMPS #10 ]] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.CAT.HEAD #8 & adj,
                                  LOCAL.CAT.VAL [ COMPS #9,
                                                 ICOMPS #10 ],
                                  LOCAL.CONT.HOOK.INDEX #1 & [SORT #7],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-adj-word := coordinating-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD word-coord ].
coordinating-pos-adj-word := coordinating-adj-word.
; & coordinating-pospol-word.
coordinating-neg-adj-word := coordinating-adj-word.
; & coordinating-negpol-word.

coordinating-adj-comma := coordinating-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD comma-coord,
     SYNSEM.LOCAL.HAS-PUNCT + ].

coordinating-v-dir-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD adv-reg & [KEYS.KEY dir],
                                 LOCAL.CONT.HOOK.INDEX #6] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.XCAT.HEAD verb-all,
                                  LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE infin],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-coord-word-sup := word &
  [ SYNSEM.LOCAL.CAT.HEAD coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7],
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CONT.HOOK.INDEX #6] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.CAT.HEAD coord,
                                  LOCAL.CONT.HOOK.INDEX #1 & [SORT #7],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-coord-word := coordinating-coord-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD word-coord ].
coordinating-coord-comma := coordinating-coord-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD comma-coord,
     SYNSEM.LOCAL.HAS-PUNCT + ].

; these three not intended used
; const-ltow-rule &
correlative-coord-word := reg-mod-lex-item & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD correl-coord & [ MOD <[LOCAL.COORD-RELEASED #1]>],
    SYNSEM.LOCAL.COORD-RELEASED #1 ].

correl-pos-coord-word := correlative-coord-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD <[LOCAL.COORD-POL +]>]].
correl-neg-coord-word := correlative-coord-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD <[LOCAL.COORD-POL -]>]].

correlative-connect-word := reg-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD correl-coord & [ MOD <[LOCAL.COORD-RELEASED #1]>],
    SYNSEM.LOCAL.COORD-RELEASED #1 ].

correl-pos-connect-word := correlative-coord-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD <[LOCAL.COORD-POL +]>],
	    SYNSEM.LOCAL.IS-PUNCT -].
correl-neg-connect-word := correlative-coord-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD <[LOCAL.COORD-POL -]>],
	    SYNSEM.LOCAL.IS-PUNCT -].

; for 'slik som', 'likedan som', which can be folowed by absolutely anything. By underspecifyng head and head of COMPS, one can hope that any wellformed configuration will offer
equalizer-word := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD #3],
                                       XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-P,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1 & [LOCAL.CONT.HOOK.INDEX #4,
					LOCAL.HAS-PUNCT - ],
    SYNSEM.LOCAL [ CONT.HOOK.XARG #2 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #2,
					  ARG2 #4],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd,
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!> ].



;;;;;;; PREPOSITIONS

dir-lex-item := word-or-lexrule &
  [ SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH bool ].

; SYNSEM.NON-LOCAL.SLASH <!!> in order to forestall crazy filler-construal
prep-word := word & 1arg-1comps &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD #3 & prep-ultra ],
                                       XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
;    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,
    SYNSEM.LOCAL [ CONT.HOOK.XARG #2 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #2 ],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

prep-n-word := prep-word &
  [ SYNSEM [LOCAL.CAT [ VAL.COMPS 1-list & [FIRST.LOCAL.CAT.HEAD poss-subj-head,
                                            FIRST.LOCAL.CONT.HOOK.INDEX #1,
                                            FIRST.LOCAL.DERIVED-HEAD bool],
                        QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1]] ].

; const-ltow-rule &
prep-s-word := word & 1arg-1comps & 
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD #3 & adjct-comp ],
                                       XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1 & [LOCAL.CAT.HEAD verb-all & [MOD <>],
					LOCAL.CAT.VAL [SUBJ olist,
						       COMPS <>,
						       ICOMPS <>,
						       SPR <>,
						       SPEC <>],
					LOCAL.CONT.HOOK.INDEX.SF prop],
    SYNSEM.LOCAL [ CONT.HOOK.XARG #2 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #2 ],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

; for the moment leaving open whether '-reg' or 'dir-'
;prep-s-word := prep-word &
;  [ SYNSEM [LOCAL [CAT [ VAL.COMPS <[LOCAL.CAT.HEAD verb-all & [MOD <>]]> ]] ]].

; ARG2 should be a handle, not ref-ind, but error-messages come out indicating that clashes with constraints of arg2-comps-synsem, which however seems not to conflict. But somewhere the ARG2 is constrained to be 'individual' - not clear where. TODO.
;prep-s-word := prep-word &
;  [ SYNSEM [LOCAL [CAT [ VAL.COMPS <[LOCAL.CAT.HEAD verb-all & [MOD <>],
;				     LOCAL.CONT.HOOK.LTOP #1]>,
;			 QVAL.DOBJECT.LOCAL.CONT.HOOK.LTOP #1 ]],
;	    LKEYS.KEYREL.ARG2 #1 ]].


prep-rais-word := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY predsort,
				       MOD <>], ;rais
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.HEAD glob-comp & [TRANSPAR bool], ;; glob rather than infin, in order to cover det later til at det sn√∏r; same reason, TRANSPAR bool rather than +
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CONT.HOOK.XARG #1,
				   LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl ]>,   
    SYNSEM.LOCAL.CAT.VAL.COMPS < #4 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #4,   
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #3],
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!  !>].

;KEYS.KEY index-sit1  
                              
prep-rais-vp-mod-word := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
;				  KEYS.KEY rais,
                                  MOD < [LOCAL.CAT.HEAD verb-all,
                                         LOCAL.CONT.HOOK.INDEX #2,
                                         LOCAL.CONT.HOOK.XARG #1] >],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                                   LOCAL.CONT.HOOK.LTOP #4,
                                   LOCAL.CONT.HOOK.XARG #1 ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE non-loc-non-temp,
   SYNSEM.LKEYS.KEYREL #5,
   SYNSEM.LOCAL.CONT.RELS <! #5 & arg12-relation & [ARG1 #2,
                                                    ARG2 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

;head-prep-indirwhquestclause-comp-phrase is still used , but using 'prep-word-clause' as head items (and head-actv-verb-icomp-fineponWH-phrase as next-up syntactic rule)
#|
prep-indirwhquest-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                       KEYS.KEY indirqu ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-or-comp,
                                  LOCAL.CAT.HEAD.DECL -,
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,   
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT indirquest-prep,
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].
|#

; to get      jeg snakker om hvorvidt du kommer
;            *jeg stoler p√• hvorvidt du kommer
; we need two types of these, or three, according to whether
; they allow a question to follow. And intrans-obl-verbs must
; be subclassified accordingly 
; right now, only a hack, letting "p√•_clause" select declarative clause,
; reflecting the behavior for "stole p√•"

;;; DPF 020411


prep-clause-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY clse,  ; LH28092018 from ultra
                                        SELECTED +],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 & [LOCAL.CAT [ HEAD verb-or-comp & [CONDITIONAL -],
						   VAL.SUBJ list ], ;antilist
				       LOCAL.CONT.HOOK.LTOP #2 & semarg,
				       LOCAL.CONT.HOOK.INDEX.E.TENSE tense] >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,   
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].


#|
prep-clause-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY clse,
                                        SELECTED +],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-or-comp,
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE tense] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,   
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].
|#



prep-bareclause-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY clse ], ; LH28092018 from ultra
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all,
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,   
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].

; til, med, som; ... til √•
; LOCAL.CAT.HEAD glob-comp -> fin-comp. Too much doubling with prep-rais-word
prep-expl-dep-word := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.HEAD fin-comp,
                                   LOCAL.CONT.HOOK.LTOP #3 ]>,   
;   SYNSEM.LOCAL.CONT.HOOK.XARG expl-ind,
   SYNSEM.LOCAL.CONT.HOOK.XARG ref-ind,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

; som  KEY som-rais
prep-s-expl-dep-word := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ #subj & list,    
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CONT.HOOK.LTOP #3,
				   LOCAL.CONT.HOOK.INDEX.SF prop,
				   LOCAL.CAT.VAL.SUBJ #subj,   
				   LOCAL.CAT.VAL.SPR #spr,   
				   LOCAL.CAT.VAL.ICOMPS #icmp]>,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,   
   SYNSEM.LOCAL.CAT.VAL.SPR #spr,   
   SYNSEM.LOCAL.CAT.VAL.ICOMPS #icmp,   
   SYNSEM.LOCAL.CONT.HOOK.XARG ref-ind,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.RELS <! [PRED "_som_eq_rel"] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !>].



prep-s-word-reg := reg-mod-lex-item & prep-s-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LOCAL.CAT.HEAD.DEGREE positive,
    SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY der-n√•r,
    SYNSEM.LOCAL.CAT.HEAD.SELECTED - ].

prep-s-word-modadvreg := xarg-mod-lex-item-2 & prep-s-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD adv-reg]> ,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit2,
    SYNSEM.LOCAL.CAT.HEAD.SELECTED - ].



prep-s-word-vmod-reg-time := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]> ].

prep-s-word-nmod-reg-time := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun,
                                LOCAL.CONT.HOOK.INDEX.SORT time-item]> ].

;LH trying, to get the expn like other subords in v-trExpnSu-expnCOND 
;prep-s-word-reg-plce := subord-comp &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place ].
;previously, and again - unclear what the above did
prep-s-word-reg-plce := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place ].

prep-s-word-reg-cond := prep-s-word-reg &
  [ SYNSEM.LOCAL.CAT.HEAD.CONDITIONAL +,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.WH-EXTRACTION-APPLIED -]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-condition ].

prep-s-word-reg-irreal := prep-s-word-reg &
  [ SYNSEM.LOCAL.CAT.HEAD.CONDITIONAL -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-irrealis ].


;;; a modadv-batch:
; 'overalt hvor'
#|
; misunderstood MOD specification
prep-s-word-vmod-modadvreg-time := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]> ].

prep-s-word-nmod-modadvreg-time := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun,
                                LOCAL.CONT.HOOK.INDEX.SORT time-item]> ].
|#
; 'overalt hvor' - can be paired by 'alltid n√•r'
prep-s-word-modadvreg-plce := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place ].

;prep-s-word-modadvreg-cond := prep-s-word-modadvreg &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-condition ].

;;;;;;;;;;


prep-vp-word-reg-time := reg-mod-lex-item & prep-vp-word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time ].

prep-nom-vp-word := word & 1arg-1comps &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD prep,
                                            HEAD.MOD < [LOCAL.CONT.HOOK.INDEX #1,
                                                        LOCAL.CAT.HEAD nominal] >,
                                            VAL.COMPS <[LOCAL.CAT.HEAD verb,
                                                        LOCAL.CONT.HOOK.XARG #1]>]],
                                LKEYS.KEYREL arg12-relation]].

prep-nom-vp-word-reg-refind := reg-mod-lex-item & prep-nom-vp-word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT semsort ].


; for the moment leaving open whether '-reg' or 'dir-'
prep-vp-word := prep-word &
  [ SYNSEM [LOCAL [CAT [HEAD prep,
                        HEAD.MOD < [LOCAL.CONT.HOOK.XARG #1,
                                    LOCAL.CAT.HEAD verb] >,
                        VAL.COMPS <[LOCAL.CAT.HEAD verb,
                                    LOCAL.CONT.HOOK.XARG #1]>]]]].

; using
; COMPS 1-list & [FIRST.LOCAL.CAT.HEAD cl-adjct inst of
; COMPS 1-list & [FIRST.LOCAL.CAT.HEAD prep-or-adv   -
; covers the same...
prep-p-adv-word := prep-word &
  [ SYNSEM [LOCAL.CAT [ VAL.COMPS 1-list & [FIRST.LOCAL.CAT.HEAD cl-adjct,
                                            FIRST.LOCAL.CONT.HOOK.INDEX #1,
                                            FIRST.LOCAL.DERIVED-HEAD -],
                        QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1]] ].

dir-prep-p-adv-word := prep-p-adv-word & dir-mod-lex-item.

prep-p-adv-word-reg := prep-p-adv-word & reg-mod-lex-item &
 [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod,
				 LOCAL.CAT.HEAD comm-noun & [KEYS.KEY absnoun]] >,
     SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE non-loc-non-temp ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod ].

prep-p-adv-vmod-word-reg := prep-p-adv-word & reg-mod-lex-item &
 [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod,
				 LOCAL.CAT.HEAD verb-all] >,
     SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE non-loc-non-temp ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod ].

; removed ',
; removed prep DECL+
;    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thin;  g]]>' - clashing with preps taking temporal objects and other special sorts
; prep taking clauses and inf have to find another category - prep-clause-word
prep-word-reg := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod & [ROLE non-loc-non-temp]] >, ;LOCAL.CAT.HEAD comm-noun & [KEYS.KEY absnoun], - too eagerly setting them apart from relational prep - after all, they also modify VPs
    SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, 
    SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
				  N-to-N-RELATIONAL-P -,
				  KEYS.KEY index-sit1],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE non-loc-non-temp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD nominal-or-connect-n]>, 
;    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] >,; they also combine like in 'her og i b√•ten' where 'og i b√•ten' adjoins to 'her', and has the same features as 'i b√•ten', thus conflict with this MOD specification.
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1]]>].

prep-word-wh-clause := reg-mod-lex-item & prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
				   KEYS.KEY index-sit1],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE non-loc-non-temp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD verb-or-comp,
                                 LOCAL.CONT.HOOK.INDEX.SF ques,
                                 LOCAL.CONT.HOOK.INDEX.E.TENSE finite]>,
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1]]>].

prep-word-loc := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod & [ROLE spatial]] >,
    SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #mod, 
    SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
				   KEYS.KEY index-sit1],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE xdim-to-xdim-spatial ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD np-head]>,
;    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] >,; they also combine like in 'her og i b√•ten' where 'og i b√•ten' adjoins to 'her', and has the same features as 'i b√•ten', thus conflict with this MOD specification
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1]]>].

prep-word-temp := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod  & [ROLE temporal]] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -,
					TEL-FIXING -,
					KEYS.KEY index-sit1],
;    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE xdim-to-xdim-temporal ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD np-head]>,
;    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] >,; they also combine like in 'her og i b√•ten' where 'og i b√•ten' adjoins to 'her', and has the same features as 'i b√•ten', thus conflict with this MOD specification
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1]]>].



; like above
prep-modadvreg-word := xarg-mod-lex-item-2 & prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
				  KEYS.KEY index-sit2 ],
    SYNSEM.LKEYS.KEYREL prep-mod-relation,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD np-head]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep-or-adv & [SELECTED -,
								KEYS.KEY index-sit1],
				  LOCAL.DERIVED-HEAD -] > ].

#|
prep-word-agent := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD  [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb & [ VOICE passive ],
				  LOCAL.CONT.HOOK.VARG #1 ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head,
				 LOCAL.CONT.HOOK.INDEX #1]> ].
|#

prep-word-agent := lbl-ltop-lex-item-2rel & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE non-loc-non-temp,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb & [ VOICE passive ],
				  LOCAL.CONT.HOOK.VARG #3,
				  LOCAL.CONT.HOOK.INDEX #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head,
				 LOCAL.CONT.HOOK.INDEX #4,
				 LOCAL.CARD-TO-BARE-N -,
				 LOCAL.SPEC-TO-BARE-N -]>,
    SYNSEM.LOCAL.CONT.RELS <! [], [ PRED "_identical-to_rel",
				    ARG1 #3,
				    ARG2 #4 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1 ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1].

;when combining with verb or adj, the combination is via a comp-rule, hemce no MOD list selecting these, still to avoid being used in N-modification
; undergoes unary rule first
; selected Ps that are not in detach-poss and not in "om at..."-constr
prep-word-sel := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>, ; if v-or-adj were a type, then that
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                        KEYS.KEY fct-spec,
                                        MOD list],
    SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX ref-ind & #1 & [SORT referential-thing],
                                  LOCAL.CAT.HEAD np-head] >,
    SYNSEM.LOCAL.DERIVED-HEAD -,
     SYNSEM.LOCAL.MODIFICATION-PERFORMED - ]. ; BLOCKING such a PP from being non-head in subj-gap-filler

;when combining with noun, the combination is via mod-rule
prep-word-n-sel := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                        KEYS.KEY fct-spec,
                                        MOD <[LOCAL.CAT.HEAD comm-noun]>],
    SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX ref-ind & #1 & [SORT referential-thing],
                                  LOCAL.CAT.HEAD np-head] >,
    SYNSEM.LOCAL.DERIVED-HEAD -,
     SYNSEM.LOCAL.MODIFICATION-PERFORMED - ]. ; BLOCKING such a PP from being non-head in subj-gap-filler

; for detached-poss
prep-detachposs-word := lbl-ltop-lex-item & prep-n-word & const-ltow-rule &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD prep-ultra & [KEYS.KEY detch,
                                                               SELECTED +,
							       MOD <>] ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2 & [SORT referential-thing]]>,
    SYNSEM.LOCAL.CONT.HOOK [VARG #2,
                            XARG #1 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #1 & event-verb,
                                          ARG2 #2 ],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

; for "spise av/p√• br√∏det"
;prep-atelic-word := word & lbl-ltop-lex-item &
prep-atelic-word := reg-mod-lex-item & prep-n-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod,
				  LOCAL.CAT.HEAD verb ] >,
      SYNSEM.LOCAL.CAT.HEAD prep,
    SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD prep-ultra & [KEYS.KEY atelic-operation,
                                                               SELECTED +] ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2 & [SORT referential-thing]]>,
    SYNSEM.LKEYS.KEYREL arg12-relation & [PRED "_affect_rel",
                                          ARG1 #xarg,
                                          ARG2 #2 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

time-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod & [ ROLE timespan] ]>,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM arg2-comps-synsem & [LKEYS.KEYREL line-to-xdim-temporal-rel],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun & [KEYS.KEY predsort ],
                                   LOCAL.CONT.HOOK.INDEX [SORT time-item]]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ]> ].

; leaves the 'LEG' aspect out, since it uses 'prep-mod-relation'
;dir-prep-word := dir-mod-lex-item & prep-n-word.

#|
; march22-06: comm-out, along with using prep-line-rel
; assumed in 'Without-Predsort' march08.05lh - till ;;;
dir-prep-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-path-rel & [ LEG #1 ]],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing]]>,
    SYNSEM.LOCAL.CONT.HOOK.XLEG #1,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ]> ].
|#

; SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD head ]> to allow PP modifying derived adjective, as in "spredd over plassen"
dir-prep-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-line-rel],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE spatial,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir,
			   SELECTED -],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
                                   LOCAL.CAT.HEAD  nominal-or-connect-n ]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK dir-hook ]> ].

dir-fixpoint-prep-word := dir-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE line-to-xdim,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY pathconsumpt-dir ] ].

dir-nonfixpoint-prep-word := dir-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE line-to-xdim ].
    
; for PPs modifying adv

; this type also represents PP adjoining to PP. In this case, the
; specification 'MOD<[LKEYS.KEYREL orient-adv-rel]>' plays no role, since
; LKEYS specification does not reach phrasal level. (Otherwise it
; would have blocked operation, so a good thing...)
; SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep-or-adv & [SELECTED bool] - bool here to allow "han vil inn i huset", where "vil" combines by head-verb-adverb-comp-rule, which otherwise requires selected+.
dir-prep-2-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-line-rel],
    SYNSEM.LOCAL.CAT.HEAD prep & [KEYS.KEY dir2,
				  SELECTED -],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep-or-adv,
                                  LOCAL.DERIVED-HEAD -,
				  LKEYS.KEYREL orient-adv-rel ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
                                   LOCAL.CAT.HEAD  np-head ]>].

dir-fixpoint-prep-2-word := dir-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixptconsumpt-dir2 ] ].

dir-nonfixpoint-prep-2-word := dir-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY nonfixpt-dir2 ] ].    
;;;

; assumed in Predsort march08.05lh - till ;;;
dirarg-prep-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-mod-relation],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir,
			   SELECTED - ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-or-noun ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
                                   LOCAL.CAT.HEAD  np-head ]> ].

dirarg-telic-prep-word := dirarg-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ].

dirarg-atelic-prep-word := dirarg-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

dirarg-prep-2-word := dir-mod-lex-item & prep-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-mod-relation],
    SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING -,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adv & [SELECTED -],
                                  LKEYS.KEYREL orient-adv-rel ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.DERIVED-HEAD -,
                                   LOCAL.CONT.HOOK.INDEX [SORT referential-thing]]> ].

dirarg-telic-prep-2-word := dirarg-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ].

dirarg-atelic-prep-2-word := dirarg-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].   
;;;

; det er under tvil at han kommer
prep-arg1prop-epon-lxm := lbl-ltop-lex-item & 2arg & const-ltow-rule &
  [ SYNSEM.LKEYS.KEYREL arg12-relation, ;; MHS 090813 Added ancestor 2arg as well as additional constraint "SYNSEM.LOCAL.ARG-S < #comps1, #comps2 >," to fix the grammar's SLASH shenanigans in cases such as 'det er for andre gang at han taper. The existing constraint of "SYNSEM.NON-LOCAL.SLASH 0-dlist" does not detect when there is a gap in one of the complements.
     SYNSEM.LOCAL.CAT.HEAD prep &[SELECTED -],
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & handle,
    SYNSEM.LKEYS.KEYREL.ARG2 #3,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comm-noun,
				   LOCAL.CONT.HOOK.INDEX #3] & #comps1,
				 [ LOCAL.CAT.HEAD fin-comp,
				   LOCAL.CONT.HOOK.LTOP #1,
				   LOCAL.CAT.HEAD.DECL bool] & #comps2 >,
    SYNSEM.LOCAL.ARG-S < #comps1, #comps2 >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY -,
    SYNSEM.NON-LOCAL.SLASH 0-dlist  ].   







nom-dir-prep-word := reg-mod-lex-item & prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LKEYS.KEYREL prep-line-rel,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir,
                           SELECTED -],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD np-head,
                                  LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing]]>].

nom-dir-fixpt-prep-word := nom-dir-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixpt-dir ]].
nom-dir-nonfixpt-prep-word := nom-dir-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY nonfixpt-dir ]].

tel-fix-word := word & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING +,
                           SELECTED -],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX.SORT time-item,
                                 LOCAL.CAT.HEAD.KEYS.KEY meastimenoun]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT telmarking,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all  ]>].

tel-fix-pathtelic-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK dir-hook,
				LOCAL.CONT.HOOK.INDEX.PATH-TELIC +,
                                LOCAL.PATHTELFIXED -,
                                LOCAL.PATHTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY telfix ].

tel-fix-path-atelic-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK dir-hook,
				LOCAL.CONT.HOOK.INDEX.PATH-TELIC -,
                                LOCAL.PATHTELFIXED -,
                                LOCAL.PATHTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY telfix ].

tel-fix-delim-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.E.DELIMITED +,
                                LOCAL.DELIMTELFIXED -,
                                LOCAL.DELIMTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY delimfix ].

tel-fix-nondelim-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.E.DELIMITED -,
                                LOCAL.DELIMTELFIXED -,
                                LOCAL.DELIMTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY delimfix ].

; also tel-fix-incremtelic, same ways...

tel-fix-prep-word := prep-n-word & tel-fix-word & reg-mod-lex-item &
 [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod ]. ; compensating for change to reg-mod-lex-item - see type 

tel-fix-pathtelic-prep-word := tel-fix-prep-word & tel-fix-pathtelic-word.
  
tel-fix-path-atelic-prep-word := tel-fix-prep-word & tel-fix-path-atelic-word.

tel-fix-delim-prep-word := tel-fix-prep-word & tel-fix-delim-word.

tel-fix-nondelim-prep-word := tel-fix-prep-word & tel-fix-nondelim-word&
 [ SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD.DEF -,
				LOCAL.CAT.HEAD.DEFINITE -]>].

; the specification ...LOCAL.CAT.HEAD.KEYS.KEY regnoun] excludes poss-prep from cooccurring with relational nouns, which is of course wrong, but since they always will have a relational prep allowed, we reduce parse proliferation
prep-word-poss := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LKEYS.KEYREL possessed-by-rel,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.DEFINITE +,
                                  LOCAL.CAT.HEAD.KEYS.KEY regnoun] >,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY possprep ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT animfull-thing],
                                   LOCAL.CAT.HEAD np-head & [KEYS.KEY animnoun] ,
                                   LOCAL.SPEC-TO-BARE-N -,
                                   LOCAL.CARD-TO-BARE-N - ] > ].

;,
;    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.TRANSPAR - ]>
rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT relatum,
                                  LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun]] >, ;relnoun
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD bool, ; '-' rules out "rett til fri"
                                 LOCAL.CAT.HEAD np-head,
				 LOCAL.CAT.POSTHEAD -]>,
    SYNSEM.LOCAL.CAT.HEAD prep & [TEL-FIXING -,
				  SELECTED -, ;from +, LH051021
				  N-to-N-RELATIONAL-P +,
				  KEYS.KEY predsort], ;preprel
    SYNSEM.LOCAL.CAN-CMB-V -,
     SYNSEM.LOCAL.MODIFICATION-PERFORMED - ].

rel-prep-wh-clause-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT relatum,
                                  LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun]] >, ;relnoun
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD verb-or-comp,
                                 LOCAL.CONT.HOOK.INDEX.SF ques,
                                 LOCAL.CONT.HOOK.INDEX.E.TENSE finite]>,
    SYNSEM.LOCAL.CAT.HEAD prep & [TEL-FIXING -,
				  SELECTED +,
				  N-to-N-RELATIONAL-P +,
				  KEYS.KEY predsort], ;preprel
    SYNSEM.LOCAL.CAN-CMB-V -,
     SYNSEM.LOCAL.MODIFICATION-PERFORMED - ].

und-rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LKEYS.KEYREL.PRED "takes_as_undergoer_rel",
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT init-und,
                                  UNDERGOER-OPEN - ] >,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED - ] ].

init-rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LKEYS.KEYREL.PRED "_takes_as_initiator_rel",
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT init-or-actor,
                                  UNDERGOER-OPEN - ] >,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED - ] ].

perform-rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LKEYS.KEYREL.PRED "_takes_as_performer_rel",
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT init-or-actor ] >,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED - ] ].




;;;; ADVERBS
; ,
;            LKEYS.KEYREL arg1-relation - applies not to locative/directional adverbs
adv-word :=  word &
  [ SYNSEM [LOCAL [CAT [HEAD #3 & adv,
                        VAL.COMPS <>,
                        VAL.ICOMPS <>,
;                        VAL.SPR <>,
                        VAL.SPEC <>],
                   XCAT [HEAD #3 ],
                   CONT.HOOK.INDEX ad-event,
		   DERIVED-HEAD bool] ],
    EXTRACTED-FROM -].

; the intuition is that these 'particles' are always selected
; removed ,
;                                              KEYS.KEY adv-selct
adv-particle-word :=   reg-mod-lex-item & word & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod,
				  LOCAL.CAT.HEAD verb-all] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM [LOCAL [CAT [HEAD #3 & adv & [ MOD <[LOCAL.CONT.HOOK hook] >, 
					   SELECTED +,
					   KEYS.KEY pcl ]],
                   XCAT.HEAD #3,
                   CONT.HOOK.INDEX ad-event ]]].

; to make compatible with rule for fronted adverbs
; ,
;                                   KEYS.KEY adv-s
;LOCAL.CONT.RELS <!  ad-rel &
;s-adv-word := word &  lbl-ltop-lex-item &
;  [ SYNSEM.LOCAL.CAT.HEAD s-adv & [MOD < [ LOCAL.CONT.HOOK.LTOP #4 & handle,
;                                           LOCAL.ADJ-SITE-OPEN + ]>],  
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
;    SYNSEM.LKEYS.KEYREL [ARG0 ad-event,
;                         ARG1 #4,
;                         LBL #1 ],
;    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; need LOCAL.CAT.HEAD verb-all, -> head
; for fragments - with relaxation also in the syntax rule   TODO                                  
;VAL.SPEC < [ LOCAL.CAT.HEAD verb-all,
; const-ltow-rule &
;
s-operadv-word := word &  lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT [HEAD s-adv & [KEYS.KEY adv-s],
                      VAL.SPEC < [ LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CONT.HOOK.LTOP #4 & handle,
                                   LOCAL.ADJ-SITE-OPEN + ] >],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-ADVs,  
    SYNSEM.LKEYS.KEYREL [ARG0 ad-event,
                         ARG1 #4 ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    CAN-OCCUR-INITIAL bool,    ; these features are introduced here
    CAN-OCCUR-FINAL bool ].

s-operadv-init-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL +,
    CAN-OCCUR-FINAL -].
s-operadv-final-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL -,
    CAN-OCCUR-FINAL +].
s-operadv-init-final-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL +,
    CAN-OCCUR-FINAL +].
s-operadv-stnd-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL -,
    CAN-OCCUR-FINAL -].


;;const-ltow-rule &
qualadv-word := word &  lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT [HEAD adv, ; adv-reg,      ;s-adv & [KEYS.KEY adv-s],
                      VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #4 & handle,
                                   LOCAL.ADJ-SITE-OPEN + ] >],  
    SYNSEM.LKEYS.KEYREL [ARG0 ad-event,
                         ARG1 #4 ],
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

qualifadv-word := qualadv-word.
qualifadv-quant-word := qualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD quantor]> ].
qualifadv-allquant-word := qualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD allquant]> ].

focqualifadv-word := qualadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD head]> ]. ;prep-or-adv


; not used in lex
;qualifadv-card-word := qualifadv-word &
;  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD card]> ].


;focqualifadv-n-word := focqualifadv-word &
;  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD np-head]> ]. ; nominal-or-connect-n
;focqualifadv-padv-word := focqualifadv-word &
;  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD prep-or-adv]> ].

;focqualifadv-perspron-word := focqualifadv-word &
;  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD pers-pron]> ].



m-adv-word := adv-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY adv-m],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-ADV,
    SYNSEM.LKEYS.KEYREL adj_rel & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; should somehow be distinguished from place-adverbs  TODO
time-adv-word := reg-mod-lex-item & adv-word  &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
    SYNSEM.LOCAL.CAT.HEAD.POS tag-ADV,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY index-sit1],
;				 MOD <[LOCAL.CAT.HEAD verb-all]>],; tempting, but loses 'kampen imorgen' etc
;    SYNSEM.LKEYS.KEYREL adj_rel & [ARG1 #1],
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim-temporal,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; not adv-reg
adv-word-reg-sup := reg-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-ADV,
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD adv,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point] ].

adv-word-reg := adv-word-reg-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH bool,
    SYNSEM.LOCAL.CONT.HOOK [INDEX.ROLE non-loc-non-temp ],
   SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ] ].
; "hvor lenge varer det?" - 'hvor' must be able to combine with a normal adverb.
;adv-word-reg := adv-word-reg-sup &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

adv-word-loc := adv-word-reg-sup &
  [SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim-spatial,
   SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ] ].

adv-word-reg-at-locus := adv-word-loc.
adv-word-at-in-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-in].
adv-word-at-out-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-out].
adv-word-at-up-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-up].
adv-word-at-down-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-down].
adv-word-at-far-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-far].
adv-word-at-home-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-home].
adv-word-at-ahead-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-ahead].
adv-word-at-back-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-back].
adv-word-at-salientpoint-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-salientpoint].
adv-word-at-awayfrom-salientpoint-reg := adv-word-reg-at-locus &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-awayfrom-salientpoint].

adv-word-temp := adv-word-reg-sup &
  [SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim-temporal,
   SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ] ].


adv-word-vp-mod := adv-word-reg-sup &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD non-copula ] >],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-ADV,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adv-nonselct ].
   


;dirarg-adv-word := dir-mod-lex-item & adv-word &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-or-noun ]> ].

dirarg-adv-word := dir-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD adv-reg & [MOD < [ LOCAL.CAT.HEAD head ]>], ;verb-or-noun  in coordination 'hit og dit the st' the second ('dit') modifies the first ('hit')
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ] ].

dirarg-telic-adv-word-sup := dirarg-adv-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixpt-dir ]  ].

dirarg-telic-adv-word := dirarg-telic-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

wh-dirarg-telic-adv-word := dirarg-telic-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

; a possible type (for "inn", f.ex.), but spurious, since in an
; adv-adv-modification, the ORIENT values would clash. We thereby
; miss a same-leg reading otherwise desirable. (Phrasal rule
; available: adv-mod-adv2-rule) If we want to get at the latter, 
; all words of this type would have to have 'ORIENT orient', and
; thus no represented semantics in the feature specification.
; This is exactly the course taken with regard to adv-word-2-reg
; (then concerning 'SORT place-param').
; (See also discussion for orient-adv-2-word.)

dirarg-telic-adv-2-word := dir-mod-lex-item & adv-word &
  [  SYNSEM.LOCAL.CAT.HEAD adv-reg & [MOD < [ LOCAL.CAT.HEAD adv ]>],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
     SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixpt-dir2,
                            SELECTED - ]  ].

; this is the same as orient-adv-word - could be used instead
;dirarg-atelic-adv-word := dirarg-adv-word &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

dirarg-telic-to-in-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-in ].
dirarg-telic-to-out-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-out ].
dirarg-telic-to-up-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-up ].
dirarg-telic-to-down-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-down ].
dirarg-telic-to-far-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-far ].
dirarg-telic-to-along-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-along ].
dirarg-telic-to-home-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-home ].
dirarg-telic-to-ahead-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-ahead ].
dirarg-telic-to-back-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-back ].
dirarg-telic-to-at-salientpoint-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-at-salientpoint ].
dirarg-telic-to-awayfrom-salientpoint-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-awayfrom-salientpoint ].
dirarg-telic-to-right-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-right ].
dirarg-telic-to-left-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-left ].


orient-adv-word-sup := dir-mod-lex-item-2 & adv-word &
  [ SYNSEM.LKEYS.KEYREL orient-adv-rel,
    SYNSEM.LOCAL.CAT.HEAD adv-reg & [MOD <[LOCAL.CAT.HEAD verb-or-noun ]>],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY orient-dir ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

orient-adv-word := orient-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

wh-orient-adv-word := orient-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

; a possible type, but spurious: if we want adv-adv-modif, the
; ORIENT values will clash. Hence ARG0s are distinct, and then
; we may as well use iterative V-adjunction. Hence no lex-items
; with this type
orient-adv-2-word := dir-mod-lex-item-2 & adv-word &
  [ SYNSEM.LKEYS.KEYREL orient-adv-rel,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD adv & [SELECTED -]  ]>,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY orient-dir ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

orient-to-north-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-north ].
orient-to-south-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-south ].
orient-to-east-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-east ].
orient-to-west-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-west ].
orient-to-in-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-in].
orient-to-out-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-out].
orient-to-up-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-up].
orient-to-down-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-down].
orient-to-far-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-far].
orient-to-forth-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-forth].
orient-to-home-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-home].
orient-to-ahead-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-ahead].
orient-to-at-salientpoint-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-at-salientpoint].
orient-to-awayfrom-salientpoint-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-awayfrom-salientpoint].

wh-adv-word-reg := adv-word-reg-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

adv-word-2-reg := xarg-mod-lex-item-2 & adv-word &
 [ SYNSEM.LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY index-sit2 ],
   SYNSEM [LKEYS.KEYREL arg1-relation,
           LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adv-reg & [SELECTED -] ] >]].

adv-word-2placepar-reg := adv-word-2-reg &
 [ SYNSEM.LKEYS.KEYREL.ARG0.SORT place-param ].






#|
nom-orient-adv-word := reg-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LKEYS.KEYREL orient-adv-rel,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY orient-dir ],
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun  ]> ].

nom-orient-to-south-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-south].
nom-orient-to-north-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-north].
nom-orient-to-east-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-east].
nom-orient-to-west-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-west].
nom-orient-to-down-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-down].
nom-orient-to-in-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-in].
nom-orient-to-out-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-out].
nom-orient-to-up-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-up].
nom-orient-to-far-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-far].
nom-orient-to-home-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-home].
nom-orient-to-ahead-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-ahead].
nom-orient-to-at-salientpoint-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-at-salientpoint].
nom-orient-to-awayfrom-salientpoint-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-awayfrom-salientpoint].
|#



refl-adv-word := reg-mod-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD refl-adv,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LKEYS.KEYREL asserted-id-rel,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD pers-pron ]> ].


;;;;;;;; NP-internal items

adjectival-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD #3 & adjectival,
    SYNSEM.LOCAL.XCAT [HEAD #3 ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.CAT.VAL.SPEC list].

adjective-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [WEAK #bool,
                                 DEGREE #degree],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.AGR.PNG.NG [NUM #num,
                             GEN #gen],
    INFL-MORPH [WEAKFORM #bool,
                DEG #degree,
                GEND #gen,
                NUMB #num] ].

adjective-word-2 := adjectival-word & lbl-ltop-lex-item-3rel &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [WEAK #bool,
                                 DEGREE #degree],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.AGR.PNG.NG [NUM #num,
                             GEN #gen],
    INFL-MORPH [WEAKFORM #bool,
                DEG #degree,
                GEND #gen,
                NUMB #num] ].


#|
adjective-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [WEAK #bool,
                                 DEGREE #degree],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG [NUM #num,
                                        GEN #gen],
    INFL-MORPH [WEAKFORM #bool,
                DEG #degree,
                GEND #gen,
                NUMB #num] ].
|#

; changing from a-mod-phrase to head-spec-phrase, and thus MOD to SPEC
; see card-mod-phrase-sup

;SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [SORT card-unit]

cardinal-word := word & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #5, 
    SYNSEM.LOCAL.CAT.HEAD #3 & cardnum & [KEYS.KEY crdnum,
                                          DEGREE positive,
					  DEFINITE -],
    SYNSEM.LOCAL.XCAT [HEAD #3 ],
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD np-head,
				  LOCAL.CONT.HOOK.INDEX #1]>,     
;    SYNSEM.LKEYS.KEYREL card-relation,
    SYNSEM.LKEYS.KEYREL card-arg1-relation,
;    SYNSEM.LKEYS.KEYREL card-arg1-relation & [ARG1 #1], ; LH200813: outcomment gets rid of ARG1, and dependencies is then ok, but 'keys' become similar for card and N, and treebanking for the demos gets messed up. Thus try again
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & [ PNG #5 ], ; LH200813 but this reentrancy gives cyclic mrs
    EXTRACTED-FROM -,
    SYNSEM.LOCAL.AGR.PNG #5,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL.SLASH 0-dlist & [ LIST < > ] ].

#| 
; see plur-cardinal-word
cardinal-word := cardinal-word-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]. 

cardinal-sg-word := cardinal-word-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]. 
|#



ordinal-lxm := adj-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ KEYS.KEY propt,
				  ORDINAL +,
;				  WEAK +,
				  DEGREE degree,
				  MOD < [LOCAL.CAT.HEAD np-head,
					 LOCAL.CAT.VAL.SUBJ <>,
					 LOCAL.CAT.VAL.COMPS <>,
					 LOCAL.CAT.VAL.ICOMPS <>]> ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LKEYS.KEYREL.ARG1 #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

#|
ordinal-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD ord & [ KEYS.KEY propt,
				      WEAK +,
				      DEGREE degree,
				      MOD < [LOCAL.CAT.HEAD np-head,
					     LOCAL.CAT.VAL.SUBJ <>,
					     LOCAL.CAT.VAL.COMPS <>,
					     LOCAL.CAT.VAL.ICOMPS <>]> ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LKEYS.KEYREL card-arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

freestnding-weak-adj-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CONT.HOOK.INDEX #1,
                                         LOCAL.CAT.HEAD np-head & [DEF + ],
                                         LOCAL.CAT.VAL.SPR < [] > ] >,
                                  WEAK + ],
;                                  DEGREE positive ], 
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LKEYS.KEYREL same-rel,
    SYNSEM.LOCAL.DERIVED-HEAD -,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

#|
; TODO - fails to work in 'mine mange gutter' - doesnt catch index of N
quantity-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1, 
    SYNSEM.LOCAL.CAT.HEAD cardquant & [ MOD < [ LOCAL.CONT.HOOK.INDEX #1 ]>],
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

;INDEX -> XARG LH28022021 why on earth?
plur-cardinal-word := cardinal-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG #num & pl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #num ].

;INDEX -> XARG LH28022021 why on earth?
sg-cardinal-word := cardinal-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG #num & sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #num ].

#|
; 'qualitative' count quantifiers
plur-quantity-word := quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD.DEF +]> ].

; not used so far (jul 05)
sg-quantity-word := quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].
|#

;deleted WH -  in SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH - ],
; in order to allow "hvor mange flere gutter"

cmpar-quantity-word := adjectival-word & lbl-ltop-lex-item-2rel & const-ltow-rule & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre], 
    SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4,
                                  LOCAL.CAT.HEAD.DEFINITE -,
                                  LOCAL.CAT.HEAD.DEF -,
                                  LOCAL.CAT.HEAD.COMPAR-DEP enn-cmpar ]>,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #4,
                                            ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

cmpar-count-quantity-word := cmpar-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

cmpar-mass-quantity-word := cmpar-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.DERIVED-HEAD - ] >,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +].


; unclear how to deal with CMPAR-PENDING
#|
superlat-quantity-word := adjectival-word & lbl-ltop-lex-item-4rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant, 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4]>,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #2,
                                            ARG2 #3 ],
                            measure-out-rel & [ ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ ARG1 #3,
                                                ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].
|#

superlat-quantity-word := adjectival-word & lbl-ltop-lex-item-2rel & const-ltow-rule & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant, 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4]>,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #4,
                                            ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

superlat-count-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

superlat-mass-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.DERIVED-HEAD - ] >].

superlat-strong-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.DEFINITE -,
                                  LOCAL.CAT.HEAD.DEF -]>].

superlat-weak-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.DEF +,
                                  LOCAL.CAT.VAL.SPR <[]>]>].

superlat-count-strong-quantity-word := superlat-count-quantity-word & superlat-strong-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].
superlat-count-weak-quantity-word := superlat-count-quantity-word & superlat-weak-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].
superlat-mass-strong-quantity-word := superlat-mass-quantity-word & superlat-strong-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].
superlat-mass-weak-quantity-word := superlat-mass-quantity-word & superlat-weak-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].

superlat-count-post-quantity-word := superlat-strong-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-post]].


; still tidy up semantics here
#|
superlat-cum-part-quantity-word := adjectival-word & lbl-ltop-lex-item-4rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre], 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD part-prep,
                                 LOCAL.CONT.HOOK.XARG #10,
                                 LOCAL.CONT.HOOK.CMPAR-ARG #7,
                                 LOCAL.CAT.VAL.SPR <[], [LOCAL.CAT.HEAD det]>] >,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #10,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #2,
                                            ARG2 #3 ],
                            measure-out-rel & [ ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ ARG1 #3,
                                                ARG2 #10 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].
|#

superlat-cum-part-quantity-word := adjectival-word & lbl-ltop-lex-item-2rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre], 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD part-prep,
                                 LOCAL.CONT.HOOK.XARG #10,
                                 LOCAL.CONT.HOOK.CMPAR-ARG #7,
                                 LOCAL.CAT.VAL.SPR <[], [LOCAL.CAT.HEAD det]>] >,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #10,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #4,
                                            ARG2 #10 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

superlat-cum-part-count-quantity-word := superlat-cum-part-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].
superlat-cum-part-mass-quantity-word := superlat-cum-part-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].





;;;;; Adjective Words

participial-pres-adj-word := adjective-word & const-ltow-rule &
  [ DTR presparticpl-adj-lxm ].

;plur-or-weak-adj := lexeme-to-word-rule.

;; strong:
neutsg-adj-word := adjective-word & lexeme-to-word-rule &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg,
    DTR strong-adj-lxm ].

neutsg-infl-adj-word := neutsg-adj-word & infl-ltow-rule. 

; [bmw]
neutsg-infl-adj-word-const := neutsg-adj-word & const-ltow-rule &
  [ INFLECTION #infl & phon,
    DTR strong-adj-lxm & [ INFLECTION #infl ] ]. 

; masc-or-fem-sg
masc-or-fem-sg-adj-word := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG masc-or-fem-sg,
;    SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG masc-or-fem-sg,
    INFLECTION #infl & phon,
    DTR strong-adj-lxm & [ INFLECTION #infl ] ].

; part of abandoned attempt to deal with "lita"
;fem-sg-adj-word := adjective-word & const-ltow-rule &
;  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG fem-sg,
;    DTR strong-adj-lxm ].

;; EAA. Alt path for mal irules.
orth-alter-masc-or-fem-sg-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG masc-or-fem-sg,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,  ;this would require ref-ind and ad-event to be identical
;    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CONT.HOOK.INDEX #1] >,
    DTR strong-adj-lxm ].

strongpl-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
    DTR strong-adj-lxm  ].

strongpl-adj-word-const := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
    DTR strong-adj-lxm  ].

; [bmw]
;strongpl-adj-word := adjective-word & infl-ltow-rule &
;  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
;    DTR strong-adj-lxm  ].

;; weak:
#|
weaksg-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG sg,
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
                                         LOCAL.CAT.VAL.SPR < [] > ] >],
    DTR weak-adj-lxm  ].

weakpl-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
                                         LOCAL.CAT.VAL.SPR cons ] >],
    DTR weak-adj-lxm  ].
|#

;; LOCAL.CAT.VAL.SPR cons &  <[LOCAL.CAT.HEAD.KEYS.KEY weaklic],...> moved from weak-adj-lxm to weak-adj-word.

weak-adj-word-sup := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD nominal-or-connect-n,
					 LOCAL.CAT.VAL.SPR list] > ], 
    DTR weak-adj-lxm  ].

weak-adj-word := weak-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD np-head & [DEF +],
					 LOCAL.CAT.VAL.SPR cons &  <[LOCAL.CAT.HEAD.KEYS.KEY weaklic],...> ] >]  ].

; After shifting to counting these as indef. adjective-mod-indef-rule covers "rette l√∏sning er √•...", without need for pseudoweak-superlative-adj-word. Same for adjective-mod-superlative-indef-rule. So, the following two rules are now commented out in rules.tdl.
pseudoweak-superlative-adj-word := weak-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD np-head & [DEF -],
					 LOCAL.CAT.VAL.SPR <> ] >,
				  DEGREE superlative ]].

weak-superlative-adj-word := weak-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD np-head & [DEF +],
					 LOCAL.CAT.VAL.SPR <[]> ] >,
				  DEGREE superlative ]].

pseudoweak-designated-adj-word := weak-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD np-head & [DEF -],
					 LOCAL.CAT.VAL.SPR <> ] >,
				  KEYS.KEY designated-pseudoweak ]].

pseudoweak-ordinal-adj-word := weak-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD np-head & [DEF -],
					 LOCAL.CAT.VAL.SPR <> ] >,
				  ORDINAL +,
				  KEYS.KEY propt ]].


#|
mal-weak-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun & [DEFINITE +],
					 LOCAL.CAT.VAL.SPR null ] >],
    GENRE robust,
    DTR weak-adj-lxm  ].
|#

weak-adj-word-const := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD nominal-or-connect-n,
                                         LOCAL.CAT.VAL.SPR cons ] >],
    DTR weak-adj-lxm  ].

; [bmw]
;weak-adj-word := adjective-word & infl-ltow-rule &
;  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
;                                         LOCAL.CAT.VAL.SPR cons ] >],
;    DTR weak-adj-lxm  ].

weaksg-adj-word := weak-adj-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG sg ].
weakpl-adj-word := weak-adj-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl ].


adj-word-abbrev := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY abbr,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ #1,
    DTR.SYNSEM.LOCAL [ DERIVED-BARE-N-FROM-ADJ #1],
    INFLECTION adj_fork ].



;CMPAR-COMMENTOUT

comparative-adj-word := word & lbl-ltop-lex-item-2rel & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj,
    DTR comparative-adj-lxm  ].

sup-adj-word := word & lbl-ltop-lex-item-3rel & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj,
    DTR sup-adj-lxm ].

sup-adj-weak-word := sup-adj-word &
  [ DTR sup-adj-weak-lxm  ]. 

sup-adj-strong-word := sup-adj-word &
  [ DTR sup-adj-strong-lxm  ]. 


adv-from-adj-t-pos-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-pos-lxm,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -].
adv-from-adj-√∏-pos-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].
adv-from-adj-tt-pos-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].
degadv-from-adj_nde-pos-word := lbl-ltop-lex-item & const-ltow-rule &
  [ DTR degadv-from-adj_nde-pos-lxm ].
degadv-from-adj_t-pos-word := lbl-ltop-lex-item & infl-ltow-rule &
  [ DTR degadv-from-adj_t-pos-lxm ].

adv-from-adj-cmpar-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-cmpar-lxm ].
adv-from-adj-superlat-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-superlat-lxm ].

; [bmw]
adv-from-adj-√∏-pos-word-const := adv-word & const-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].

; den ene
sg-weak-cardinal-word := sg-cardinal-word & 
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < [] > ] >,
     SYNSEM.LOCAL.CAT.VAL.SPR <[]> ].

sg-strong-cardinal-word := sg-cardinal-word & 
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < > ] >,
     SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD.DEF -]> ].

; for "den snille gutten" - cf def-q-word, for "den bengalske tiger"
; LH020214: beware: the three instances of this category are p.t. commented out.
det-word := lbl-ltop-lex-item & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [] !>,
                                   LOCAL.CAT.HEAD [DEF +,
                                                   DEFINITE +]] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1, 
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL familiar-rel].

#|
;experiment version, to get 'den' in 'den snille gutten' to get ARG0 distinct from gutt_rel
det-word := lbl-ltop-lex-item & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [] !>,
                                   LOCAL.CAT.HEAD [DEF +,
                                                   DEFINITE +]] >],
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1, 
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL familiarity-rel,
    SYNSEM.LKEYS.KEYREL.ARG1 #1 ].
|#

;LOCAL.CONT.HOOK.LTOP #2,
;    				   ,
;SYNSEM.LKEYS.KEYREL deictic-rel,
;    SYNSEM.LKEYS.KEYREL.ARG1 #1 



dem-word-super := lbl-ltop-lex-item & lex-or-phrase-synsem & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CONT.HOOK.LTOP #2,
				   LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [LBL #2] !>] >],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,; this was commented away, not sure why.
    SYNSEM.LKEYS.KEYREL arg0-relation ]. 

    
#|
dem-word-super := lbl-ltop-lex-item & lex-or-phrase-synsem & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CONT.HOOK.LTOP #2,
;				   LOCAL.AGR.PNG #5,
				   LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [LBL #2] !>] >],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    SYNSEM.LOCAL.AGR.PNG #5,
    SYNSEM.LKEYS.KEYREL deictic-rel,
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & [ PNG.NG #5 ] ]. 
|#


dem-word-sup := dem-word-super &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD.DEF +] >,
    SYNSEM.LOCAL.CONT.HCONS <!!> ].

; with DEF+ but DEFINITE bool, we allow "den bengalske tiger er utd√∏dd" -
dem-word := dem-word-sup &
[ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD.DEFINITE bool]>].

; cf det-word, for "den snille gutten"
; with DEF+ but DEFINITE-, we allow "den bengalske tiger er utd√∏dd" -
def-q-word := lbl-ltop-lex-item-2rel & no-slash & const-ltow-rule &
  [ SYNSEM.LKEYS.KEYREL familiar-rel,
    SYNSEM.LOCAL.CONT.RELS <!  [ARG0 #2,
                                LBL #3],
                               def-q-rel & [ARG0 #2,
                                            RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.CAT.HEAD det & [KEYS.KEY weaklic],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD.DEF +,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.DERIVED-HEAD -,
                                   LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [] !>] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

;; In the following section, agreement information is moved from INDEX to AGR, 
;; so as to be linguistically sound, and open for a mal rule. EAA 020411.

;; How they used to look like:
;;det-fam-masc-or-fem-sg-word := det-word &
;;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
; LH080613 now redoing that - agreement between subj and adj in copulaconstr got lost
; ,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg
det-fam-masc-or-fem-sg-word := det-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg].

det-fam-neutsg-word := det-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg].

det-fam-pl-word := det-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl].

;,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg
dem-masc-or-fem-sg-word := dem-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg].

;,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg
dem-neutsg-word := dem-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg].

;,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl
dem-pl-word := dem-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl].

def-q-masc-or-fem-sg-word := def-q-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg].

def-q-neutsg-word := def-q-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg].

def-q-pl-word := def-q-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl].

;; Here the change ends. EAA 020411.

; for "klokka fem /fem tretti" , "nummer fem"
; the opened list for SPR in order to get "han kom tirsdag kl to" with weekday-spec-phrase and 'head-initial' spec rule for 'kl to'


; LH030513  dug to deep somewhere, nothing wrong with this one
klokka-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD noun & [COORDINABLE -,
				  KEYS.KEY name-of-card],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-N,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPEC <>,
                           COMPS <>,
			   SPR.FIRST [LOCAL.CONT.HOOK.INDEX [SORT card-unit],
				      LOCAL.CAT.HEAD card ]],
;                           SPR 1-list & <[LOCAL.CONT.HOOK.INDEX [SORT card-unit],
;					  LOCAL.CAT.HEAD card ]> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT time-item, ; applies also to 'nummer ni'
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL arg0-relation].

title-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD noun & [COORDINABLE -],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-N,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
			   SPEC.FIRST [LOCAL.CAT.HEAD prop-noun ]],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT measure-unit],
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL arg0-relation].


klokka-bare-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY crdfix],
    SYNSEM.LOCAL.CAT.HEAD.POS tag-N,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPEC <>,
                           COMPS <>,
                           SPR list ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL arg0-relation].

;SYNSEM.LKEYS.KEYREL partitive-rel & [ ARG1 #1,
;                                          ARG2 #2 ],
    
; "av" in "av guttene" expecting to combine with a quantifier such as
; "hver", "ingen", "noen", "hvilke"

;,
;                                 LOCAL.CAT.HEAD q
part-prep-word := lbl-ltop-lex-item-sinarg0-2rel & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.GEN #gen] ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #2 & [PNG.NG pl,
							      PNG.NG.GEN #gen] ]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH bool,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.CONT.RELS <! [ PRED "_pron_rel",
				ARG0 #1 ], partitive-rel & [ ARG1 #1,
							     ARG2 #2 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

part-q-prep-word := part-prep-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD q ]> ].

part-num-prep-word := part-prep-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD card ]> ].

; "av" in "av guttene" expecting to combine with a cardinal or "mange/f√•".
; a problem is how to induce scoping, since these items don't introduce
; their own quantifier. 
;   drop 'pl' to get mass also LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].

#|
part-card-prep-word := lbl-ltop-lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED "_pron_rel",
				ARG0 #3 ], partitive-rel & [ ARG1 #3,
							     ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3,
                                 LOCAL.CAT.HEAD adjectival & [KEYS.KEY quantas]], ...>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 ]>].
|#

part-card-prep-word := lbl-ltop-lex-item-openarg0-2rel & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.RELS <! [ LBL #lbl,
				PRED "_pron_rel",
				ARG0 #3 ], partitive-rel & [ LBL #lbl,
							     ARG1 #3,
							     ARG2 #9 ]  !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3 & [SORT card-unit],
				 LOCAL.CARD-TO-BARE-N +,
                                 LOCAL.CAT.HEAD comm-noun & [KEYS.KEY absnoun]], ...>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD comm-noun & [ DEF + ], ; np-head
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.LTOP #lbl,
				  LOCAL.CONT.HOOK.INDEX #9 ]>].


part-measurenp-prep-word := lbl-ltop-lex-item-sinarg0-2rel & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED "_pron_rel",
				ARG0 #3 ], partitive-rel & [ ARG1 #3,
							     ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3 & [ SORT measure-unit ],
                                 LOCAL.CAT.HEAD noun ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].


part-adj-prep-word := lbl-ltop-lex-item-sinarg0 & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #3,
    SYNSEM.LOCAL.CONT.HOOK.XARG #9,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.XARG #3,
                                 LOCAL.CAT.HEAD adj ], []>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [ DEF + ],; h√∏yeste av alle guttene
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].


; ,
;                                  LOCAL.CONT.HCONS <! [], [] !> ]>
part-adj-prep2-word := lbl-ltop-lex-item-sinarg0 & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #3,
    SYNSEM.LOCAL.CONT.HOOK.XARG #9,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.XARG #3,
                                 LOCAL.CAT.HEAD adj ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD allquant,
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ]]>].

; "av" in "av vinen" expecting to combine with a quantifier such as
; "mye", "lite", "intet", "noe"
part-q-mass-prep-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #1,
                                 LOCAL.CAT.HEAD q ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD comm-noun, ; & [ DEF + ],"mer av full stilling"
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #2 & [PNG.NG sg ] ]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LKEYS.KEYREL partitive-rel & [ ARG1 #1,
                                          ARG2 #2 ]].
#|
; not clear if this is needed
part-card-mass-prep-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ], 
                            plurindef-q-rel & [ARG0 #3,
                                             RSTR #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #5,
                                LARG #6 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #6,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3,
                                 LOCAL.CAT.HEAD card ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG sg ] ]>].
|#

; "av" in "hav av tilskuere", or "med" in "krukke med genever", expecting to 
; combine with an NP as COMPS which is BOUNDED -
measure-out-prep-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #1 & [SORT measure-unit ],
                                 LOCAL.CAT.HEAD noun & [ KEYS.KEY measnoun ]]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF - ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #2 & [BOUNDED - ] ]>,
    SYNSEM.LOCAL.CONT.HCONS 0-dlist, ;; MHS 160713 Temporary measure. Testing to see if this removes some of the error messages that are produced when the 'check lexicon' function of the LKB is employed.
    SYNSEM.LKEYS.KEYREL measure-out-rel & [ ARG1 #1,
                                            ARG2 #2 ]].






; in cooperation with head-quant-comp-phrase, this word category
; applies uniquely to "alle" and "begge" preceding a definite N-bar
univquant1-part-word := lbl-ltop-lex-item-sinarg0-3rel & 1arg-1comps & const-ltow-rule & 
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ], 
                            indef-q-rel & [ARG0 #3,
                                         RSTR #5 ], 
			    arg0-relation & [PRED "_entity_rel",
					     ARG0 #3] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #5,
                                 LARG #6 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #6,
    SYNSEM.LOCAL.CAT.HEAD allquant,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEFINITE +,
							  DEF +],
                                  LOCAL.CONT.HOOK.INDEX #9,
                                  LOCAL.CAT.VAL.SPR <> ]>,
    SYNSEM.LOCAL.BINDING.BOUND -].

univquant1-part-sg-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>].

; masc-or-fem-sg
univquant1-part-masc-or-fem-sg-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ]>].

univquant1-part-neutsg-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ]>].

univquant1-part-pl-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [PNG.NG pl ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>].


; in cooperation with head-quant-gen-comp-phrase, and before that
; poss-general-genitive-phrase, this word category
; applies uniquely to "alle" and "begge" preceding a genitive
univquant2-part-word := lbl-ltop-lex-item-sinarg0-2rel & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ], 
                            indef-q-rel & [ARG0 #3,
                                           RSTR #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #5,
                                 LARG #6 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [BOUNDED +,
                                  WH - ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #6,
    SYNSEM.LOCAL.CAT.HEAD allquant,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEFINITE - ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 ]>,
    SYNSEM.LOCAL.BINDING.BOUND - ].

univquant2-part-sg-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>].

; masc-or-fem-sg
univquant2-part-masc-or-fem-sg-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ]>].

univquant2-part-neutsg-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ]>].

univquant2-part-pl-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>].

; INDEFINITE QUANTIFIERS and articles
; Changed DEF bool to DEF -. EAA 040411.
;LH   & [KEYS.KEY qkey]
indef-card-quantifier-word-sup := lbl-ltop-lex-item & word & no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD q,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD np-head,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3]>],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [ INDEX #1 & [WH -] ],
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #1,
                                             RSTR #2 ] !>,
    SYNSEM.LOCAL.BINDING.BOUND - ].

indef-card-quantifier-word := indef-card-quantifier-word-sup & 
[ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD [ DEFINITE -, DEF - ]] >].

degreespec-word := lbl-ltop-lex-item-2rel & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD [DEGREE degree]] >],
    SYNSEM.LOCAL.CONT.HCONS <![ HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! [LBL #3,
			       ARG0 #ind ], indef-q-rel & [PRED "_udef_q_rel",
							   ARG0 #ind,
							   RSTR #2] !>].

#|
; 'absolute' use, without 'than-phrase'
degreespec-word-2 := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD [DEGREE degree]] >],
    SYNSEM.LOCAL.CONT.HCONS <![ HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! [LBL #3,
			       ARG0 #ind ], indef-q-rel & [PRED "_diff-amount_q_rel",
							   ARG0 #ind,
							   RSTR #2] !>].
|#

; non-wh-degreewords
degreepos-spec-word-sup := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD [DEGREE positive ]] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

;[why on earth have  HEAD comparative-adv? losing 'meget gammel' - -  SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD comparative-adv & [DEGREE positive ]] >]].
degreepos-spec-word := degreepos-spec-word-sup &
 [ SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD adjectival & [DEGREE positive ]] >]].

degreepos-post-spec-word := degreepos-spec-word-sup.

degreecmpar-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD adjectival,
;				   LOCAL.CAT.HEAD.DEGREE comparative,
;				   LOCAL.CONT.HOOK.INDEX #1,
				   LOCAL.CMPAR-PENDING +] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

; LH060513  For 'absolute' use, without than-clause. The mrs that would be induced by degreecmpar-spec-word will have an ARG2 of 'exceed' which is not instantiated. LKB seems to accept that as long as it is of type 'u', but in principle it should not happen, and THIS TYPE is one where this could be repaired. At the moment it behaves just like degreecmpar-spec-word, as long as the system doesn't complain.
degreecmpar-spec-word-2 := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD adjectival,
;				   LOCAL.CAT.HEAD.DEGREE comparative,
				   LOCAL.CMPAR-PENDING -] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

degreesup-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE superlative ] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

; wh-degreewords: "hvor stor", "hvor mange"
degreewh-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD [DEGREE positive ]] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH + ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].
#|
; wh-degreewords: "hvor stor", "hvor mange"
; comparative-adv & 
wh-degrpos-spec-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD [DEGREE positive]] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH + ]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.RELS <! interrog-q-rel & [PRED "_extent-factor_q_rel",
						ARG0 #1 ] !>].
|#

wh-degreecmpar-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE comparative ] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH + ]],
;    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.RELS <! interrog-q-rel & [PRED "_extent-factor_q_rel",
						ARG0 #1 ], [] !>].

; for "hvor mye" in "hvor mye mer/mindre", treated as a single unit, since
; "mye" cannot alternate with "lite"
wh-sg-degreecmpar-spec-word := wh-degreecmpar-spec-word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CONT.HOOK.INDEX.PNG.NG sg ] >]].
; for "hvor mange" in "hvor mange flere/f√¶rre", treated as a single unit, since
; "mange" cannot alternate with "f√•"
wh-pl-degreecmpar-spec-word := wh-degreecmpar-spec-word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CONT.HOOK.INDEX.PNG.NG pl ] >]].

quantspec-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE positive ] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ] !>].

cardspec-word := quantspec-word &
  [ SYNSEM.LOCAL.CAT.VAL [  SPEC < [LOCAL.CAT.HEAD card] >]].

indefspec-word := quantspec-word &
  [ SYNSEM.LOCAL.CAT.VAL [  SPEC < [LOCAL.CAT.HEAD q] >]].

interrog-quantifier-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD quant & [KEYS.KEY interr-word],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ cons,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD nom,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF - ]>],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ WH + ],
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! interrog-q-rel & [ARG0 #1,
                                                RSTR #2 ] !>].



art-cardone-word-sup := indef-card-quantifier-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD art,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD nom]>,
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_exactly_1_q_rel"] !>].


art-cardone-word := art-cardone-word-sup & indef-card-quantifier-word.


quant-indef-card-word := indef-card-quantifier-word &
  [ SYNSEM.LOCAL.CAT.HEAD quant & [KEYS.KEY non-interr-word] ].

; "intet", "hvert"
quant-indef-card-neutsg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.HEAD n-quant,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD nom]> ].

; "ingenting" - should really be an 'np'-item, but provisionally:
quant-indef-card-mascsg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-sg,
    SYNSEM.LOCAL.CAT.HEAD n-quant,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD nom]> ].

; "ingen", mange, flere (abs)
quant-indef-card-pl-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD n-quant,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD nom]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY + ].

quant-indef-card-univ-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD n-quant,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CMPAR-PENDING - ].

quant-indef-cmpar-card-pl-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD quant,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD nom]>,
    SYNSEM.LOCAL.CMPAR-PENDING bool ].

; "ingen", "noen", "hver"
; masc-or-fem-sg
quant-indef-card-masc-or-fem-sg-word-sup := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CAT.HEAD n-quant ].

; masc-or-fem-sg
quant-indef-nonpart-masc-or-fem-sg-word := quant-indef-card-masc-or-fem-sg-word-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD noun] >].

; masc-or-fem-sg
quant-indef-part-masc-or-fem-sg-word := quant-indef-card-masc-or-fem-sg-word-sup.

; "noe"
quant-indef-ncard-sg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG 3nsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG 3nsg,
    SYNSEM.LOCAL.CAT.HEAD n-quant,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY + ].

; "litt", "mye" (comparable 'mass' quantifiers) with no "sv√¶rt" or "hvor"
; "Ola drikker litt vin". Real quantification
; ,
;    SYNSEM.LOCAL.CAT.HEAD adj-quant 
quant-indef-adjcard2-sg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG.NUM sing,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD.DEGREE positive] >,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY + ].

; "litt", "mye" (comparable 'mass' quantifiers), combined with "sv√¶rt"
; or "hvor" - 'how much wine'
quant-indef-adjcard-sg-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG 3sg],
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR < [] >,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD np-head,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF -,
				   LOCAL.CAT.HEAD.DEGREE positive,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.DERIVED-HEAD -]>],
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #1,
                                             RSTR #2 ] !>].

;  & [KEYS.KEY adjquant-pre]
; suspect with such a wide HEAD type. Trying with the one from above
quant-indef-adjcard-sg-abs-word := lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre],
;    SYNSEM.LOCAL.CAT.HEAD np-head,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < >],
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [RSTR #2 ] !>].



; "hvilke"
interrog-quant-pl-word := interrog-quantifier-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].
; "hvilken"
; masc-or-fem-sg
interrog-quant-masc-or-fem-sg-word := interrog-quantifier-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg ].
; hvilket"
interrog-quant-neutsg-word := interrog-quantifier-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg ].


;; Some changes here to accomodate new type of SPEC-rules. EAA. 020411.

art-neutsg-word := art-cardone-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg].

art-mascsg-word := art-cardone-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-sg ].

;; Old entry
;art-mascsg-poss-word := art-cardone-poss-word &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG masc-sg,
;    SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX.PNG masc-sg]>].

art-femsg-word := art-cardone-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG fem-sg ].

; 'nummer fem' in 'mann nummer fem'
numerical-parameter-word := lbl-ltop-lex-item & word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD q & [KEYS.KEY qkey],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD card,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3]>],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [ INDEX #1 & [WH -] ],
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #1,
                                             RSTR #2 ] !>,
    SYNSEM.LOCAL.BINDING.BOUND - ].







; "mer (enn)", "like (som)"

;; MHS 190713 Added parent no-slash
comparative-adv-word-sup := lbl-ltop-lex-item-3rel & word & rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD adjectival,
				  LOCAL.CONT.HOOK.INDEX #4,
                                  LOCAL.CONT.HOOK.LTOP #1,
                                  LOCAL.CONT.HOOK.XPRED #9,
                                  LOCAL.DERIVED-HEAD - ] >,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

comparative-adv-word := comparative-adv-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative ].

; open how CMPAR-PENDING should behave here
superlative-adv-word := comparative-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative ].

;; MHS 190713 Added parent no-slash
comparative-closecomp-adv-word := lbl-ltop-lex-item-2rel & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv & [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CAT.HEAD cmpar-dep-close,
                                     LOCAL.CONT.HOOK.INDEX #3 ]>,
                           SPEC < [LOCAL.CAT.HEAD.DEGREE positive,
                                   LOCAL.CONT.HOOK.INDEX #4] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #4,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG0 #8,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

#|
comparative-closecomp-with-cmpar-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CAT.HEAD cmpar-dep,
                                     LOCAL.CONT.HOOK.INDEX #3 ]>,
                           SPEC < [LOCAL.CAT.HEAD.DEGREE comparative,
                                   LOCAL.CONT.HOOK.CMPAR-ARG #4] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG0 #8,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #10,
						ARG1 #2,
                                                ARG2 #4 ] !>].
|#

; a slightly leaner version of the above
; for "mer enn fem meter st√∏rre"

;; MHS 190713 Added no-slash & 
comparative-closecomp-with-cmpar-word := lbl-ltop-lex-item-2rel & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv & [ DEGREE comparative ], 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CAT.HEAD cmpar-dep-close,
                                     LOCAL.CONT.HOOK.INDEX #3 ]>,
                           SPEC < [LOCAL.CAT.HEAD.DEGREE comparative,
                                   LOCAL.CONT.HOOK.CMPAR-ARG #4] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ WH - ],
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #10,
						ARG1 #2,
                                                ARG2 #4 ] !> ].
;,
;    SYNSEM.LKEYS.KEYREL.ARG0 #11,
;    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].


;; MHS 190713 Added no-slash &     
cmpar-dep-close-word := word & no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-close, 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [SORT measure-unit ],
                                     LOCAL.CAT.VAL.COMPS <> ]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_cmparpartcl_rel"]!>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

;; MHS 190713 Added no-slash & ; som, enn
cmpar-dep-reg-word := no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD n-or-adj-or-adv, 
						    LOCAL.CONT.HOOK.VARG #3, 
						    LOCAL.CONT.HOOK.LTOP #ltop,
;                                                    LOCAL.CONT.HOOK.CMPAR-PRED #2,
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [ BOUNDED bool ],
				     LOCAL.DERIVED-HEAD -]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop,
;				PRED #2,
				PRED "_comparison-ref-point_rel",
                                ARG0 #3,
                                ARG1 #1 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

cmpar-dep-reg-with-clause-word := no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD n-or-adj, 
						    LOCAL.CONT.HOOK.LTOP #top, 
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
				     LOCAL.CAT.HEAD verb-or-comp]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ LBL #top,
				PRED "_comparison-ref-point_rel",
                                ARG1 #ltop ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

cmpar-dep-reg-with-p-adv-word := no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD n-or-adj, 
						    LOCAL.CONT.HOOK.LTOP #top, 
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
				     LOCAL.CAT.HEAD prep-or-adv]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ LBL #top,
				PRED "_comparison-ref-point_rel",
                                ARG1 #ltop ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

cmpar-dep-reg-cluster-word := no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD n-or-adj, 
						    LOCAL.CONT.HOOK.VARG #3, 
						    LOCAL.CONT.HOOK.LTOP #ltop,
                                                    LOCAL.CMPAR-PENDING +,
                                                    LEX - ] >, ; must be "s√•" plus adjective
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ COMPS <>,;[LOCAL.CONT.HOOK.INDEX #1 & [BOUNDED bool]]
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop,
				PRED "_comparison-ref-point_rel",
                                ARG0 #3,
                                ARG1 semarg ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

;; MHS 190713 Added no-slash & 
cmpar-dep-diff-for-noun-word := no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD nom,
						    LOCAL.CONT.HOOK.INDEX #3,
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [ BOUNDED bool ]]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ PRED "_exceeds-in-q-dim-in-activity_rel",
                                ARG1 #3,
                                ARG2 #1 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

;; MHS 190713 Added no-slash &     
cmpar-dep-equal-for-noun-word := no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD nom,
						    LOCAL.CONT.HOOK.INDEX #3,
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [ BOUNDED bool ]]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ PRED "_equals-in-q-dim-in-activity_rel",
                                ARG1 #3,
                                ARG2 #1 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
    
;; MHS 190713 Added no-slash & 
comparative-adv-vp-mod-word-sup := lbl-ltop-lex-item-3rel & word & rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adv & [POS tag-adv],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb,
                                  LOCAL.CONT.HOOK.INDEX #4,
                                  LOCAL.CONT.HOOK.LTOP #1,
                                  LOCAL.CONT.HOOK.XPRED #9,
                                  LOCAL.DERIVED-HEAD - ] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

comparative-adv-vp-mod-word := comparative-adv-vp-mod-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative ].

; open how CMPAR-PENDING should behave here
superlative-adv-vp-mod-word := comparative-adv-vp-mod-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative ].


; const-ltow-rule &
; to allow "hele Ola" and "den snille Ola", use 'DEFINITE bool'
proper-name-word := lbl-ltop-lex-item-2rel & word & rule & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD #5 & prop-noun & [ DEF +,
                                             DEFINITE bool,
                                             COORDINABLE +,
					     BARE -,
					     EXPLETIVE -,
                                             KEYS.KEY propnoun ],
    SYNSEM.LOCAL.XCAT.HEAD #5,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.PROPERNAME +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             PNG.PERS thirdpers,
                                             SORT full-thing ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC list,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.BINDING.BOUND -,
;    SYNSEM.LOCAL.INHER-WH -,
    SYNSEM.BIND unbnd-min,
    SYNSEM.LOCAL.CONT.RELS <!  named-relation & [ARG0 #2,
                                            LBL #3],
                               def-q-rel & [ARG0 #2,
                                          RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

proprium-noun-lxm := lbl-ltop-lex-item-2rel & word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD #5 & prop-noun & [ DEF +,
                                             DEFINITE bool,
                                             BARE - ],
    SYNSEM.LOCAL.XCAT.HEAD #5,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             PNG.PERS thirdpers,
                                             SORT full-thing ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC list,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.BIND unbnd-min,
    SYNSEM.LOCAL.CONT.RELS <!  named-relation & [ARG0 #2,
                                            LBL #3],
                               def-q-rel & [ARG0 #2,
                                          RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

mascsg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-sg ].
femsg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem-sg ].
neutsg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ].
; masc-or-fem-sg
masc-or-fem-sg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
commpl-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-pl ].
neutpl-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutpl ].

mascsg-anim-proper-name-word := mascsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
firstname-mascsg-anim-proper-name-word := mascsg-anim-proper-name-word &
[ SYNSEM.LOCAL.FIRSTNAME + ].
lastname-mascsg-anim-proper-name-word := mascsg-anim-proper-name-word &
[ SYNSEM.LOCAL.FIRSTNAME - ].
mascsg-inan-proper-name-word := mascsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
femsg-anim-proper-name-word := femsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
firstname-femsg-anim-proper-name-word := femsg-anim-proper-name-word &
[ SYNSEM.LOCAL.FIRSTNAME + ].
lastname-femsg-anim-proper-name-word := femsg-anim-proper-name-word &
[ SYNSEM.LOCAL.FIRSTNAME - ].
femsg-inan-proper-name-word := femsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
neutsg-anim-proper-name-word := neutsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
firstname-neutsg-anim-proper-name-word := neutsg-anim-proper-name-word &
[ SYNSEM.LOCAL.FIRSTNAME + ].
lastname-neutsg-anim-proper-name-word := neutsg-anim-proper-name-word &
[ SYNSEM.LOCAL.FIRSTNAME - ].
neutsg-inan-proper-name-word := neutsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
; masc-or-fem-sg
masc-or-fem-sg-anim-proper-name-word := masc-or-fem-sg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
; masc-or-fem-sg
masc-or-fem-sg-inan-proper-name-word := masc-or-fem-sg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
commpl-anim-proper-name-word := commpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
commpl-inan-proper-name-word := commpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
neutpl-anim-proper-name-word := neutpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
neutpl-inan-proper-name-word := neutpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].


;;;;;; THE PRONOMINAL SYSTEM



bindable-word := word &
  [ SYNSEM.LOCAL.BINDING binding ].

; "som" as in "gutten som smiler": "som" is here subject, combining by head-relative-subject-phrase. which in turn adjoins to N by relative-subj-mod-phrase. This "som" can not invert - must be marked for that
; removing ARG0 has wide ramifications - see validatebon_597, and rules, comments LH04102018. Thus taking the part '-sinarg0' away.
subj-relpron := lbl-ltop-lex-item-sinarg0 & rule & bindable-word & no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD comp & [ ACCUSATIVE -,
				   SELECTED -],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.SUBJ-ONLY +,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    RULE card-ok,
    RESUMPTIVE - ].

; rel_pron_rel
som_subj-relpron := subj-relpron & 
  [ SYNSEM.LOCAL.CAT.HEAD rel-pron,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH - ],
    SYNSEM.LOCAL.CONT.RELS <! rel_pron_rel !> ]. ; & [ARG0 #arg, ARG1 #arg]
    
hvilket_subj-relpron := subj-relpron & 
  [ SYNSEM.LOCAL.CAT.HEAD comp,
    SYNSEM.LOCAL.CONT.HOOK.INDEX event-verb & [ WH - ],
    SYNSEM.LOCAL.CONT.RELS <!  vp-rel_pron_rel !> ].



som-resumpt-word := lbl-ltop-lex-item & rule & bindable-word & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD rel-pron & [ ACCUSATIVE -,
                                       SELECTED - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH + ], ; ref-ind & 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < >,
                           SPR < >,
                           SPEC < >,
                           COMPS < >],
    SYNSEM.LOCAL.SUBJ-ONLY +,
    SYNSEM.LOCAL.CONT.RELS <! res-pron-rel  !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
   ; SYNSEM.NON-LOCAL.SLASH 1-dlist & [ LIST < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #index ] > ], 
    RESUMPTIVE +,
    RULE card-ok ].


interrog-pron-word := lbl-ltop-lex-item-2rel & rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [KEYS.KEY interr-word],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH +,
                                             SORT referential-thing],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  pers-pron-rel & [ARG0 #2,
                                                LBL #3],
                               interrog-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL 3rd-wh-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

interrog-adv-word := lbl-ltop-lex-item-2rel & rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY interr-word],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH +,
                                             SORT referential-thing],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  pers-pron-rel & [ARG0 #2,
                                                LBL #3],
                               interrog-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL 3rd-wh-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].
#|
adv-word-reg-sup := reg-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD adv,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point] ].
|#

; ,
;    SYNSEM.NON-LOCAL.SLASH 0-dlist
; const-ltow-rule &
pers-pron-word := lbl-ltop-lex-item-2rel & rule & bindable-word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [DEF +,
                                       KEYS.KEY persprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             SORT referential-thing ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
;                           SPR < >,
;                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I -,
                           REFL-II - ],
 ;   SYNSEM.LOCAL.BND-MOUNTABLE < >,
    SYNSEM.LOCAL.CONT.RELS <!  pers-pron-rel & [ARG0 #2,
                                                LBL #3],
                               contextual-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.HAS-REL-CL -,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

; imposed rather in lexicon - - too many subtypes
;pers-pron-str-word := pers-pron-word-sup &
;  [ SYNSEM.LOCAL.CTXT.DISC-BOUND + ].
;pers-pron-weak-word := pers-pron-word-sup &
;  [ SYNSEM.LOCAL.CTXT.DISC-BOUND - ].


#|
seg-word := lbl-ltop-lex-item-3rel & rule & bindable-word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [DEF +,
                                       KEYS.KEY persprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             SORT referential-thing ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #index,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #2,
                                                LBL #3],
                               reflexive-q-rel & [ARG0 #2,
                                                   RSTR #4],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #2 & [PNG.PERS #p],
                                                 ARG2 #index & [PNG.PERS #p]] !>,
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.CTXT pron-discbnd,
    RULE card-ok ].
|#
;,
;                                             SORT referential-thing
;   not clear why so loose constraint - allows 'han anser seg snilt'                                               ARG1 #2 & [PNG.PERS #p],
;                                                 ARG2 #index & [PNG.PERS #p]] !>
seg-word := lbl-ltop-lex-item-3rel & rule & bindable-word & no-slash & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [DEF +,
                                       KEYS.KEY persprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #index,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #2,
                                                LBL #3],
                               reflexive-q-rel & [ARG0 #2,
                                                   RSTR #4],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #2 & [PNG #p,
							    SORT sort],
                                                 ARG2 #index & [PNG #p,
								SORT sort]] !>,
    SYNSEM.LOCAL.BND-RESP < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.CTXT pron-discbnd,
    RULE card-ok ].


; ,
;    SYNSEM.LOCAL.BND-RESP < >
nonrefl-pron-word := bindable-word &
  [ SYNSEM.LOCAL.BINDING [ BOUND bool,
                           REFL-I -,
                           REFL-II - ] ].

#|
seg-pron-word := bindable-word & no-slash & 
  [ SYNSEM.LOCAL.BINDING #1 & [ BOUND +,
                                REFL-I +,
                                REFL-II - ],
    SYNSEM.LOCAL.CONT.HOOK [VARG #index],
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-TYPE #1,
                                            ANAPH-INDX #index ] > ].
|#

seg-pron-word := bindable-word & no-slash & 
  [ SYNSEM.LOCAL.BINDING #1 & [ BOUND +,
                                REFL-I + ],
    SYNSEM.LOCAL.CONT.HOOK [VARG #index],
    SYNSEM.LOCAL.BND-RESP #bnd & < bindee & [ ANAPH-TYPE #1,
                                       ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.BND-MOUNTABLE #bnd ].


nom-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE - ].
acc-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE + ].

sg-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
plur-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

acc-seg-pron := seg-word &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE + ].

sg-seg-pron := seg-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
plur-seg-pron := seg-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

1st-pers-pron-word := pers-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-pers-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS firstpers,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem, ; too strong, really
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers].
2nd-pers-pron-word := pers-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pers-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS secpers,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem, ; too strong, really
   SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
3rd-pers-pron-word := pers-pron-word &
  [SYNSEM.LKEYS.KEYREL 3rd-pers-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
   SYNSEM.LOCAL.AGR.PNG.PERS thirdpers ].

1st-seg-pron-word := seg-word &
  [SYNSEM.LKEYS.KEYREL 1st-refl-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [PNG.PERS firstpers],
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers].
2nd-seg-pron-word := seg-word &
  [SYNSEM.LKEYS.KEYREL 2nd-refl-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [PNG.PERS secpers],
   SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
3rd-seg-pron-word := seg-word &
  [SYNSEM.LKEYS.KEYREL 3rd-refl-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
   SYNSEM.LOCAL.AGR.PNG.PERS thirdpers ].

; Commented out the line ;SYNSEM.LKEYS.KEYREL.PRED "_pron_rel", in the following 
; types, to avoid "en","man","den","denne" and "han" be represented as the same. EAA 01.04.11.
3rd-masc-pron := 3rd-pers-pron-word &
  [ ;SYNSEM.LKEYS.KEYREL.PRED "_3rd-masc_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc,
   SYNSEM.LOCAL.AGR.PNG.NG masc ].
3rd-fem-pron := 3rd-pers-pron-word &
  [;SYNSEM.LKEYS.KEYREL.PRED "_3rd-masc_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem,
   SYNSEM.LOCAL.AGR.PNG.NG fem ].
3rd-masc-or-fem-pron := 3rd-pers-pron-word &
  [ ;SYNSEM.LKEYS.KEYREL.PRED "_3rd-masc_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem,
   SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem ].

3rd-neut-pron := 3rd-pers-pron-word &
  [;SYNSEM.LKEYS.KEYREL.PRED "_3rd-masc_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut,
   SYNSEM.LOCAL.AGR.PNG.NG neut ].

;  &
;  [SYNSEM.LKEYS.KEYREL 3rd-pl-pers-pron-rel ]
3rd-plural-pron := 3rd-pers-pron-word.

; masc-or-fem-sg
3rd-masc-or-fem-sg-pron := 3rd-pers-pron-word.
3rd-neutsg-pron := 3rd-pers-pron-word.

; deleting 'nonrefl-pron-word &' from all non-3rd sg pronouns, so as to avoid reduplication of "meg", "deg" etc
1st-sg-nom-pers-pron := 1st-pers-pron-word & nom-pers-pron & sg-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel ].
#|
1st-sg-acc-pers-pron := 1st-pers-pron-word & acc-pers-pron & sg-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel ].
|#
1st-sg-acc-pers-pron := 1st-pers-pron-word & acc-pers-pron & sg-pers-pron &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel ].
1st-pl-nom-pers-pron := 1st-pers-pron-word & nom-pers-pron & plur-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-pl-pers-pron-rel ].
1st-pl-acc-pers-pron := 1st-pers-pron-word & acc-pers-pron & plur-pers-pron &
  [SYNSEM.LKEYS.KEYREL 1st-pl-pers-pron-rel ].
2nd-sg-nom-pers-pron := 2nd-pers-pron-word & nom-pers-pron & sg-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-pers-pron-rel ].
2nd-sg-acc-pers-pron := 2nd-pers-pron-word & acc-pers-pron & sg-pers-pron &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-pers-pron-rel ].
2nd-pl-pers-pron := 2nd-pers-pron-word & plur-pers-pron &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-pers-pron-rel ].

3rd-sg-masc-nom-pers-pron := nom-pers-pron & sg-pers-pron & 3rd-masc-pron & nonrefl-pron-word.
3rd-sg-fem-nom-pers-pron := nom-pers-pron & sg-pers-pron & 3rd-fem-pron & nonrefl-pron-word.
; masc-or-fem-sg
; strange item, so replace by the one elow
;3rd-sg-neut-masc-or-fem-sg-pers-pron := sg-pers-pron & 3rd-neut-pron & 3rd-masc-or-fem-sg-pron & nonrefl-pron-word.
3rd-sg-neut-masc-or-fem-sg-pers-pron := sg-pers-pron & 3rd-masc-or-fem-pron & 3rd-masc-or-fem-sg-pron & nonrefl-pron-word.
3rd-sg-neut-neutsg-pers-pron := sg-pers-pron & 3rd-neut-pron & 3rd-neutsg-pron & nonrefl-pron-word.

3rd-sg-masc-acc-pers-pron := acc-pers-pron & sg-pers-pron & 3rd-masc-pron & nonrefl-pron-word.
3rd-sg-fem-acc-pers-pron := acc-pers-pron & sg-pers-pron & 3rd-fem-pron & nonrefl-pron-word.

3rd-pl-pers-pron := plur-pers-pron & 3rd-plural-pron & nonrefl-pron-word.
3rd-pl-nom-pers-pron := nom-pers-pron & 3rd-pl-pers-pron.
3rd-pl-acc-pers-pron := acc-pers-pron & 3rd-pl-pers-pron.

1st-sg-seg-pron := 1st-seg-pron-word & acc-seg-pron & sg-seg-pron  & seg-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-refl-pron-rel ].
1st-pl-seg-pron := 1st-seg-pron-word & acc-seg-pron & plur-seg-pron & seg-pron-word  &
  [SYNSEM.LKEYS.KEYREL 1st-pl-refl-pron-rel ].
2nd-sg-seg-pron := 2nd-seg-pron-word & acc-seg-pron & sg-seg-pron & seg-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-refl-pron-rel ].
2nd-pl-seg-pron := 2nd-seg-pron-word & plur-seg-pron & seg-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-refl-pron-rel ].
3rd-seg-pron := acc-seg-pron & seg-pron-word &
  [ SYNSEM.LKEYS.KEYREL 3rd-refl-pron-rel,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers ].

reciproc-pron := acc-seg-pron & plur-seg-pron.

;reciproc-pron := acc-seg-pron & plur-seg-pron & seg-pron-word  &
;  [SYNSEM.LKEYS.KEYREL refl-pron-rel ].

poss-reflpron-word := lbl-ltop-lex-item-3rel & bindable-word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD posspron & [KEYS.KEY possprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
;    SYNSEM.LOCAL.AGR #1,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < [LOCAL.CAT.HEAD.DEFINITE bool,
                                   LOCAL.CAT.HEAD.DEF +,
				   LOCAL.CONT.HOOK.LTOP #ltop] >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #1,
                                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4],
                               arg12-relation & [LBL #ltop,
						 PRED "coreferential_rel",
                                                 ARG1 #1 & [PNG.PERS #p], 
                                                 ARG2 #index & [PNG.PERS #p]] !>,  
    SYNSEM.LOCAL.BND-MOUNTABLE #bnd & < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok].

; LH080416 experm - here the contextual-q-rel and HCONS must be induced in C-CONT in the rule for prenominal pronoun, and by the definite article in the case of the postnominal pronoun.
; LH080114 DONE
;                                   LOCAL.CAT.HEAD.DEF +  prevents 'mine gutter'
poss-pron-word-sup := lbl-ltop-lex-item-2rel & bindable-word & rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD posspron & [KEYS.KEY possprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
			   SPEC < [ ] >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  [ARG0 #1,
                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].


poss-pron-word := poss-pron-word-sup &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

poss-wh-pron-word := poss-pron-word-sup &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

;"hvis" as in "gutten hvis katt mjauer ..."
rel-poss-pron-word := lbl-ltop-lex-item & bindable-word & rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD posspron & [KEYS.KEY possprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
			   SPEC < [ ] >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  [ARG1 #1] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    RULE card-ok ].  ; , SYNSEM.LKEYS.KEYREL.ARG0 #11,SYNSEM.LKEYS.ALTKEYREL.ARG0 #11

; "Ola sine katter" - "Ola" is COMPS, "katter" is SPEC, "sine" this word, and "s" likewise.

#| ;1
poss-particle-word := rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD possparticle & [KEYS.KEY posspcl],
    SYNSEM.LOCAL.AGR.PNG #png,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #2, ;#1 & ref-ind, From previous regarding #1 and #2 Clashes when numbers are different
;    SYNSEM.LOCAL.CONT.HOOK.VARG #2,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CONT.HOOK.INDEX.PNG #png, ;INDEX #1 & 
				   LOCAL.CAT.HEAD.DEF + ] >,
                           COMPS <[ LOCAL.CONT.HOOK.INDEX semarg,
				    LOCAL.CONT.HOOK.LTOP #lbl]> ],
    SYNSEM.LOCAL.AGR.PNG #png,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [PNG #png],
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_posspartcl_rel",
;						    ARG0 #2,
						    LBL #lbl ] !>,
    SYNSEM.LOCAL.CONT.HCONS <!  !>,
    RULE card-ok].
|#

;NEW - from svn 558
poss-particle-word := rule & no-slash & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD possparticle & [KEYS.KEY posspcl],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF + ] >,
                           COMPS <[ LOCAL.CONT.HOOK.INDEX #1,
				    LOCAL.CONT.HOOK.LTOP #lbl]> ],
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_posspartcl_rel",
						    LBL #lbl ] !>,
    SYNSEM.LOCAL.CONT.HCONS <!  !>,
    RULE card-ok].



; masc-or-fem-sg - ?
poss-mascsg-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG #png & [NG masc-sg],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [PNG #png]].

poss-femsg-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG fem-sg ].

poss-neutsg-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg ].

poss-plur-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl ].


;LH090416 deactivated - the rule postnom-poss-phrase has been redefined in such a way that the same lex-items for possessives can be used both pre- and postnominally.
poss-reflpron-post-word := lbl-ltop-lex-item-4rel & bindable-word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD postposspron & [MOD < [LOCAL.CAT.HEAD.DEFINITE +,
                                                 LOCAL.CONT.HOOK.INDEX #5 ] >,
                                          KEYS.KEY possprn],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
;    SYNSEM.LOCAL.AGR #1,
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #1,
                                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4],
                            poss-rel & [ LBL #3,
					 ARG1 #1,
                                         ARG2 #5 ],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #1 & [PNG.PERS #p],
                                                 ARG2 #index & [PNG.PERS #p]] !>,
;    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.BND-MOUNTABLE #bnd & < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3]  !>,
    RULE card-ok].

;LH090416 deactivated - the rule postnom-poss-phrase has been redefined in such a way that the same lex-items for possessives can be used both pre- and postnominally.
poss-pron-post-word := lbl-ltop-lex-item-3rel & bindable-word & rule & 
  [ SYNSEM.LOCAL.CAT.HEAD postposspron & [MOD < [LOCAL.CAT.HEAD.DEFINITE +,
						 LOCAL.CONT.HOOK.INDEX #5 ] >],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    SYNSEM.LOCAL.CONT.RELS <!  [ARG0 #1,
                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4],
                            poss-rel & [ LBL #3,
					 ARG1 #1,
                                         ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3]  !>,
    RULE card-ok].

poss-word := word & const-ltow-rule.
sg-poss := poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].
plur-poss := poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

1st-poss-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-pers-pron-rel,
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers ].
1st-sg-poss-word := 1st-poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
1st-pl-poss-word := 1st-poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-pl-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].
2nd-poss-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
2nd-sg-poss-word := 2nd-poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
2nd-pl-poss-word := 2nd-poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

3rd-poss-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 3rd-pers-pron-rel ].

3rd-quest-poss-word := poss-word & poss-wh-pron-word &
  [SYNSEM.LKEYS.KEYREL 3rd-wh-pers-pron-rel ].

; pied piping 'hvis' in relatives. To work, it must induce a feature on the hosting NP which releases WH-COMPLETE + when used as subject (head-relative-subject-phrase), and is recognized as a relative filler when not a subject (rel-head-filler-phrase)
;poss-pron-word &
3rd-rel-poss-word := poss-word & rel-poss-pron-word &
  [SYNSEM.LKEYS.KEYREL 3rd-rel-pron-rel ]. ;3rd-wh-pers-pron-rel
;3rd-rel-poss-word := poss-word. TODO: to avoid twice same quantied vbl in "mannen hvis hund...", the second rel must be gotten rid of
3rd-sg-masc-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_masc_anim_rel",
    SYNSEM.LOCAL.AGR.PNG 3msg ].
3rd-sg-fem-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_fem_anim_rel",
    SYNSEM.LOCAL.AGR.PNG 3fsg ].
3rd-sg-neut-msc-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_neutanim_msc_rel",
    SYNSEM.LOCAL.AGR.PNG 3nsg ].
3rd-sg-neut-nt-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_neutanim_nt_rel",
    SYNSEM.LOCAL.AGR.PNG 3nsg ].
3rd-plural-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL 3rd-pl-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG 3pl ].

; masc-or-fem-sg "dens"?
3rd-masc-or-fem-sg-poss := 3rd-poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
3rd-neutsg-poss := 3rd-poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ].

;; for reflexive possessives
1st-reflposs-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-refl-pron-rel,
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers ].
1st-sg-reflposs-word := 1st-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
1st-pl-reflposs-word := 1st-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 1st-pl-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].
2nd-reflposs-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
2nd-sg-reflposs-word := 2nd-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
2nd-pl-reflposs-word := 2nd-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

3rd-reflposs-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 3rd-refl-pron-rel ].

; PRONOMINAL possessives, neutral as to pre- or post-nominal
; min
; masc-or-fem-sg? or masc-sg
1st-mascsg-poss-pron := 1st-sg-poss-word & sg-poss & nonrefl-pron-word & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; mi
1st-sg-fem-poss-pron := 1st-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; mitt
1st-sg-neut-poss-pron := 1st-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; mine
1st-sg-plur-poss-pron := 1st-sg-poss-word & plur-poss & nonrefl-pron-word.

; v√•r
; masc-or-fem-sg
1st-pl-masc-or-fem-sg-poss-pron := 1st-pl-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
; v√•rt
1st-pl-neut-poss-pron := 1st-pl-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; v√•re
1st-pl-plur-poss-pron := 1st-pl-poss-word & plur-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

; din
; masc-or-fem-sg ? rather masc-sg
2nd-mascsg-poss-pron := 2nd-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; di
2nd-sg-fem-poss-pron := 2nd-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; ditt
2nd-sg-neut-poss-pron := 2nd-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; dine
2nd-sg-plur-poss-pron := 2nd-sg-poss-word & plur-poss & nonrefl-pron-word.

; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-pron := 2nd-pl-poss-word & nonrefl-pron-word.


; hans (combines with all genders, and both numbers)
3rd-sg-masc-poss-pron := 3rd-sg-masc-poss & nonrefl-pron-word.
; hennes (combines with all genders, and both numbers)
3rd-sg-fem-poss-pron := 3rd-sg-fem-poss & nonrefl-pron-word.
; dens (combines with all genders, and both numbers)
3rd-sg-neut-msc-poss-pron := 3rd-sg-neut-msc-poss & nonrefl-pron-word.
; dets (combines with all genders, and both numbers)
3rd-sg-neut-nt-poss-pron := 3rd-sg-neut-nt-poss & nonrefl-pron-word.
; deres (combines with all genders, and both numbers)
3rd-plural-poss-pron := 3rd-plural-poss & nonrefl-pron-word.

;Pre-possessors

; min
; masc-or-fem-sg? see above - masc-sg 
1st-mascsg-poss-pron-pre := 1st-mascsg-poss-pron & poss-pron-word.
; mi
1st-sg-fem-poss-pron-pre := 1st-sg-fem-poss-pron & poss-pron-word.
; mitt
1st-sg-neut-poss-pron-pre := 1st-sg-neut-poss-pron & poss-pron-word.
; mine
1st-sg-plur-poss-pron-pre := 1st-sg-plur-poss-pron & poss-pron-word.
; v√•r
; masc-or-fem-sg
1st-pl-masc-or-fem-sg-poss-pron-pre := 1st-pl-masc-or-fem-sg-poss-pron & poss-pron-word.
; v√•rt
1st-pl-neut-poss-pron-pre := 1st-pl-neut-poss-pron & poss-pron-word.
; v√•re
1st-pl-plur-poss-pron-pre := 1st-pl-plur-poss-pron & poss-pron-word.

; din
; masc-or-fem-sg? masc-sg
2nd-mascsg-poss-pron-pre := 2nd-mascsg-poss-pron & poss-pron-word.
; di
2nd-sg-fem-poss-pron-pre := 2nd-sg-fem-poss-pron & poss-pron-word.
; ditt
2nd-sg-neut-poss-pron-pre := 2nd-sg-neut-poss-pron & poss-pron-word.
; dine
2nd-sg-plur-poss-pron-pre := 2nd-sg-plur-poss-pron & poss-pron-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-pron-pre := 2nd-pl-poss-pron & poss-pron-word.

; hans (combines with all genders, and both numbers)
3rd-sg-masc-poss-pron-pre := 3rd-sg-masc-poss-pron & poss-pron-word.
; hennes (combines with all genders, and both numbers)
3rd-sg-fem-poss-pron-pre := 3rd-sg-fem-poss-pron & poss-pron-word.
; dens (combines with all genders, and both numbers)
3rd-sg-neut-msc-poss-pron-pre := 3rd-sg-neut-msc-poss-pron & poss-pron-word.
; dets (combines with all genders, and both numbers)
3rd-sg-neut-nt-poss-pron-pre := 3rd-sg-neut-nt-poss-pron & poss-pron-word.
; deres (combines with all genders, and both numbers)
3rd-plural-poss-pron-pre := 3rd-plural-poss-pron & poss-pron-word.


;Post-possessors

; min
; masc-or-fem-sg - no
1st-mascsg-poss-pron-post := 1st-mascsg-poss-pron & poss-pron-post-word.
; mi
1st-sg-fem-poss-pron-post := 1st-sg-fem-poss-pron & poss-pron-post-word.
; mitt
1st-sg-neut-poss-pron-post := 1st-sg-neut-poss-pron & poss-pron-post-word.
; mine
1st-sg-plur-poss-pron-post := 1st-sg-plur-poss-pron & poss-pron-post-word.
; v√•r
; masc-or-fem-sg - see above
1st-pl-masc-or-fem-sg-poss-pron-post := 1st-pl-masc-or-fem-sg-poss-pron & poss-pron-post-word.
; v√•rt
1st-pl-neut-poss-pron-post := 1st-pl-neut-poss-pron & poss-pron-post-word.
; v√•re
1st-pl-plur-poss-pron-post := 1st-pl-plur-poss-pron & poss-pron-post-word.

; din
; masc-or-fem-sg? no, only masc-sg
2nd-mascsg-poss-pron-post := 2nd-mascsg-poss-pron & poss-pron-post-word.
; di
2nd-sg-fem-poss-pron-post := 2nd-sg-fem-poss-pron & poss-pron-post-word.
; ditt
2nd-sg-neut-poss-pron-post := 2nd-sg-neut-poss-pron & poss-pron-post-word.
; dine
2nd-sg-plur-poss-pron-post := 2nd-sg-plur-poss-pron & poss-pron-post-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-pron-post := 2nd-pl-poss-pron & poss-pron-post-word.

; hans (combines with all genders, and both numbers)
3rd-sg-masc-poss-pron-post := 3rd-sg-masc-poss-pron & poss-pron-post-word.
; hennes (combines with all genders, and both numbers)
3rd-sg-fem-poss-pron-post := 3rd-sg-fem-poss-pron & poss-pron-post-word.
; dens (combines with all genders, and both numbers)
3rd-sg-neut-msc-poss-pron-post := 3rd-sg-neut-msc-poss-pron & poss-pron-post-word.
; dets (combines with all genders, and both numbers)
3rd-sg-neut-nt-poss-pron-post := 3rd-sg-neut-nt-poss-pron & poss-pron-post-word.
; deres (combines with all genders, and both numbers)
3rd-plural-poss-pron-post := 3rd-plural-poss-pron & poss-pron-post-word.


; masc-or-fem-sg - same as for non-refl
; REFLEXIVE possessives, neutral as to whether pre- or post
; min
1st-mascsg-poss-refl-pron := 1st-sg-reflposs-word & sg-poss & seg-pron-word & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; mi
1st-sg-fem-poss-refl-pron := 1st-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; mitt
1st-sg-neut-poss-refl-pron := 1st-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; mine
1st-sg-plur-poss-refl-pron := 1st-sg-reflposs-word & plur-poss & seg-pron-word.

; v√•r
1st-pl-masc-or-fem-sg-poss-refl-pron := 1st-pl-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
; v√•rt
1st-pl-neut-poss-refl-pron := 1st-pl-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; v√•re
1st-pl-plur-poss-refl-pron := 1st-pl-reflposs-word & plur-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].
; din
2nd-mascsg-poss-refl-pron := 2nd-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; di
2nd-sg-fem-poss-refl-pron := 2nd-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; ditt
2nd-sg-neut-poss-refl-pron := 2nd-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; dine
2nd-sg-plur-poss-refl-pron := 2nd-sg-reflposs-word & plur-poss & seg-pron-word.

; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-refl-pron := 2nd-pl-reflposs-word & seg-pron-word.

; sin
3rd-mascsg-poss-refl-pron := 3rd-reflposs-word & sg-poss & seg-pron-word & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; si
3rd-sg-fem-poss-refl-pron := 3rd-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; sitt
3rd-sg-neut-poss-refl-pron := 3rd-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; sine
3rd-plur-poss-refl-pron := 3rd-reflposs-word & plur-poss & seg-pron-word.

; Pre-nominal possessive refl
; min
1st-mascsg-poss-refl-pron-pre := 1st-mascsg-poss-refl-pron & poss-reflpron-word.
; mi
1st-sg-fem-poss-refl-pron-pre := 1st-sg-fem-poss-refl-pron & poss-reflpron-word.
; mitt
1st-sg-neut-poss-refl-pron-pre := 1st-sg-neut-poss-refl-pron & poss-reflpron-word.
; mine
1st-sg-plur-poss-refl-pron-pre := 1st-sg-plur-poss-refl-pron & poss-reflpron-word.
; v√•r
1st-pl-masc-or-fem-sg-poss-refl-pron-pre := 1st-pl-masc-or-fem-sg-poss-refl-pron & poss-reflpron-word.
; v√•rt
1st-pl-neut-poss-refl-pron-pre := 1st-pl-neut-poss-refl-pron & poss-reflpron-word.
; v√•re
1st-pl-plur-poss-refl-pron-pre := 1st-pl-plur-poss-refl-pron & poss-reflpron-word.
; din
2nd-mascsg-poss-refl-pron-pre := 2nd-mascsg-poss-refl-pron & poss-reflpron-word.
; di
2nd-sg-fem-poss-refl-pron-pre := 2nd-sg-fem-poss-refl-pron & poss-reflpron-word.
; ditt
2nd-sg-neut-poss-refl-pron-pre := 2nd-sg-neut-poss-refl-pron & poss-reflpron-word.
; dine
2nd-sg-plur-poss-refl-pron-pre := 2nd-sg-plur-poss-refl-pron & poss-reflpron-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-refl-pron-pre := 2nd-pl-poss-refl-pron & poss-reflpron-word.
; sin
3rd-mascsg-poss-refl-pron-pre := 3rd-mascsg-poss-refl-pron & poss-reflpron-word.
; si
3rd-sg-fem-poss-refl-pron-pre := 3rd-sg-fem-poss-refl-pron & poss-reflpron-word.
; sitt
3rd-sg-neut-poss-refl-pron-pre := 3rd-sg-neut-poss-refl-pron & poss-reflpron-word.
; sine
3rd-plur-poss-refl-pron-pre := 3rd-plur-poss-refl-pron & poss-reflpron-word.

; postnominal reflexive possessives
; min
1st-mascsg-poss-refl-pron-post := 1st-mascsg-poss-refl-pron & poss-reflpron-post-word.
; mi
1st-sg-fem-poss-refl-pron-post := 1st-sg-fem-poss-refl-pron & poss-reflpron-post-word.
; mitt
1st-sg-neut-poss-refl-pron-post := 1st-sg-neut-poss-refl-pron & poss-reflpron-post-word.
; mine
1st-sg-plur-poss-refl-pron-post := 1st-sg-plur-poss-refl-pron & poss-reflpron-post-word.
; v√•r
1st-pl-masc-or-fem-sg-poss-refl-pron-post := 1st-pl-masc-or-fem-sg-poss-refl-pron & poss-reflpron-post-word.
; v√•rt
1st-pl-neut-poss-refl-pron-post := 1st-pl-neut-poss-refl-pron & poss-reflpron-post-word.
; v√•re
1st-pl-plur-poss-refl-pron-post := 1st-pl-plur-poss-refl-pron & poss-reflpron-post-word.
; din
2nd-mascsg-poss-refl-pron-post := 2nd-mascsg-poss-refl-pron & poss-reflpron-post-word.
; di
2nd-sg-fem-poss-refl-pron-post := 2nd-sg-fem-poss-refl-pron & poss-reflpron-post-word.
; ditt
2nd-sg-neut-poss-refl-pron-post := 2nd-sg-neut-poss-refl-pron & poss-reflpron-post-word.
; dine
2nd-sg-plur-poss-refl-pron-post := 2nd-sg-plur-poss-refl-pron & poss-reflpron-post-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-refl-pron-post := 2nd-pl-poss-refl-pron & poss-reflpron-post-word.
; sin
3rd-mascsg-poss-refl-pron-post := 3rd-mascsg-poss-refl-pron & poss-reflpron-post-word.
; si
3rd-sg-fem-poss-refl-pron-post := 3rd-sg-fem-poss-refl-pron & poss-reflpron-post-word.
; sitt
3rd-sg-neut-poss-refl-pron-post := 3rd-sg-neut-poss-refl-pron & poss-reflpron-post-word.
; sine
3rd-plur-poss-refl-pron-post := 3rd-plur-poss-refl-pron & poss-reflpron-post-word.

;;;;;;;;;;;;;;;;;;;;
#|
explet-pron-word := word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD expl-pron,
    SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind & [ WH -,
                                              PNG.NG neutsg],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_expletive_rel"] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    RULE card-ok].
|#

; SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind
explet-pron-word := lbl-ltop-lex-item-2rel & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD expl-pron & [DEF +,
                                       KEYS.KEY explprn,
				       EXPLETIVE +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             PNG 3nsg ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I -,
                           REFL-II - ],
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_expletive_pron_rel",
			       ARG0 #2,
                               LBL #3],
                               expletive-q-rel & 
			        [ARG0 #2,
                                 RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok ].

#|
explet-pron-word := lbl-ltop-lex-item-3rel & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD expl-pron & [DEF +,
                                       KEYS.KEY explprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind & [ WH -,
                                             PNG 3nsg ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I -,
                           REFL-II - ],
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_expletive_pron_rel",
			       ARG0 #2,
                               LBL #3],
                                [PRED "situation-intro-rel",
				 ARG0 #2,
				 LBL #3],
                               expletive-q-rel & 
			        [ARG0 #2,
                                 RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok ].
|#


    
noun-word := word &
  [ RULE card-sensitive,
    SYNSEM.LOCAL.CAT.HEAD #3 & comm-noun & [COORDINABLE +],
    SYNSEM.LOCAL.XCAT [HEAD #3 ],
    SYNSEM.LOCAL.CAT.VAL.SPEC list,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.BIND unbnd ].

noun-word-abbrev := noun-word & const-ltow-rule &
  [ INFLECTION subst_fork ].

;; LH160214: This rule is ONLY for the POS-tagger, in order to introduce an inflectional form of a genitive noun or proper name; it works together with:  poss_wtow_noun_irule. The latter is activated ONLY in the svn version used for the POS-tagger.
noun-word-poss := noun-word & infl-wtow-rule &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

#|
sg-noun-word := noun-word.

plain-sg-noun-word := sg-noun-word & const-ltow-rule &
  [DTR noun-lexeme & [ SYNSEM.LOCAL.DERIVED-HEAD #11,
                       SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 & sg,
   SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE -,
                                 BARE - ],
   SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].
|#

bare-sg-noun-word := sg-noun-word &
  [SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 & sg,
   SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE -],
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    DTR bare-sg-noun-lexeme & [ SYNSEM.LOCAL.DERIVED-HEAD #11,
                               SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 ],
   RULE.NEEDS-CARD bool ].

; LH Sep1 With these changes, all numb, gend and definiteness information is introduced at lexeme level, and likewise NG and 'DEFINITE bool'
;sg-noun-word := noun-word.

; produced via an ltol-rule *not* introducing a quantifier: it has to combine with a specifier in order for a q_rel to get introduced


;plain-sg-noun-word := noun-word & const-ltow-rule &
;  [DTR sg-indef-noun-lxm & [ SYNSEM.LOCAL.DERIVED-HEAD #11 ],
;   SYNSEM.LOCAL.CAT.HEAD noun & [BARE - ],
;   SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
;   SYNSEM.LOCAL.DERIVED-HEAD #11,
;    RULE.NEEDS-CARD bool ].

; collapsing bare-sg-noun-word and plain-sg-noun-word into one type, namely sg-noun-word:
#|
; produced via an ltol-rule *not* introducing a quantifier
plain-sg-noun-word := noun-word & const-ltow-rule &
  [DTR sg-indef-noun-lxm & [ SYNSEM.LOCAL.DERIVED-HEAD #11 ],
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].

; produced via an ltol-rule introducing a quantifier
bare-sg-noun-word := noun-word & const-ltow-rule &
  [DTR bare-sg-noun-lexeme & [ SYNSEM.LOCAL.DERIVED-HEAD #11 ],
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].
|#

sg-noun-word := noun-word & const-ltow-rule &
  [SYNSEM.LOCAL.CAT.VAL #1,
   SYNSEM.LOCAL.DERIVED-HEAD #11,
   DTR noun-infl-lexeme & [ SYNSEM.LOCAL.CAT.VAL #1,
                            SYNSEM.LOCAL.DERIVED-HEAD #11 ],
   RULE.NEEDS-CARD bool ].



mascsg-def-noun-word := noun-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.DERIVED-HEAD #11,
    ARGS < sg-masc-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11] > ].

femsg-def-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR sg-fem-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11] ].

neutsg-def-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR sg-neut-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11]  ].

pl-def-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR plur-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11] ].

plur-indef-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     RULE #1,
     DTR pl-indef-noun-lexeme,
     DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR.RULE #1].

;this is the normal version, so no label 'infl' on it
mascpl-indef-noun-word := plur-indef-noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-pl ].

mascpl-indef-noun-const-word := noun-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-pl,
    DTR pl-indef-noun-lexeme,
    RULE #1,
    DTR.RULE #1].

fempl-indef-noun-word := plur-indef-noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem-pl ].

fempl-indef-noun-const-word := noun-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem-pl,
    DTR pl-indef-noun-lexeme,
    RULE #1,
    DTR.RULE #1].

neutpl-indef-noun-infl-word := plur-indef-noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutpl ].

neutpl-indef-noun-const-word := noun-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutpl,
    DTR pl-indef-noun-lexeme,
    RULE #1,
    DTR.RULE #1 ].



;;;;;;;;;;; VERB WORDS

; less strict XCAT-CAT relation, to allow  "g√•r fra... og blir leder": combine verb and cop
verb-word := word & lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb,
                                      INV #4,
                                      VOICE #voice],
    SYNSEM.LOCAL.XCAT [HEAD verb-all & [INV #4] ],
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E [TENSE #tense,
                                    MOOD #mood],
    SYNSEM.LOCAL.BINDING #bd,
    SYNSEM.LOCAL.HIGHEST-V-PROJ #hip+,
    SYNSEM.NON-LOCAL.SLASH #2,
    SYNSEM.VAL-CLASS #valclass,
    INFL-MORPH [TEMPUS #tense,
                MODUS #mood,
		DIATHESIS #voice],
    INFLECTED +,
    EXTRACTED-FROM -,
    DTR [ SYNSEM.NON-LOCAL.SLASH #2,
	  SYNSEM.VAL-CLASS #valclass,
          SYNSEM.LOCAL.HIGHEST-V-PROJ #hip+,
	  SYNSEM.LOCAL.BINDING #bd,
	  INFLECTED - ]].

; removed DTR verb-general-lexeme, since presentational verbs do not belong here, due to their extra EPs
    
inf-verb-word := verb-word & const-ltow-rule &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT.HEAD [VOICE active,
                           IMPERATIVE -,
                           DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ].

;LH191215 Has to be worked on a lot. For 'Ola ligger og sover' it generates i.a. 'Ola ligger og soving' and 'Ola ligger og ing'. nominalized_ing_infl_rule has been commented out.
nominalized-ing-verb-word := verb-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD [VOICE active,
                           IMPERATIVE -,
                           DECL +,
			   MAIN-CL -],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active,
					  KEYS.KEY mainvb ]].



imp-verb-word := verb-word & rule &
  [ DTR imperative-verb-lexeme,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imperative,
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE +].

infl-imp-verb-word := imp-verb-word & infl-ltow-rule.

const-imp-verb-word := imp-verb-word & const-ltow-rule.

infl-ltow-verb-word := verb-word & infl-ltow-rule.
const-ltow-verb-word := verb-word & const-ltow-rule.

indicative-verb-word := verb-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE - ].

pres-verb-word := indicative-verb-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pres,
  DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active  ].

infl-pres-verb-word := infl-ltow-verb-word & pres-verb-word.
const-pres-verb-word := const-ltow-verb-word & pres-verb-word.

pret-verb-word := indicative-verb-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pret,
  DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active ].

infl-pret-verb-word := infl-ltow-verb-word & pret-verb-word.
const-pret-verb-word := const-ltow-verb-word & pret-verb-word.

; so far, this covers both active and passive - participle-pass-word below not activated yet
perf-part-verb-word := indicative-verb-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    SYNSEM.LOCAL.CAT.HEAD.VOICE #1,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE #1 ].

infl-perf-part-verb-word := infl-ltow-verb-word & perf-part-verb-word.
const-perf-part-verb-word := const-ltow-verb-word & perf-part-verb-word.


s-pass-word := indicative-verb-word & infl-ltow-verb-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.VOICE s-pass,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE s-pass-tenses, ; can be used in infinitive, and past tense
    DTR.SYNSEM.LOCAL.CAN-PASSIVIZE +,
    DTR [SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive ]]]]]].

participle-pass-word := indicative-verb-word & infl-ltow-verb-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.VOICE ptc-pass,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    DTR [SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive ]]]]]].
#|
participle-pass-word := indicative-verb-word & infl-ltow-verb-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.VOICE ptc-pass,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    DTR passive-lexeme ].
|#

;interjection-word := verb-word & const-ltow-rule & rule &
;  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY interjct ], 
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD hortative].

#|
interjection-word := word & rule & lbl-ltop-lex-item & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD interjection & [KEYS.KEY interjct,
				      INTERJECT +,
				      MOD <[LOCAL.CONT.HOOK.INDEX #1]>],
   SYNSEM.LOCAL.CAT.VAL.COMPS <>,
;   SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   SYNSEM.LOCAL.CAT.VAL.SPR <>,
   SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LKEYS.KEYREL.ARG1 #1,
;    SYNSEM.NON-LOCAL.SLASH <! !>,
   SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

; This is simply the ROOT definition, and will only work for individual words, not things like "ja, takk". Can be later activated (the rules are there).LH080718
interjection-word := phrase &
[ SYNSEM.LOCAL.CAT [ HEAD verb-all & [ MAIN-CL + ],
                     VAL [ SUBJ < anti-synsem >,
                           SPR null,
                           SPEC null,
                           COMPS null,
                           ICOMPS null] ],
  SYNSEM.LOCAL.NEED-IMP-UNARY -,
  SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
  SYNSEM.LOCAL.BND-RESP <>,  ;;LH020216 Refl binding is now a bit out of control, so temporarily suspending these constraints. See head-verb-tame-comp-phrase and trans-arg1-2refl-synsem.
  SYNSEM.LOCAL.WAIT-BND-RESP <>,
  SYNSEM.LOCAL.MUST-COORD-PROJECT -,
  SYNSEM.LOCAL.NEED-Q-MARK -, ;; MHS 120713 This line only has effect in the mal-grammar.
;  SYNSEM.LOCAL.IS-A-COMPLEMENT -, ;; MHS 120713 Experimenting with using this type to reduce spurious parses that arise in main clause extraction.
;  SYNSEM.NON-LOCAL [ SLASH 0-dlist & [ LIST < >],;
;		     REL 0-dlist & [ LIST < >],
;		     QUE 0-dlist & [ LIST < >] ],
SYNSEM.LOCAL.CONT.RELS <! !>,
SYNSEM.LOCAL.CONT.HCONS <! !>,
INFLECTED +,
  FRONT-TO-FILL -,
  EXTRACTED-FROM -].


;;;; COMPLEMENTIZERS

; 1arg-1comps & ;; MHS 080713

basic-compl := word & const-ltow-rule & 
  [SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
   SYNSEM.LOCAL.CAT.VAL.COMPS < #1 & [LOCAL.CONT.HOOK.INDEX.E.TENSE #2 & tense ]>,
   SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #2,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
   SYNSEM.LOCAL.AGR.PNG.NG neutsg,
   SYNSEM.LEX + ].


inf-comp := basic-compl &
  [ SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
                                         DECL +,
                                         KEYS.KEY infinit-comp-eq,
					 MODALITY #mod ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL.SUBJ < synsem >,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],    
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CAT.HEAD.MODALITY #mod,
                                   LOCAL.CONT.HOOK.LTOP #4,
                                   LOCAL.CONT.HOOK.XARG #1 ]>, 
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [PRED "_inf-mark_rel",
					      LBL #3,
                                              ARG1 #4 ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

;;;;;;;;;

inf-arbref-comp := basic-compl &
  [ SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
                                         DECL +,
                                         KEYS.KEY infinit-comp-arb ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #ind & ref-ind & [PNG.PERS thirdpers]] >,
                                   LOCAL.CAT.HEAD.MAIN-CL -,    
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>, 
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [PRED "_inf-mark_rel",
					      LBL #3,
                                              ARG1 #4],
			   indef-q-rel & [PRED "_udef_q_rel",
					    ARG0 #ind,
					    RSTR #rstr], [ PRED "_pron_rel",
							   LBL #lbl,
							   ARG0 #ind ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! [HARG #rstr,
			       LARG #lbl] !> ].



; a preposition - "...for √• .." (rais), with feature transportation from V velow to V above as main purpose
; KEYS.KEY predcomp-inf,
;                                        SELECTED +,

for-comp := basic-compl &
  [ SYNSEM.LOCAL.CAT.HEAD for-cmp & [ DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.TRANSPAR +,
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CONT.HOOK.XARG #1 ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

;;;  DPF 020411

; & 1arg-1comp & ;; MHS 080713 To be commented in after treebanking.


;LOCAL.CAT.HEAD adj,  for COMPS  clashes with 'clse' below
;
som-adj-pred-comp := 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-adj,
					MOD <>], ; MOD <> to prevent 'bilen som ny' analyzed as NP in Hun oppfattet bilen som ny
    SYNSEM.LOCAL.CAT.VAL.COMPS < #5 & [ LOCAL.CAT.VAL.SUBJ list, ;antilist,
                                        LOCAL.CONT.HOOK.LTOP #3,
                                        LOCAL.MAL-INFLECT-LEEWAY +,
					LOCAL.CONT.HOOK.XARG #1 ]>, 
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [PRED "_som_eq_rel",
					       ARG1 #3] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].


som-derivedadj-pred-comp := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule & 

  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-adj,
					MOD <> ],  ; MOD <> to prevent 'bilen som ny' analyzed as NP in Hun oppfattet bilen som ny
    SYNSEM.LOCAL.CAT.VAL.COMPS < #5 & [ LOCAL.CAT.VAL.SUBJ antilist,
                                        LOCAL.CONT.HOOK.LTOP #3,
                                        LOCAL.CONT.HOOK.XARG #1, 
					LOCAL.DERIVED-HEAD + ]>, 
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [PRED "_som_eq_rel",
					       ARG1 #3] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

#|
som-adj-pred-comp := word &
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-adj ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #5 & [ LOCAL.CAT.VAL.SUBJ olist,
                                        LOCAL.CONT.HOOK.LTOP #3,
                                        LOCAL.CONT.HOOK.XARG #1 ]>, 
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_som_eq_rel"] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#


som-adj-pred-pp-comp := som-adj-pred-comp &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj-reg ]> ].

;som-derivedadj-pred-pp-comp := som-derivedadj-pred-comp.
; &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj ]> ].

som-adj-pred-clse-comp := som-adj-pred-comp &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD verb-all ]> ].

; 1arg-1comp & ;; MHS 080713
som-n-pred-comp := word & 1arg-1comps & lbl-ltop-lex-item & const-ltow-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n,
					MOD <>], ;"opptreden som" should be ok, but then restrict the MOD value to this kind of noun.
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ <>,    
                                   LOCAL.CAT.HEAD noun,
                                   LOCAL.CONT.HOOK.INDEX #5, 
				   LOCAL.DERIVED-HEAD - ]>, ; , LOCAL.DERIVED-HEAD -
   SYNSEM.LOCAL.CONT.HOOK.XARG #1, ; & ref-ind,   
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [ PRED "_instantiate_c_rel",
			       LBL #3,
			       ARG0 #8,
			       ARG1 #1,
			       ARG2 #5 ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].


#|
som-n-pred-comp := word &
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ <>,    
                                   LOCAL.CAT.HEAD noun,
                                   LOCAL.CONT.HOOK.INDEX #5,
                                   LOCAL.DERIVED-HEAD - ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,   
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [ PRED "_instantiate_c_rel",
			       LBL #3,
			       ARG0 #8,
			       ARG1 #1 & [ PNG.NG.NUM #num ],
			       ARG2 #5 & [ PNG.NG.NUM #num ] ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

pre-subord-comp :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD glob-comp & [ TRANSPAR -,
                                       KEYS.KEY pre-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD glob-comp & [ TRANSPAR - ],
				   LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CAT.HEAD.IMPERATIVE -,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                              ARG1 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].


; 'semarg' from '#4'
subord-comp :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR -,
                                       KEYS.KEY finit-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CAT.HEAD.IMPERATIVE -,
                                   LOCAL.CAT.HEAD.WH-COMPLETE -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP semarg,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL semarg,
                                              ARG1 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].

; 'semarg' from '#4'
subord-maincl-comp :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR -,
                                       KEYS.KEY finit-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL +,
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CAT.HEAD.IMPERATIVE -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP semarg ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                              ARG1 semarg] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].

decl-subord-comp := subord-comp &
  [ SYNSEM.LOCAL.CAT.HEAD.DECL +,
    SYNSEM.LOCAL.CAT.HEAD.CONDITIONAL -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL +,
				   LOCAL.CAT.HEAD.INV -,
				   LOCAL.CONT.HOOK.INDEX.SF prop ] >].

y-n-quest-subord-comp := subord-comp &
  [ SYNSEM.LOCAL.CAT.HEAD.DECL -,
    SYNSEM.LOCAL.CAT.HEAD.CONDITIONAL -,
    SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE +].

#|
LH180718
,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL bool, ;; from '-'
				   LOCAL.CAT.HEAD.WH-COMPLETE -,
				   LOCAL.CONT.HOOK.INDEX.SF iforce] >]. ;; from 'ques'
|#

subord-colon :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR -,
                                       KEYS.KEY finit-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL +,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [PRED "subord-colon_rel",
					      LBL #3,
                                              ARG1 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].

#|

interjection-lexeme := lexeme & lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY interjct ],
    SYNSEM.LOCAL.CAT [VAL [ SUBJ antilist,
                            SPR < >,
                            SPEC <>,
                            COMPS <>,
                            ICOMPS <> ]], 
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD hortative,
    SYNSEM.LOCAL.CONT.RELS <! arg0-relation !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>, 
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND unbnd ].
|#


 ;  LEXEME TYPES

top-verb-lexeme := lexeme.

; lexeme, inheriting from norm-lex-item, allows for many rels; verb-lexeme,
; by assumption, only one

verb-general-lexeme := top-verb-lexeme & lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LKEYS #4,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.XLEXKEYS #4,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HAS-WH-MOVED -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,				;; Added to avoid s-final. EAA030811
    SYNSEM.BIND unbnd ].

verb-lexeme := verb-general-lexeme &
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb],
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE bool] > ]]].

;abandoned
gapping-serial-verb-lexeme := verb-general-lexeme &
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
				   INV +,
                                   KEYS.KEY gapping-conj,
				   MOD < [LOCAL.CAT.QVAL #1 & qval-valence, ;trans-qval-sup,
					  LOCAL.CAT.HEAD verb-all,
					  LOCAL.CONT.HOOK.XLEXKEYS.KEYREL.PRED #2] >],
    SYNSEM.LOCAL.CAT.QVAL #1,
    SYNSEM.LKEYS.KEYREL.PRED #2,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED +,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED +,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    SYNSEM.LOCAL.WH-ISLAND +,
    EXTRACTED-FROM bool ]. ; -

;works with 'petko' for 'og', when gaping rules are activated. Fails for the semantics.LH041021
gapping-conjunction := word & lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT.HEAD word-coord  & [MOD < [LOCAL.CAT.QVAL #qval & qval-valence,
;						LOCAL.CAT.VAL #val,
;						LKEYS.KEYREL #keyrel & relation,
						LOCAL.CAT.HEAD verb-all,
;						LOCAL.CONT.RELS.LIST.FIRST #keyrel,
						LOCAL.CONT.HOOK.XLEXKEYS.KEYREL.PRED #2] >],
    SYNSEM.LOCAL.CAT.QVAL #qval,
;    SYNSEM.LOCAL.CAT.VAL #val,
;    SYNSEM.LKEYS.KEYREL #keyrel,
    SYNSEM.LKEYS.KEYREL.PRED #2,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED +,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED +,
;    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LKEYS #4,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.XLEXKEYS #4,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.GAPPING +,
    SYNSEM.LOCAL.HAS-WH-MOVED -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,
    SYNSEM.LOCAL.GAPPING +,				
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.BIND unbnd ]. ;, SYNSEM.BIND unbnd



;,
;    SYNSEM.LOCAL.CAT trans-qval-sup
;    SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>,
;    SYNSEM.LOCAL.CAT.VAL.COMPS <[]>
				    
;;; FOR LEXICAL ENTRIES

;skje, inntreffe
intrans-arg1-result-verb-lexeme := verb-general-lexeme &
[ SYNSEM intrans-arg1-synsem,
  EXTRACTED-FROM -,
  SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
				 KEYS.KEY resultvb],
  SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE bool] > ]]  ].

; sove, starte, sove, revne, st√•
intrans-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1-synsem,
  EXTRACTED-FROM -  ].

; g√•, l√∏pe, hoppe
intrans-arg1dir-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1dir-synsem ].

;vare fra... til...
intrans-arg1dir-temp-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1dir-temp-synsem ].

; added 'sup' 31.03.09, to harmonize with Univcode
intrans-obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-n-synsem,
  EXTRACTED-FROM -  ].

intrans-locobl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-locobl-synsem,
  EXTRACTED-FROM -  ].

; added 'sup' 31.03.09, to harmonize with Univcode
intrans-2obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-2obl-synsem-sup,
  EXTRACTED-FROM -  ].

; "se alvorlig p√•"
intrans-adv-obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-adv-obl-synsem ].

intrans-obl-sup-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-synsem-sup ].

intrans-obl-n-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-n-synsem ].

intrans-obl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-decl-synsem ].

; intended for same coverage as intrans-indirwhquest-pp-verb-lexeme - has PP as ICOMPS, while the other has it as COMPS
intrans-obl-interr-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-interr-synsem ].

; intended for same coverage as intrans-obl-interr-verb-lexeme - has PP as COMPS, while the other has it as ICOMPS
intrans-indirwhquest-pp-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-indirwhquest-pp-synsem ].

; only in semlab lex
intrans-obl-arbinf-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-arbinf-synsem ].

; spise p√•, gnage p√•
intrans-atel-obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-atel-obl-synsem ].

; no phrasal rule going with this yet. only 4 items.
; fungere, dufte
intrans-obladv-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obladv-synsem ].

intrans-obl-refl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-refl-synsem ].

intrans-eventarg1-decl-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-decl-synsem  ].

intrans-eventarg1-interr-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-interr-synsem ].

intrans-eventarg1-absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-absinf-synsem  ].

intrans-eventarg1-decl-obl-n-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-decl-obl-n-synsem ].
intrans-eventarg1-interr-obl-n-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-interr-obl-n-synsem ].
intrans-eventarg1-absinf-obl-n-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-absinf-obl-n-synsem ].

intrans-eventarg1decl-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1decl-eventobldecl-synsem ].
intrans-eventarg1decl-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1decl-eventoblinterr-synsem ].
intrans-eventarg1interr-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1interr-eventobldecl-synsem ]. 
intrans-eventarg1interr-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1interr-eventoblinterr-synsem ]. 




; for "han stiller som reserve"
intrans-secpred-som-arg1-x-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-secpred-som-arg1-x-synsem ].

;"at han kommer teller som en suksess"
; not used after all, reduplicates other type
;intrans-secpred-som-eventarg1-x-verb-lexeme := verb-lexeme &
;  [ SYNSEM intrans-secpred-som-eventarg1-x-synsem ].

intrans-eventarg1-secpred-som-arg1-x-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-eventarg1-secpred-som-arg1-x-synsem ].

; perhaps useful
intrans-rais-from-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-rais-from-pp-arg1-synsem ].

intrans-decl-in-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-decl-in-pp-arg1-synsem ].

intrans-interr-in-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-interr-in-pp-arg1-synsem ].

intrans-absinf-in-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-absinf-in-pp-arg1-synsem ].

;;
trans-decl-in-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM trans-decl-in-pp-arg1-synsem ].

trans-interr-in-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM trans-interr-in-pp-arg1-synsem ].

trans-absinf-in-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM trans-absinf-in-pp-arg1-synsem ].

;;

trans-rais-from-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM trans-rais-from-pp-arg1-synsem ].

; new generation type - see lex-types-v.tdl
;v-intrOblEpon := verb-lexeme &
;  [ SYNSEM intrans-epon-with-pp-arg1-synsem ].

v-intrPrtclOblEpon-oblEponDECL := verb-lexeme &
  [ SYNSEM intrans-adv-epon-with-pp-arg1-synsem ].
;v-intrPrtclOblEpon-subjExpl_oblEponDECL := verb-lexeme &
;  [ SYNSEM intrans-adv-epon-with-pp-arg1-synsem ].

; forefalle_2, virke, synes, vedbli
intrans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-general-lexeme &
[ SYNSEM intrans-secpred-rais-from-nonverbal-arg1-synsem ].

; forefalle_2, virke, synes, vedbli - som (om) S
intrans-secpred-rais-from-som-clause-arg1-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-rais-from-som-clause-arg1-synsem ].



; forefalle_2, virke, synes, vedbli
epon-intrans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-2rel-lexeme &
[ SYNSEM epon-intrans-secpred-rais-from-nonverbal-arg1-synsem ].

; TODO - LH300712 not yet working
; forefalle_2, virke, synes, vedbli
epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-3rel-lexeme &
[ SYNSEM epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-synsem ].

; "se syk ut" - ut_6 := adv-particle-word
intrans-secpred-prtcl1-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-prtcl1-rais-from-nonverbal-arg1-synsem ].

intrans-secpred-prtcl1a-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem ].

trans-secpred-prtcl1a-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem ].

; "se ut til √• komme" - ut_6 := adv-particle-word; til_11 := prep-rais-word;
; 'non-verbal' because
; the infinitive marker "√•" ('inf-comp') heads a non-verbal projection
; flawed
intrans-secpred-prtcl2-rais-from-nonverbal-arg1-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-prtcl2-rais-from-nonverbal-arg1-synsem ].
; only in semlab, with type v-intrAdvOblRais-subjNonarg_oblRaisInf-thSitObl-EXHIBACT
intrans-adv-rais-from-pp-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-adv-rais-from-pp-arg1-synsem ].

; se ut som. se ut som om
intrans-secpred-prtcl3-rais-from-nonverbal-arg1-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-prtcl3-rais-from-nonverbal-arg1-synsem ].

intrans-secpred-argx-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-argx-synsem ].

; koke_intr-sec
intrans-secpred-argcsx-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-argcsx-synsem ].

;intrans-secpred-adj-argx-verb-lexeme := verb-lexeme &
;[ SYNSEM intrans-secpred-adj-argx-synsem ].
;intrans-secpred-pp-argx-verb-lexeme := verb-lexeme &
;[ SYNSEM intrans-secpred-pp-argx-synsem ].

intrans-secpred-arg1-csx-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-arg1-csx-synsem ].

; lade opp, bule ut, ese opp - 
intrans-telicparticle-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-telicparticle-arg1-synsem ].

; no lex-item using this - they all are subtypes - the one above, and underneath
intrans-aspectualparticle-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-telicity-particle-arg1-synsem ].

; holde p√•, drive p√•: it enforces atelicity for the whole constr.
intrans-atelicparticle-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-atelicparticle-arg1-synsem ].

; drive (og g√•)
; for "drive" in "driver og g√•r": it enforces atelicity for the whole constr.
intrans-arg1-atelic-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1-atelic-synsem ].

; flawed
; for "drive/holde" in "driver/holder p√• med √•": it enforces atelicity for the whole constr.
;subj-prtcl-equi-pp-atelic-verb-lexeme := verb-lexeme &
;[ SYNSEM subj-prtcl-equi-pp-atelic-synsem ].
; ok:
subj-prtcl-equi-pp-atelic-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-adv-equinf-synsem ].

intrans-secpred-rais-from-verbal-arg1-verb-lexeme-sup := verb-general-lexeme &
  [ SYNSEM intrans-secpred-rais-from-verbal-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; forefalle, , "forefalle komme"
intrans-secpred-rais-from-verbal-arg1-verb-lexeme := intrans-secpred-rais-from-verbal-arg1-verb-lexeme-sup & verb-lexeme.

; forefalle_3, vedbli "forefalle √• komme"
intrans-secpred-rais-from-infinmarked-arg1-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-secpred-rais-from-infinmarked-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; for inheritance
aux-verb-lexeme := verb-general-lexeme & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-aux & [ KEYS.KEY auxvb ],
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; ville, m√•tte, kunne, burde, skulle
epistemic-modal-verb-lexeme := intrans-secpred-rais-from-verbal-arg1-verb-lexeme-sup & aux-verb-lexeme.

; "ha, bli" - for inheritance
intrans-secpred-rais-from-perfect-verbal-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-secpred-rais-from-perfect-verbal-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; ha, f√•
aux-perf-verb-lexeme := intrans-secpred-rais-from-perfect-verbal-arg1-verb-lexeme & aux-verb-lexeme &
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VOICE active ] >].

; bli (passive)
aux-pass-verb-lexeme := intrans-secpred-rais-from-perfect-verbal-arg1-verb-lexeme & aux-verb-lexeme &
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VOICE ptc-pass ] >].

; pr√∏ve, fors√∏ke
subj-equi-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-synsem ].

; finne p√• √•
subj-equi-particle-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-particle-synsem ].

; for inheritance
subj-equi-bare-verb-lexeme := verb-general-lexeme &
  [ SYNSEM subj-equi-bare-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; ville, m√•tte, kunne, burde, skulle
root-modal-verb-lexeme := subj-equi-bare-verb-lexeme & aux-verb-lexeme.

; flawed
; "be om √• komme"; "snakke om √• komme"
;subj-equi-pp-verb-lexeme := verb-lexeme &
;[ SYNSEM subj-equi-pp-synsem ].
; "be om √• komme"; "snakke om √• komme"

; ok:
subj-equi-pp-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-equinf-synsem ].

; "drive med √• komme"
subj-equi-pp-atelic-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-pp-atelic-synsem ].

; se_2, treffe, lage, fort√¶re
; cannot really maintain that all objects be referential-thing - will block "fort√¶re en sekk med poteter", for instance
;trans-arg1-2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-arg1-2-synsem & [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
;                                                           OPT - ] >]] ].

trans-arg1-2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2-synsem & [ LOCAL.CAT.VAL [ COMPS <[ ]>]] ].

; MUST MAKE A COMMON EXCL SUPERTYPE OF INHER-COMPL AND referential-thing,
; to make head-verb-comp-phrase subsume this type
;trans-arg1-2inh-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-arg1-2-synsem-sup & [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT inher-compl ] >]] ].
; but making things simpler right now:
trans-arg1-2inh-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2-synsem-sup &
	 [LOCAL.CONT.HOOK hook,
	  LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX.WH -,
				LOCAL.BINDING.LEX-TAME -]>]]. ; one cannot ask 'hvilken d√∏d d√∏de han'. 'hvilket l√∏p l√∏p han' is ok, so 'l√∏pe' is plain transitive.

; vaske
trans-arg1-2refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2refl-synsem & [ LOCAL.CAT.VAL [ COMPS <[ ]>]] ].

; COMPS <[LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
; legge, skyte, kaste, sl√•, heade, sparke, spille, miste, slepe
trans-arg1-2dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2dir-synsem & [LOCAL [ CAT.VAL [SUBJ <[ ] >,
                                            COMPS <[ ]>]]] ].



; basere NP p√•, fortelle tull om - not discrim the governee of prep
trans-obl-sup-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-synsem-sup ].


; basere NP p√•, fortelle tull om
trans-obl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-n-synsem ].

trans-obl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-decl-synsem ].

trans-obl-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-interr-synsem ].

trans-obl-absinf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-absinf-synsem ].

; basere seg p√• - not discriminating about the governee of the prep
trans-refl-obl-sup-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-synsem-sup ].

; basere seg p√•
trans-refl-obl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-synsem ].

trans-refl-obl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-decl-synsem ].

trans-refl-obl-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-interr-synsem ].

trans-refl-obl-absinf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-absinf-synsem ].

; "vedde 2 kroner med Marit p√• at..."
trans-2obl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-2obl-synsem ].

; "lagre kisten i skogen"
trans-locobl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-locobl-synsem ].

; "oppholde seg i skogen"
trans-refl-locobl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-locobl-synsem ].

; no phrasal rule going with this yet. only 1 item: tilrede.
trans-obladv-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obladv-synsem ].

trans-refl-obladv-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obladv-synsem ].

trans-obl-n-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-n-synsem ].




trans-dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-dir-synsem ].

trans-refl-dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-dir-synsem ].

; for "treffe Jon i hodet": 'the head is possessed by Jon', thus #3 is the head ; and #1 is Jon. Also, for: "(?) kaste Jon n√∏tter i hodet"
; removed: 'LOCAL.CAT.HEAD.KEYS.KEY detch,' from the ICOMPS - the
; prep is quite freely selected, actually
                               
; this type is made for the types trans-pp-arg1-detached-poss-synsem-sup and ditrans-pp-arg1-2-detached-poss-synsem. The intransitive version, almost identical apart from a non-empty COMPS, is intrans-pp-detached-poss-synsem.
detached-possessor-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL [ CONT.HOOK.INDEX #1 ] ], ... >,
                    ICOMPS < [ LOCAL.CONT.HOOK.VARG #3,
                               LOCAL.CONT.HOOK.LTOP #2,
                               LOCAL.CAT.HEAD.KEYS.KEY detch ] > ],
    LOCAL.CAT.VAL.ICOMPS < #4, ...>,
    LOCAL.CAT.QVAL with-obl-pp-qval & [ OBL1 #4 & [ LOCAL.CAT [ HEAD prep,
								VAL.COMPS null ] ] ],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel,
    LKEYS [ ALTKEYREL #altkey & poss-rel &
                  [ ARG1 #1,
                    ARG2 #3 ],
            KEYREL #key & [ARGOBLQ #2] ],
    LOCAL.CONT.RELS <! #key, #altkey !> ].


;;   "Kari skrubber Jon p√• ryggen" (adv11) - two options:
; in this, Kari is what is 'on'

#|
trans-pp-arg1-detached-poss-synsem := detached-possessor-synsem &
  [ LOCAL.CAT trans-with-1icomps-pp-cat & [VAL.ICOMPS <[LOCAL.CONT.HOOK.VARG #5]>,
                                            VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #4],
    LKEYS [ ALTKEYREL [ ARG1 #4 ],
            KEYREL [ ARG1 #5 ] ] ].
|#

; ; in this, the event as such is what is 'on' - probably 
intrans-pp-detached-poss-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #1 ] ], ... >,
                    ICOMPS < [ LOCAL.CONT.HOOK.VARG #3,
                               LOCAL.CONT.HOOK.LTOP #2,
                               LOCAL.CAT.HEAD.KEYS.KEY detch ] > ],
    LOCAL.CAT.VAL.ICOMPS < #4, ...>,
    LOCAL.CAT.QVAL with-obl-pp-qval & [ OBL1 #4 & [ LOCAL.CAT [ HEAD prep-or-adv,
								VAL.COMPS null ] ] ],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel,
    LKEYS [ ALTKEYREL #altkey & poss-rel &
                  [ LBL #5,
		    ARG1 #1,
                    ARG2 #3 ],
            KEYREL #key & [LBL #5,
			   ARGOBLQ #2]],
    LOCAL.CONT.RELS <! #key, #altkey !>].



; the least controversial
trans-pp-arg1-detached-poss-synsem-sup := detached-possessor-synsem &
  [ LOCAL.CAT trans-with-1icomps-pp-cat & [VAL.ICOMPS <[LOCAL.CONT.HOOK.XARG #5]>,
                                            VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #4],
    LKEYS [ ALTKEYREL [ ARG1 #4 ],
            KEYREL [ ARG0 #5,
		     ARG2 #4] ] ].

trans-pp-arg1-detached-poss-synsem := trans-pp-arg1-detached-poss-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

trans-pp-arg1-detached-poss-refl-synsem := trans-pp-arg1-detached-poss-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2 ] >,
    LOCAL.CAN-PASSIVIZE -].



;;   "Jon kyler Kari en sn√∏ball i ryggen" (adv10)
ditrans-pp-arg1-2-detached-poss-synsem := detached-possessor-synsem &
  [ LOCAL.CAT ditrans-with-icomps-pp-cat & [VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #4,
                                            VAL.COMPS.REST.FIRST.LOCAL.CONT.HOOK.INDEX #5],
    LKEYS [ ALTKEYREL [ ARG1 #4 ],
            KEYREL [ ARG2 #5 ] ]].

; has only one subtype
verb-2rel-lexeme-sup := top-verb-lexeme & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd ].

verb-2rel-lexeme-straight := verb-2rel-lexeme-sup & lbl-ltop-lex-item-2rel.
verb-2rel-lexeme := lbl-ltop-lex-item-2rel-lbltweak & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd,
    INFLECTED -].

verb-2rel-arg12a-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a.

verb-2rel-arg12a1-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a1.
verb-2rel-arg12a12-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a12.
verb-2rel-arg12aObl-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12aObl.
verb-2rel-arg12a1Obl-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a1Obl.
verb-2rel-arg12a12Obl-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a12Obl.
verb-2rel-arg12ax-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12ax.
verb-2rel-arg12a1x-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a1x.
verb-2rel-arg12a12x-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a12x.

verb-3rel-lexeme := lbl-ltop-lex-item-3rel & lexeme &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd ].


;;   "Kari fryser p√• ryggen"
intrans-pp-detached-poss-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM intrans-pp-detached-poss-synsem ].

;;   "Kari skrubber Jon p√• ryggen" (adv11)
trans-pp-arg1-detached-poss-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM trans-pp-arg1-detached-poss-synsem ].

;;   "Kari kl√∏r seg p√• ryggen" (adv11)
trans-pp-arg1-detached-poss-refl-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM trans-pp-arg1-detached-poss-refl-synsem ].

;;   "Jon kyler Kari en sn√∏ball i ryggen" (adv10)
ditrans-pp-arg1-2-detached-poss-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM ditrans-pp-arg1-2-detached-poss-synsem ].


; love
subj-equi-doublobj-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-doublobj-synsem ].

; tillate
obj-equi-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-synsem ].

obj-equi-refl-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-refl-synsem ].

trans-obl-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-inf-synsem ].

; be
obj-equi-bare-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-bare-synsem ].

; oppfordre
obj-equi-pp-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-pp-synsem ].
; forplikte seg til
obj-equi-pp-refl-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-pp-refl-synsem ].

; "overlate til Ola √•..." - job done by trans-obl + head-actv-verb-icomp-epon-phrase
;obl-equi-verb-lexeme := verb-lexeme &
;[ SYNSEM obl-equi-synsem ].

; se_5 "se ham komme"

; han f√∏ler seg komme
trans-secpred-rais-refl-from-verbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-verbal-arg2-synsem ].

trans-secpred-rais-from-verbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-verbal-arg2-synsem ].

; "han viser seg √• komme"
trans-secpred-rais-refl-tosubj-from-infinmarked-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-tosubj-from-infinmarked-arg1-synsem ].

; "han lar seg se"
;la-seg-se-verb-lexeme := lexeme & lbl-ltop-lex-item-3rel &
la-seg-se-verb-lexeme := verb-lexeme &
[ SYNSEM la-seg-se-synsem ].

la-sangen-synge-verb-lexeme := verb-lexeme &
[ SYNSEM la-sangen-synge-synsem ].

; fortone seg syk
trans-secpred-refl-argx-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-refl-argx-synsem ].

trans-secpred-refl-argx-verb-lexeme :+
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD pers-pron ]. ;; MHS 090813 To block unwanted bare finite structures from arising in sentences such as 'han fortoner seg syk'.

; "han synes meg √• komme", "han forekommer meg √• komme"
trans-secpred-rais-from-infinmarked-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-infinmarked-arg1-synsem ].

; for "jeg forutsetter ham √• komme", with pass: "han forutsettes √• komme"
trans-secpred-rais-from-infinmarked-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-infinmarked-arg2-synsem ].

; for "jeg forutsetter ham skutt", with pass: "han forutsettes skutt" - Complex Passive
trans-secpred-rais-from-perfmarked-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-perfmarked-arg2-synsem ].

; han synes meg syk
trans-secpred-rais-from-adj-or-som-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-adj-or-som-arg1-synsem ].

; anse (for/som)
;trans-secpred-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-synsem ].

trans-secpred-lexcause-pp-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-lexcause-pp-synsem ].
trans-secpred-refl-lexcause-pp-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-refl-lexcause-pp-synsem ].

trans-secpred-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CONT.HOOK.INDEX semarg]>]]. ;ad-event

;;;; BEGINNING OF NEW TYPE

trans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg1-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CONT.HOOK.INDEX semarg]>]]. ;ad-event

trans-secpred-rais-from-nonverbal-arg1-plain-synsem := trans-secpred-rais-from-nonverbal-arg1-synsem-sap &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].

trans-secpred-rais-from-nonverbal-arg1-synsem-sap := trans-secpred-rais-from-nonverbal-arg1-synsem-super.

trans-secpred-rais-from-nonverbal-arg1-synsem-super := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #6,
                            LOCAL.CAT.HEAD nominal], 
                          [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adj-or-adv,
			    LOCAL.CONT.HOOK.LTOP #3 ] >, 
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL [ARG1 #3,
                  ARG2 #6 ]].

;see lex-types_v
;v-trScprArg1-scObNrg_scPredprtclSom := trans-secpred-rais-from-nonverbal-arg1-verb-lexeme.

;;;; END OF NEW TYPE

trans-secpred-som-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-som,
                                      LOCAL.CONT.HOOK.INDEX semarg]>]].;ad-event

trans-secpred-for-rais-from-nonverbal-arg2-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-inf-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY pcl ]>]].;for-rais
trans-secpred-for-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-for ]>]].

trans-secpred-til-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-til ]>]].
trans-secpred-til-rais-from-nonverbal-arg2-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-inf-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY til-rais ]>]].


; han synes en idiot
intrans-secpred-rais-from-n-arg1-verb-lexeme := top-verb-lexeme &
[ SYNSEM intrans-secpred-rais-from-n-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [] >,
			    SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.BIND unbnd].


; han synes meg en idiot
trans-secpred-rais-from-n-arg1-verb-lexeme := top-verb-lexeme &
[ SYNSEM trans-secpred-rais-from-n-arg1-synsem,
  SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.BIND unbnd].

; anse seg (som) syk
;trans-secpred-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-synsem ].


trans-secpred-adj-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD adj-reg ]>]].

trans-secpred-som-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-som ]>]].

trans-secpred-til-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-til ]>]].

trans-secpred-for-rais-refl-from-nonverbal-arg2-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-inf-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY pcl ]>]].;for-rais
trans-secpred-for-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predsort ]>]].;for-rais

; like any other verb, except that it lexically has two relations, the one extra for introducing the 'instantiate' EP reflecting the nominal predicative
; ,
;    SYNSEM.LKEYS.KEYREL.ARG0 #11,
;    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11
trans-secpred-rais-from-nominal-arg2-verb-lexeme := top-verb-lexeme & lbl-ltop-lex-item-openarg0-2rel &
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                 KEYS.KEY mainvb],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd,
    SYNSEM trans-secpred-rais-from-nominal-arg2-synsem  ].

; kalle seg en tosk
; ,
;    SYNSEM.LKEYS.KEYREL.ARG0 #11,
;    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11
trans-secpred-rais-refl-from-nominal-arg2-verb-lexeme := top-verb-lexeme & lbl-ltop-lex-item-openarg0-2rel & 
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                 KEYS.KEY mainvb],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd,
    SYNSEM trans-secpred-rais-refl-from-nominal-arg2-synsem ].

; kalle ham en venn
;trans-secpred-rais-from-nominal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-from-nominal-arg2-synsem ].

; kalle seg en tosk
;trans-secpred-rais-refl-from-nominal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-refl-from-nominal-arg2-synsem ].


; hoppe_3
trans-secpred-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD prep-or-adj-or-adv ]>]]].

;LH may7-11
trans-secpred-shift-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-shift-arg1-x-synsem & 
         [LOCAL.CAT.VAL [COMPS < [ LOCAL.CAT.HEAD prep-or-adj-or-adv ], [] >]]].

;LH 27202020
;trans-secpred-super-arg1-x-verb-lexeme := verb-lexeme &
;[ SYNSEM.LOCAL.CAT trans-secpred-cat ].

;LH 27202020
;trans-particle-arg1-x-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-particle-arg1-x-synsem-sup &
;         [LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY pcl] ]].

trans-secpred-arg1-x-refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-refl-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD prep-or-adj-or-adv]>]] ].

; there are 425 of these in lex.large-v.tdl - "fiffe seg opp"
trans-telicparticle-arg1-x-refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-refl-synsem & 
         [LOCAL.CAN-PASSIVIZE -,
	  LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl ],
                                   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
                                   LOCAL.CONT.HOOK.XARG #1,
                                   LKEYS.KEYREL.ARG1 #1] >]] ].

trans-telicparticle-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl ],
                                   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
                                   LOCAL.CONT.HOOK.XARG #1,
                                   LKEYS.KEYREL.ARG1 #1] >]] ].

; LH 280411
trans-telicparticle-shift-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particleshift-non-dir-synsem & 
         [LOCAL.CAT.VAL [COMPS < [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl ],
                                   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
                                   LOCAL.CONT.HOOK.XARG #1,
                                   LKEYS.KEYREL.ARG1 #1], 
				 [ LOCAL.CAT.HEAD nominal ] >]] ].

trans-particleshift-eventobj-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particleshift-eventobj-synsem ].

trans-secpred-refl-dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-refl-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                             [ LOCAL.CONT.HOOK.INDEX ad-event & [SORT path-related-motion]] >]] ].




; sparke ballen flat
trans-secpred-arg1-2-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-2-x-synsem ].

; sparke_secpred-refl
trans-secpred-arg1-2-x-refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-2-x-refl-synsem ].

; sparke_particleshift
trans-particleshift-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particleshift-synsem ].

; sparke_adjshift
trans-adjshift-verb-lexeme := verb-lexeme &
[ SYNSEM trans-adjshift-synsem ].

; kle p√• seg jakken
trans-ppshift-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-synsem ].

;bre p√• Ola dynen
trans-ppshift-nonrefl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-nonrefl-synsem ].

trans-ppshift-decl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-decl-synsem ].

trans-ppshift-with-refl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-with-refl-decl-synsem ].

trans-ppshift-with-refl-equi-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-with-refl-equi-synsem ].

trans-ppshift-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-interr-synsem ].

; kle p√• gutten 
trans-ppshift-implicit-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-implicit-synsem ].
; kle p√• seg 
trans-ppshift-refl-implicit-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-refl-implicit-synsem ].

; se_subord
trans-subord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-subord-synsem ].

trans-secpred-arg1-2decl-x-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-2decl-x-synsem ].

trans-secpred-arg1-2interr-x-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-2interr-x-synsem ].

; se_subord
trans-barefinite-subord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-barefinite-subord-synsem ].

;lexeme & lbl-ltop-lex-item-3rel
trans-absinfsubord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-absinfsubord-synsem ].

trans-arg1absinf-absinfsubord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1absinf-absinfsubord-synsem ].

; muliggj√∏re det √•
trans-subord-expn-verb-lexeme := verb-lexeme &
[ SYNSEM trans-subord-expn-synsem ].

trans-particle-subord-expn-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particle-subord-expn-synsem ].

trans-secpred-subord-expn-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-subord-expn-synsem ].

; overlate det til Ola √•
trans-obl-subord-expn-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-subord-expn-synsem ].

; sp√∏rre_tr-interr
trans-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indirwhquest-synsem ].

trans-indir-y-n-quest-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indir-y-n-quest-synsem ].

trans-indir-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indir-interr-synsem ].

trans-indir-sudecl-obinterr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indir-sudecl-obinterr-synsem ].

; overlate, vise_1, unne
ditrans-arg1-2-3-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-arg1-2-3-synsem ].

; unne_1 (seg)
ditrans-arg1-2-3refl-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-arg1-2-3refl-synsem ].

; vise
ditrans-decl-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-decl-synsem ].

; forestille_subord-refl
ditrans-refl-decl-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-refl-decl-synsem ].

; forespeile noen √• 
ditrans-equiinf-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-equiinf-synsem ].

; foresette seg √•
ditrans-refl-equiinf-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-refl-equiinf-synsem ].

; sp√∏rre hvorvidt_ditr-interr
ditrans-y-n-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-y-n-nonrefl-indirwhquest-synsem].
;undre seg hvorvidt
ditrans-y-n-refl-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-y-n-refl-indirwhquest-synsem].
; sp√∏rre_hvem_ditr-interr
ditrans-wh-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-wh-nonrefl-indirwhquest-synsem].
;undre seg hvem
ditrans-wh-refl-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-wh-refl-indirwhquest-synsem].

; sp√∏rre_ditr-interr
;ditrans-indirwhquest-verb-lexeme := verb-lexeme &
;[ SYNSEM ditrans-indirwhquest-synsem ].

; undre_subord-refl
;ditrans-refl-indirwhquest-verb-lexeme := verb-lexeme & 
;[ SYNSEM ditrans-refl-indirwhquest-synsem ].

ditrans-eventarg1-decl-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1-decl-synsem ].
ditrans-eventarg1-interr-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1-interr-synsem ].
ditrans-eventarg1-absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1-absinf-synsem ].
ditrans-eventarg1decl-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1decl-eventarg2decl-synsem ].
ditrans-eventarg1decl-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1decl-eventarg2interr-synsem ].
ditrans-eventarg1interr-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1interr-eventarg2decl-synsem ].
ditrans-eventarg1interr-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1interr-eventarg2interr-synsem ].

; suse, regne
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
;(was verb-general-lexeme)
impersonal-presentational-verb-lexeme := verb-2rel-arg12a-lexeme & top-verb-lexeme &
  [ SYNSEM impersonal-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

impersonal-trans-presentational-verb-lexeme := verb-2rel-arg12a-lexeme & top-verb-lexeme &
  [ SYNSEM impersonal-trans-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

impersonal-presentational-result-verb-lexeme := verb-2rel-arg12a-lexeme & top-verb-lexeme &
  [ SYNSEM impersonal-trans-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY resultvb]].

; kvekke, ise, kile, kime
;impersonal-presentational-obl-verb-lexeme := verb-lexeme &
;  [ SYNSEM impersonal-presentational-obl-synsem ].

; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
impersonal-presentational-obl-verb-lexeme := verb-2rel-arg12aObl-lexeme &
  [ SYNSEM impersonal-presentational-obl-synsem ].

impersonal-presentational-obl-event-verb-lexeme := verb-2rel-arg12aObl-lexeme &
  [ SYNSEM impersonal-presentational-obl-event-synsem ].

subject-obl-presentational-verb-lexeme := verb-2rel-arg12a1Obl-lexeme &
 [ SYNSEM subject-obl-presentational-synsem ].

; tykne til, klarne opp
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
impersonal-presentational-telicparticle-verb-lexeme := verb-2rel-arg12ax-lexeme &
  [ SYNSEM impersonal-presentational-telicparticle-synsem ].

; verb-general
; sitte, v√¶re_6
;subject-presentational-verb-lexeme := lexeme & lbl-ltop-lex-item-2rel &
;  [ SYNSEM subject-presentational-synsem,
;    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
;                                   KEYS.KEY mainvb]].

subject-presentational-verb-lexeme := verb-2rel-arg12a1-lexeme &
  [ SYNSEM subject-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

subject-dir-presentational-verb-lexeme := verb-2rel-arg12a1-lexeme &
  [ SYNSEM subject-dir-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

; verb-general
; rusle_4, komme_pres
; see experiment 021012
;subject-dir-presentational-verb-lexeme := verb-2rel-arg12a1-lexeme &
;  [ SYNSEM subject-dir-presentational-synsem ].

; "det trenger seg fram en mann"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-secpred-refl-dir-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM subject-presentational-secpred-refl-dir-synsem ].

; verb-general
; "det bor mange i Moss"
subject-locobl-presentational-verb-lexeme := verb-2rel-arg12a1Obl-lexeme &
  [ SYNSEM subject-locobl-presentational-synsem ].

; "det hopper opp en katt"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-telicparticle-verb-lexeme := verb-2rel-arg12a1x-lexeme &
  [ SYNSEM subject-presentational-telicparticle-synsem ].

; "det smetter en katt ut"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-telicparticle-prtcllast-verb-lexeme := verb-2rel-arg12a1x-lexeme &
  [ SYNSEM subject-presentational-telicparticle-prtcllast-synsem ].

; tilkomme, vente "det venter meg en ulykke"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-presentational-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM io-presentational-synsem ].

;  "det setter seg en gutt"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-refl-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM subject-presentational-refl-synsem ].

; LH 260411 - see TODO for synsem
;  "det smyger seg en gutt"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-dir-presentational-refl-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM subject-dir-presentational-refl-synsem ].

subject-dir-presentational-refl-verb-lexeme :+ 
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD pers-pron]. ;; MHS 090813 Added to block weird bare infinite structures seen arising in sentences such as 'det sniker seg ut en mann'.

;  "det oppholder seg en gutt i hagen"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-locobl-presentational-refl-verb-lexeme := verb-2rel-arg12a12x-lexeme &
  [ SYNSEM subject-locobl-presentational-refl-synsem ].

;subject-locobl-presentational-refl-verb-lexeme :+
;[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD pers-pron]. ;; MHS 090813 Added to block weird bare infinite structures seen arising in sentences such as 'det setter seg en gutt her'.

; forekomme, foresveve - "det forekommer meg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-epon-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM io-epon-synsem ].
; "det viser seg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-refl-epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM io-refl-epon-synsem ].

; forekomme, foresveve - "det forekommer meg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-epon-wh-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM io-epon-wh-synsem ].
; "det viser seg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-refl-epon-wh-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM io-refl-epon-wh-synsem ].

; "det tar to timer √• g√• hit", "det koster fem kroner √•..."
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
meas-epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM meas-epon-synsem ].

; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
meas-io-epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM meas-io-epon-synsem ].

; forekomme, hende - "det forekommer/hender at han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-synsem ].

; "det sp√∏rs om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-indirwhquest-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-indirwhquest-synsem ].

; not a real type
; "det (expl) beror p√• om han kommer/at han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-oblique-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-oblique-synsem ].

; det beror p√• deg at/om han kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-decl-and-yn-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-pp-synsem ].
epon-decl-and-yn-particle-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-particle-pp-synsem ].
epon-np-decl-and-yn-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-np-decl-and-yn-pp-synsem ].
; det beror p√• deg hvem som kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-wh-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-pp-synsem ].
epon-wh-particle-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-particle-pp-synsem ].

; det beror p√• om du kommer at/om han kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-decl-and-yn-decl-and-yn-pp-clause-verb-lexeme := verb-2rel-lexeme &
[ SYNSEM epon-decl-and-yn-decl-and-yn-pp-clause-synsem ].
epon-decl-and-yn-decl-and-yn-particle-pp-clause-verb-lexeme := verb-2rel-lexeme &
[ SYNSEM epon-decl-and-yn-decl-and-yn-particle-pp-clause-synsem ].



; det beror p√• om du kommer hvem som kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:

epon-decl-and-yn-wh-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-wh-pp-clause-synsem ].
epon-decl-and-yn-wh-particle-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-wh-particle-pp-clause-synsem ].

; det beror p√• hvem som kommer at/om han kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-wh-decl-and-yn-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-decl-and-yn-pp-clause-synsem ].
epon-wh-decl-and-yn-particle-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-decl-and-yn-particle-pp-clause-synsem ].

; det beror p√• hvem som kommer hvem som vinner
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-wh-wh-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-wh-pp-clause-synsem ].
epon-wh-wh-particle-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-wh-particle-pp-clause-synsem ].

; det h√∏rer med at ...
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-particle-DECL-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-particle-DECL-synsem ].

; det h√∏rer med √• ...
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-particle-inf-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-particle-inf-synsem ].

; det V med om ...
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-particle-interr-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-particle-interr-synsem ].

; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-inf-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-inf-synsem ].

trans-eventarg1-decl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-decl-synsem ].

trans-eventarg1-interr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-interr-synsem ].

trans-eventarg1-absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-absinf-synsem  ].

trans-eventarg1-equi-contr-by-obj-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-equi-contr-by-obj-synsem  ].

trans-obl-eventarg1-equi-contr-by-obj-obl-contr-by-obj-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-obl-eventarg1-equi-contr-by-obj-obl-contr-by-obj-synsem ].

trans-eventarg1-decl-obl-equi-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-decl-obl-equi-synsem ].

trans-eventarg1-decl-obl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-decl-obl-synsem ].

trans-eventarg1-interr-obl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-interr-obl-synsem ].

trans-eventarg1decl-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventarg2decl-synsem ].
trans-eventarg1decl-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventarg2interr-synsem ].
trans-eventarg1interr-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventarg2decl-synsem ].
trans-eventarg1interr-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventarg2interr-synsem ].
trans-eventarg1absinf-eventarg2absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1absinf-eventarg2absinf-synsem ].
trans-eventarg1decl-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventobldecl-synsem ].
trans-eventarg1decl-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventoblinterr-synsem ].
trans-eventarg1interr-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventobldecl-synsem ]. 
trans-eventarg1interr-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventoblinterr-synsem ]. 


copula-lexeme := verb-general-lexeme &
   [ SYNSEM.LOCAL.CAT.HEAD [VOICE active,
                            KEYS.KEY mainvb]].

; v√¶re, bli ("suru")
copula-standard-verb-lexeme-sup := copula-lexeme &
   [ SYNSEM copula-standard-synsem ].
;LH may9-11
copula-predparticle-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-predparticle-synsem ].
copula-predprtcl-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-predprtcl-synsem ].

copula-standard-verb-lexeme := copula-standard-verb-lexeme-sup.
copula-bli-standard-verb-lexeme := copula-standard-verb-lexeme-sup &
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.DERIVED-HEAD - ] > ].

; v√¶re, bli ("aru")
copula-locpp-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-locpp-synsem ].
;copula-locpp-pp-verb-lexeme := copula-lexeme &
;   [ SYNSEM copula-locpp-pp-synsem ].
copula-locpp-with-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-locpp-with-nonepon-synsem ].
copula-dirpp-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-dirpp-synsem ].
; v√¶re, bli ("aru")
copula-locadv-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-locadv-synsem ].

; v√¶re_abs
copula-standard-abs-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-standard-abs-synsem ].

copula-tough-abs-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-tough-abs-synsem ].

copula-er-√•-finne-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-er-√•-finne-synsem ].

; v√¶re_abs-nonepon-decl
copula-adj-abs-with-nonepon-decl-verb-lexeme := copula-lexeme &
  [ SYNSEM copula-adj-abs-with-nonepon-decl-synsem ].

; v√¶re_abs-nonepon-quest
copula-adj-abs-with-nonepon-quest-verb-lexeme := copula-lexeme &
  [ SYNSEM copula-adj-abs-with-nonepon-quest-synsem ].

; v√¶re_copnom, bli_copnom
copula-nom-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-nom-synsem ].

; ... er at...
copula-clause-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-clause-synsem ].

; ...er √• ...
copula-absinf-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-absinf-synsem ].

; √• ...er √• ...
copula-arg1absinf-absinf-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-arg1absinf-absinf-synsem ].

; ... er hvorvidt/hva...
copula-indirwhquest-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-indirwhquest-synsem ].

copula-indir-y-n-quest-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-indir-y-n-quest-synsem ].

copula-noun-with-sudecl-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-sudecl-nonepon-synsem ].

copula-noun-with-suYN-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-suYN-nonepon-synsem ].

copula-noun-with-suWH-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-suWH-nonepon-synsem ].

copula-noun-with-suabsinf-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-suabsinf-nonepon-synsem ].

¬§¬§¬§ := inflection.


;;; POTENTIAL LEXEMES, SEMANTICALLY MORE SPECIFIED, and NOT
;;; DESCENDING FROM predsort.tdl

; peke
intrans-arg1orient-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1orient-synsem ].

; fort√¶re
trans-arg1-2tel-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2tel & [ LOCAL.CAT.VAL [ COMPS < [] >]] ].

; spise, vinne
trans-arg1-2tel-opt-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2tel & [ LOCAL.CAT.VAL [ COMPS < [] >]] ].

; fortsette_2, g√•_3, l√∏pe_2, ta_3, rusle_2, flyte_2, hoppe_2
trans-arg1dir-2length-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1dir-2length-synsem ].

trans-arg1dir-2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1dir-2-synsem ].

trans-arg1dir-2refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1dir-2refl-synsem ].


;;; SEMANTICALLY ENRICHED TYPES
; verbs fitting these types are given in lex2.semlab.tdl, and depend on
; the predsort.tdl file
;; the i-synsemers
;; first types that can be subtypes of intrans-arg1-...
posture-verb-lexeme := verb-lexeme &
  [ SYNSEM posture-synsem ].
arrow-pointing-verb-lexeme := verb-lexeme &
  [ SYNSEM arrow-pointing-synsem ].
road-going-verb-lexeme := verb-lexeme &
  [ SYNSEM road-going-synsem ].
tour-going-verb-lexeme := verb-lexeme &
  [ SYNSEM tour-going-synsem ].
locomotion-verb-lexeme := verb-lexeme &
  [ SYNSEM locomotion-synsem ].

;; then types that can be subtypes of trans-arg1-2-...
directing-arrow-verb-lexeme := verb-lexeme &
  [ SYNSEM directing-arrow-synsem ].
directing-line-verb-lexeme := verb-lexeme &
  [ SYNSEM directing-line-synsem ].
directing-tour-verb-lexeme := verb-lexeme &
  [ SYNSEM directing-tour-synsem ].
ejecting-verb-lexeme := verb-lexeme &
  [ SYNSEM ejection-synsem ].

line-follow-line-verb-lexeme := verb-lexeme &
  [ SYNSEM line-follow-line-synsem ].
line-crossing-line-verb-lexeme := verb-lexeme &
  [ SYNSEM line-crossing-line-synsem ].
begleiten-verb-lexeme := verb-lexeme &
  [ SYNSEM begleiten-synsem ].
crossing-locomotors-verb-lexeme := verb-lexeme &
  [ SYNSEM crossing-locomotors-synsem ].

init-verb-lexeme := verb-lexeme &
  [ SYNSEM init-synsem ].
init-und-verb-lexeme := verb-lexeme &
  [ SYNSEM init-und-synsem ].
init-dat-verb-lexeme := verb-lexeme &
  [ SYNSEM init-dat-synsem ].
init-und-dat-verb-lexeme := verb-lexeme &
  [ SYNSEM init-und-dat-synsem ].
und-verb-lexeme := verb-lexeme &
  [ SYNSEM und-synsem ].
und-dat-verb-lexeme := verb-lexeme &
  [ SYNSEM und-dat-synsem ].
dat-verb-lexeme := verb-lexeme &
  [ SYNSEM dat-synsem ].

init-locomotion-verb-lexeme := verb-lexeme &
  [ SYNSEM init-locomotion-synsem ].


; broken ARG1 link -db jan05; 
;; other potential predsort.tdl-dependents, shaded in lexicon.tdl,
; but not present in verb-lex.tdl
basic-intrans-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1-synsem & [ LKEYS.KEYREL posture-svh-rel]].
ejection-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2ejection ].
intrans-dir-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1dir-synsem ].



;;;;; IMPERATIVE

; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
imperative-verb-lexeme := const-ltol-rule &
  [ C-CONT.RELS <! 2nd-pers-pron-rel & [PRED "addressee-rel",
					ARG0 #2 & [ PNG.NG masc ],
                                        LBL #3],
                               contextual-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    C-CONT.HCONS #8 & <! [HARG #4,
                           LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD verb-all & [ COP #10,
				       KEYS.KEY #key,
                                       VOICE active,
				       INV -,
				       MAIN-CL +],
    SYNSEM.LOCAL.CONT.HOOK #1, 
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imperative,
    SYNSEM.LOCAL.CONT.HCONS #8,
    SYNSEM.LOCAL.CONT.RELS <! [],[], [] !>,
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE +,
;    SYNSEM.LOCAL.CAT.VAL.SPR olist,  - LH250612, outcomment to allow 'han kommer ikke', 'han unner henne ikke boken'
    SYNSEM.LOCAL.CAT.VAL.SUBJ antilist, ;; MHS 110713 replaces SUBJ cons with SUBJ antilist
    SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #19,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY +,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED +,
    DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ COP #10,
					   KEYS.KEY #key,
					   MAIN-CL +],
    DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED +,
    DTR.SYNSEM.LOCAL.NEED-IMP-UNARY +,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    DTR.SYNSEM.LOCAL.CONT.HOOK #1,
    DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CONT.HOOK.INDEX #2 ]>,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #9 & list,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #19,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>].


;;;;;;;;;;;;; NOUN ITEMS ;;;;;;;;;;;;;;;;;

noun-item := lexeme &
  [ INFLECTION [ GEND gen,
                 NUMB num,
                 DEFINITENESS definiteness ]].
m-noun := noun-item &
  [ INFLECTION [ GEND m ]].
f-noun := noun-item &
  [ INFLECTION [ GEND f ]].
n-noun := noun-item &
  [ INFLECTION [ GEND n ]].
sing-noun := noun-item &
  [ INFLECTION [ NUMB sing ]].
plur-noun := noun-item &
  [ INFLECTION [ NUMB plur ]].
def-noun := noun-item &
  [ INFLECTION [ DEFINITENESS def ]].
indef-noun := noun-item &
  [ INFLECTION [ DEFINITENESS ind ]].

m-sing-def-noun := m-noun & sing-noun & def-noun.
m-sing-indef-noun := m-noun & sing-noun & indef-noun.
m-plur-def-noun := m-noun & plur-noun & def-noun.
m-plur-indef-noun := m-noun & plur-noun & indef-noun.
f-sing-def-noun := f-noun & sing-noun & def-noun.
f-sing-indef-noun := f-noun & sing-noun & indef-noun.
f-plur-def-noun := f-noun & plur-noun & def-noun.
f-plur-indef-noun := f-noun & plur-noun & indef-noun.
n-sing-def-noun := n-noun & sing-noun & def-noun.
n-sing-indef-noun := n-noun & sing-noun & indef-noun.
n-plur-def-noun := n-noun & plur-noun & def-noun.
n-plur-indef-noun := n-noun & plur-noun & indef-noun.

m-sing-noun := m-noun & sing-noun.
m-plur-noun := m-noun & plur-noun.
f-sing-noun := f-noun & sing-noun.
f-plur-noun := f-noun & plur-noun.
n-sing-noun := n-noun & sing-noun.
n-plur-noun := n-noun & plur-noun.

m-def-noun := m-noun & def-noun.
m-indef-noun := m-noun & indef-noun.
f-def-noun := f-noun & def-noun.
f-indef-noun := f-noun & indef-noun.
n-def-noun := n-noun & def-noun.
n-indef-noun := n-noun & indef-noun.

sing-def-noun := sing-noun & def-noun.
plur-def-noun := plur-noun & def-noun.
sing-indef-noun := sing-noun & indef-noun.
plur-indef-noun := plur-noun & indef-noun.



;;;;;;;;;;; NOUN LEXEMES;;;;;;;;;;;

noun-lxm := lexeme & no-slash &
  [ SYNSEM [ LOCAL.CAT.HEAD comm-noun,
;	     LOCAL.INHER-WH -,
	     NON-LOCAL.SLASH 0-dlist & [ LIST < > ]]].

;noun-lexeme := lbl-ltop-lex-item & rule & lexeme &
noun-lexeme := lbl-ltop-lex-item & rule & noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD comm-noun & [ EXPLETIVE -], ;DEGREE positive,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC list,
                           COMPS <>,
                           ICOMPS list],
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.DERIVED-HEAD -,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.BND-MOUNTABLE <>,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.PROPERNAME -,
    SYNSEM.LKEYS.KEYREL relation,
    INFLECTION #1,
    INFL-MORPH #1,
    EXTRINSIC-ORD status-noun-infl-lexeme ].

lightverb-noun-lexeme := fact-inanim-noun-lxm &
 [ SYNSEM.LOCAL.CAT.VAL lightverbnoun-val ].

neut-lightverb-noun-lxm := lightverb-noun-lexeme & neut-noun-lxm.

;neut-noun-lxm := noun-lexeme & n-noun &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
;fem-noun-lxm := noun-lexeme & f-noun &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
;masc-noun-lxm := noun-lexeme & m-noun &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
;,SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +

neut-noun-lxm := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
fem-noun-lxm := noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY bool ]. ;-
masc-noun-lxm := noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY bool ]. ;-

;sg-indef-noun-lxm := noun-lexeme & sing-indef-noun &
;  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE - ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].

;; nb-infl
mascorneut-noun-lxm := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut-or-masc,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY + ].
mascorfem-noun-lxm := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY + ].

; dummy exception type from Troll
ic-gend-noun-lxm := noun-lexeme.


; this type, with its immediate descendants, is in order to distinguish all the noun lexemes in lex4.na-lrg.tdl from measure-noun-lxm and its descendants, so that these 55 000 items do not all take part in rules designed for measure-nps. All of the types dir-, relanim-, reganim-, relinan- and reginan- have SORT specifications which are subtypes of 'referential-thing', hence when one day all 55 000 are annotated with regard to these options, they stay within the general large category, even though we are not explicitly subtyping them all under ref-noun-lexemes. In other words, once we glue in 'lanim-', 'ganim-', 'linan-' and 'ginan-' behind the 're' in 'neut-re-noun-lxm' etc., the ref-noun-lexeme with its immediate descendants will cease to play a role in the system. But since that day may never come, it will be a useful temporary type to have.

ref-noun-lexeme := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK hook & [INDEX.SORT referential-thing ]].

neut-re-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
fem-re-noun-lxm := ref-noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
masc-re-noun-lxm := ref-noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
mascorneut-re-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut-or-masc ].
mascorfem-re-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem ].
x-reginan-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

; referred to in 'measure-np' rules and lexemes:
;( no further subtypes here - but 'measure-unit' has its subtypes, and the
; rule np-mod-vp uses one of them - 'time-item' - to restrict the NP. 
; As long as no further subtypes of measure-noun-lxm are distinguished, this
; rule will still allow "*ankom to meter", alongside "ankom s√∏ndag"
measure-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook & [INDEX.SORT measure-unit ]],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measurnoun].

measure-many-dim-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook & [INDEX.SORT measure-unit ]],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measurnoun].

measure-length-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT length-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun ].

measure-time-noun-lxm-sup := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT time-item,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY meastimenoun ].
; removing ,
;    SYNSEM.LOCAL.CAT.VAL.SPEC 1-list, to get 'han veier 5 kg'
measure-weight-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT weight-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun  ].
measure-vol-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT volume-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun,
    SYNSEM.LOCAL.CAT.VAL.SPEC 1-list  ].
measure-amount-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT amount-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun  ].

measure-time-noun-lxm := measure-time-noun-lxm-sup.
;measure-specifictime-noun-lxm := measure-time-noun-lxm-sup &
;  [EXTRINSIC-ORD not-eligbl-for-noun-infl-lexeme].
measure-specifictime-noun-lxm := measure-time-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEF + ].
;generic_year_ne := measure-specifictime-noun-lxm.

masc-measure-length-noun-lxm := measure-length-noun-lxm & masc-noun-lxm.
fem-measure-length-noun-lxm := measure-length-noun-lxm & fem-noun-lxm.
neut-measure-length-noun-lxm := measure-length-noun-lxm & neut-noun-lxm.
mascorneut-measure-length-noun-lxm := measure-length-noun-lxm & mascorneut-noun-lxm.
mascorfem-measure-length-noun-lxm := measure-length-noun-lxm & mascorfem-noun-lxm.

masc-measure-time-noun-lxm := measure-time-noun-lxm & masc-noun-lxm.
fem-measure-time-noun-lxm := measure-time-noun-lxm & fem-noun-lxm.
neut-measure-time-noun-lxm := measure-time-noun-lxm & neut-noun-lxm.
mascorneut-measure-time-noun-lxm := measure-time-noun-lxm & mascorneut-noun-lxm.
masc-measure-specifictime-noun-lxm := measure-specifictime-noun-lxm & masc-noun-lxm.
mascorfem-measure-time-noun-lxm := measure-time-noun-lxm & mascorfem-noun-lxm.

masc-measure-weight-noun-lxm := measure-weight-noun-lxm & masc-noun-lxm.
fem-measure-weight-noun-lxm := measure-weight-noun-lxm & fem-noun-lxm.
neut-measure-weight-noun-lxm := measure-weight-noun-lxm & neut-noun-lxm.
mascorneut-measure-weight-noun-lxm := measure-weight-noun-lxm & mascorneut-noun-lxm.

masc-measure-vol-noun-lxm := measure-vol-noun-lxm & masc-noun-lxm.
fem-measure-vol-noun-lxm := measure-vol-noun-lxm & fem-noun-lxm.
neut-measure-vol-noun-lxm := measure-vol-noun-lxm & neut-noun-lxm.
mascorneut-measure-vol-noun-lxm := measure-vol-noun-lxm & mascorneut-noun-lxm.
mascorfem-measure-vol-noun-lxm := measure-vol-noun-lxm & mascorfem-noun-lxm.

masc-measure-amount-noun-lxm := measure-amount-noun-lxm & masc-noun-lxm.
fem-measure-amount--noun-lxm := measure-amount-noun-lxm & fem-noun-lxm.
neut-measure-amount-noun-lxm := measure-amount-noun-lxm & neut-noun-lxm.
mascorneut-measure-amount-noun-lxm := measure-amount-noun-lxm & mascorneut-noun-lxm.
mascorfem-measure-amount-noun-lxm := measure-amount-noun-lxm & mascorfem-noun-lxm.



;masc-measure-noun-lxm := masc-noun-lxm & measure-noun-lxm.
;neut-measure-noun-lxm := neut-noun-lxm & measure-noun-lxm.
;fem-measure-noun-lxm := fem-noun-lxm & measure-noun-lxm.
;mascorneut-measure-noun-lxm := mascorneut-noun-lxm & measure-noun-lxm.

; relevant for 'detached possessors' constructions:
;body-part-noun-lxm := noun-lexeme &
;  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT body-part ] ].
;masc-bodypart-noun-lxm := masc-noun-lxm & body-part-noun-lxm.
;neut-bodypart-noun-lxm := neut-noun-lxm & body-part-noun-lxm.
;fem-bodypart-noun-lxm := fem-noun-lxm & body-part-noun-lxm.

; this is the 'nothing special' type of noun. The way the body-part and
; measure nouns work, there are certain rules in which only they
; take part. For any noun non-eligible, it only need an exclusive
; marking - 'SORT full-thing' is such a marking, and also 'SORT measure-
; unit' relative to the rules requiring body part, and vice versa.
; By assumption, no rule will require of its undergoers that they be
;'SORT full-thing'.

reg-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook & [INDEX.SORT full-thing ]],
    SYNSEM.LOCAL.CAT.HEAD.RELATIONAL -,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun ].

anim-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT anim-thing ],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY animnoun ].
inanim-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT inan-thing ],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY inanimnoun ].

; a logical step - abs-noun-lxm (cf the type 'absnoun' under KEY) is
; formally bypassed

reg-anim-noun-lxm := reg-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY reganim ].
reg-inanim-noun-lxm := reg-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY reginan ].

masc-reganim-noun-lxm := masc-noun-lxm & reg-anim-noun-lxm.
masc-reginan-noun-lxm := masc-noun-lxm & reg-inanim-noun-lxm.
fem-reganim-noun-lxm := fem-noun-lxm & reg-anim-noun-lxm.
fem-reginan-noun-lxm := fem-noun-lxm & reg-inanim-noun-lxm.
neut-reganim-noun-lxm := neut-noun-lxm & reg-anim-noun-lxm.
neut-reginan-noun-lxm := neut-noun-lxm & reg-inanim-noun-lxm.
mascorneut-reganim-noun-lxm := mascorneut-noun-lxm & reg-anim-noun-lxm.
mascorneut-reginan-noun-lxm := mascorneut-noun-lxm & reg-inanim-noun-lxm.
mascorfem-reganim-noun-lxm := mascorfem-noun-lxm & reg-anim-noun-lxm.
mascorfem-reginan-noun-lxm := mascorfem-noun-lxm & reg-inanim-noun-lxm.

; for nouns like "vei" 'road' - not generalized
;dir-noun-lxm := noun-lexeme &
;  [ SYNSEM nounsynsem-arg0dir & [LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
;                                 LOCAL.CAT.HEAD.KEYS.KEY dirnoun ] ].

dir-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
            LOCAL.CONT.HOOK.DIRARG #1,
            LOCAL.CAT.HEAD.KEYS.KEY dirnoun, ; clashes with absnoun veien langs elven
            LKEYS.KEYREL.ARG0 #1 ] ].

masc-dir-noun-lxm := dir-noun-lxm & masc-noun-lxm.
fem-dir-noun-lxm := dir-noun-lxm & fem-noun-lxm.
neut-dir-noun-lxm := dir-noun-lxm & neut-noun-lxm.
mascorfem-dir-noun-lxm := dir-noun-lxm & mascorfem-noun-lxm.
mascorneut-dir-noun-lxm := dir-noun-lxm & mascorneut-noun-lxm.

;body-part is one subtype of this, event-nouns another - not going to that
; detail yet ('role-noun-lexeme' would be one way of continuing - see below)
relation-noun-lxm-sup := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT relatum,
            LOCAL.CAT.HEAD.RELATIONAL +,
            LOCAL.CAT.HEAD.KEYS.KEY relnoun] ].

relation-noun-lxm := relation-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].

rel-anim-noun-lxm := relation-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-noun-lxm := relation-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-noun-lxm := relation-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact,
    SYNSEM.LOCAL.CAT.VAL.SPR list ]. ; <[]> "ideen at..."

masc-relanim-noun-lxm := masc-noun-lxm & rel-anim-noun-lxm.
masc-relinan-noun-lxm := masc-noun-lxm & rel-inanim-noun-lxm.
masc-factinan-noun-lxm := masc-noun-lxm & fact-inanim-noun-lxm.
fem-relanim-noun-lxm := fem-noun-lxm & rel-anim-noun-lxm.
fem-relinan-noun-lxm := fem-noun-lxm & rel-inanim-noun-lxm.
fem-factinan-noun-lxm := fem-noun-lxm & fact-inanim-noun-lxm.
neut-relanim-noun-lxm := neut-noun-lxm & rel-anim-noun-lxm.
neut-relinan-noun-lxm := neut-noun-lxm & rel-inanim-noun-lxm.
neut-factinan-noun-lxm := neut-noun-lxm & fact-inanim-noun-lxm.
mascorneut-relanim-noun-lxm := mascorneut-noun-lxm & rel-anim-noun-lxm.
mascorneut-relinan-noun-lxm := mascorneut-noun-lxm & rel-inanim-noun-lxm.
mascorneut-factinan-noun-lxm := mascorneut-noun-lxm & fact-inanim-noun-lxm.
mascorfem-relanim-noun-lxm := mascorfem-noun-lxm & rel-anim-noun-lxm.
mascorfem-relinan-noun-lxm := mascorfem-noun-lxm & rel-inanim-noun-lxm.
mascorfem-factinan-noun-lxm := mascorfem-noun-lxm & fact-inanim-noun-lxm.


relation-obl-noun-lxm-sup := relation-noun-lxm-sup &
  [ SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1,
                                                  SELECTED +]]> ].

;; lhNov08: NB! the KEYS.KEY values need to be adjusted!
relation-obl-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY preprel ]]> ].

rel-anim-obl-noun-lxm := relation-obl-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-noun-lxm := relation-obl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-noun-lxm := relation-obl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-noun-lxm := masc-noun-lxm & rel-anim-obl-noun-lxm.
masc-relinan-obl-noun-lxm := masc-noun-lxm & rel-inanim-obl-noun-lxm.
masc-factinan-obl-noun-lxm := masc-noun-lxm & fact-inanim-obl-noun-lxm.
fem-relanim-obl-noun-lxm := fem-noun-lxm & rel-anim-obl-noun-lxm.
fem-relinan-obl-noun-lxm := fem-noun-lxm & rel-inanim-obl-noun-lxm.
fem-factinan-obl-noun-lxm := fem-noun-lxm & fact-inanim-obl-noun-lxm.
neut-relanim-obl-noun-lxm := neut-noun-lxm & rel-anim-obl-noun-lxm.
neut-relinan-obl-noun-lxm := neut-noun-lxm & rel-inanim-obl-noun-lxm.
neut-factinan-obl-noun-lxm := neut-noun-lxm & fact-inanim-obl-noun-lxm.
mascorfem-relanim-obl-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-noun-lxm.
mascorfem-relinan-obl-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-noun-lxm.
mascorfem-factinan-obl-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-noun-lxm.


relation-obl-decl-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

rel-anim-obl-decl-noun-lxm := relation-obl-decl-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-decl-noun-lxm := relation-obl-decl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-decl-noun-lxm := relation-obl-decl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-decl-noun-lxm := masc-noun-lxm & rel-anim-obl-decl-noun-lxm.
masc-relinan-obl-decl-noun-lxm := masc-noun-lxm & rel-inanim-obl-decl-noun-lxm.
masc-factinan-obl-decl-noun-lxm := masc-noun-lxm & fact-inanim-obl-decl-noun-lxm.
fem-relanim-obl-decl-noun-lxm := fem-noun-lxm & rel-anim-obl-decl-noun-lxm.
fem-relinan-obl-decl-noun-lxm := fem-noun-lxm & rel-inanim-obl-decl-noun-lxm.
fem-factinan-obl-decl-noun-lxm := fem-noun-lxm & fact-inanim-obl-decl-noun-lxm.
neut-relanim-obl-decl-noun-lxm := neut-noun-lxm & rel-anim-obl-decl-noun-lxm.
neut-relinan-obl-decl-noun-lxm := neut-noun-lxm & rel-inanim-obl-decl-noun-lxm.
neut-factinan-obl-decl-noun-lxm := neut-noun-lxm & fact-inanim-obl-decl-noun-lxm.
mascorfem-relanim-obl-decl-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-decl-noun-lxm.
mascorfem-relinan-obl-decl-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-decl-noun-lxm.
mascorfem-factinan-obl-decl-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-decl-noun-lxm.


relation-obl-inf-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ],
				  LOCAL.CAT.HEAD infin-comp]> ].

rel-anim-obl-inf-noun-lxm := relation-obl-inf-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-inf-noun-lxm := relation-obl-inf-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-inf-noun-lxm := relation-obl-inf-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-inf-noun-lxm := masc-noun-lxm & rel-anim-obl-inf-noun-lxm.
masc-relinan-obl-inf-noun-lxm := masc-noun-lxm & rel-inanim-obl-inf-noun-lxm.
masc-factinan-obl-inf-noun-lxm := masc-noun-lxm & fact-inanim-obl-inf-noun-lxm.
fem-relanim-obl-inf-noun-lxm := fem-noun-lxm & rel-anim-obl-inf-noun-lxm.
fem-relinan-obl-inf-noun-lxm := fem-noun-lxm & rel-inanim-obl-inf-noun-lxm.
fem-factinan-obl-inf-noun-lxm := fem-noun-lxm & fact-inanim-obl-inf-noun-lxm.
neut-relanim-obl-inf-noun-lxm := neut-noun-lxm & rel-anim-obl-inf-noun-lxm.
neut-relinan-obl-inf-noun-lxm := neut-noun-lxm & rel-inanim-obl-inf-noun-lxm.
neut-factinan-obl-inf-noun-lxm := neut-noun-lxm & fact-inanim-obl-inf-noun-lxm.
mascorfem-relanim-obl-inf-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-inf-noun-lxm.
mascorfem-relinan-obl-inf-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-inf-noun-lxm.
mascorfem-factinan-obl-inf-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-inf-noun-lxm.


relation-obl-interr-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].

rel-anim-obl-interr-noun-lxm := relation-obl-interr-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-interr-noun-lxm := relation-obl-interr-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-interr-noun-lxm := relation-obl-interr-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-interr-noun-lxm := masc-noun-lxm & rel-anim-obl-interr-noun-lxm.
masc-relinan-obl-interr-noun-lxm := masc-noun-lxm & rel-inanim-obl-interr-noun-lxm.
masc-factinan-obl-interr-noun-lxm := masc-noun-lxm & fact-inanim-obl-interr-noun-lxm.
fem-relanim-obl-interr-noun-lxm := fem-noun-lxm & rel-anim-obl-interr-noun-lxm.
fem-relinan-obl-interr-noun-lxm := fem-noun-lxm & rel-inanim-obl-interr-noun-lxm.
fem-factinan-obl-interr-noun-lxm := fem-noun-lxm & fact-inanim-obl-interr-noun-lxm.
neut-relanim-obl-interr-noun-lxm := neut-noun-lxm & rel-anim-obl-interr-noun-lxm.
neut-relinan-obl-interr-noun-lxm := neut-noun-lxm & rel-inanim-obl-interr-noun-lxm.
neut-factinan-obl-interr-noun-lxm := neut-noun-lxm & fact-inanim-obl-interr-noun-lxm.
mascorfem-relanim-obl-interr-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-interr-noun-lxm.
mascorfem-relinan-obl-interr-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-interr-noun-lxm.
mascorfem-factinan-obl-interr-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-interr-noun-lxm.



inher-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT inher-compl ],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY inhr-comp ].
masc-inher-noun-lxm := masc-noun-lxm & inher-noun-lxm.
fem-inher-noun-lxm := fem-noun-lxm & inher-noun-lxm.
neut-inher-noun-lxm := neut-noun-lxm & inher-noun-lxm.
mascorfem-inher-noun-lxm := mascorfem-noun-lxm & inher-noun-lxm.
mascorneut-inher-noun-lxm := mascorneut-noun-lxm & inher-noun-lxm.


; using types defined in prepsort.tdl & lex2.semlab
role-noun-lexeme := noun-lexeme.

; for event nouns with two roles, like "spising" ('eating')
; the 'roles' are supplied by the combinatory genitive rule, or by
; combining prepositions (prep-mod-n-phrase/rule)
init-und-relation-noun-lxm := role-noun-lexeme &
  [ SYNSEM [LKEYS.KEYREL.IARG.CLASS init-und-svh ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT init-und ]].
masc-init-und-relation-noun-lxm := masc-noun-lxm & init-und-relation-noun-lxm.
neut-init-und-relation-noun-lxm := neut-noun-lxm & init-und-relation-noun-lxm.
fem-init-und-relation-noun-lxm := fem-noun-lxm & init-und-relation-noun-lxm.

; for event nouns with an actor role, like "skrik"
; the 'roles' are supplied by the combinatory genitive rule, or by
; combining prepositions (prep-mod-n-phrase/rule)
init-relation-noun-lxm := role-noun-lexeme &
  [ SYNSEM [LKEYS.KEYREL.IARG.CLASS init-svh ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT actor ]].
masc-init-relation-noun-lxm := masc-noun-lxm & init-relation-noun-lxm.
neut-init-relation-noun-lxm := neut-noun-lxm & init-relation-noun-lxm.
fem-init-relation-noun-lxm := fem-noun-lxm & init-relation-noun-lxm.

; for event nouns with a theme role, like "fornedrelse"
; the 'roles' are supplied by the combinatory genitive rule, or by
; combining prepositions (prep-mod-n-phrase/rule)
und-relation-noun-lxm := role-noun-lexeme &
  [ SYNSEM [LKEYS.KEYREL.IARG.CLASS und-svh ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT theme ]].
masc-und-relation-noun-lxm := masc-noun-lxm & und-relation-noun-lxm.
neut-und-relation-noun-lxm := neut-noun-lxm & und-relation-noun-lxm.
fem-und-relation-noun-lxm := fem-noun-lxm & und-relation-noun-lxm.

; to regulate ltol-rules
status-noun-infl-lexeme := sort.
input-to-noun-infl-lexeme := status-noun-infl-lexeme.
output-from-noun-infl-lexeme := status-noun-infl-lexeme.
not-eligbl-for-noun-infl-lexeme := status-noun-infl-lexeme.

; [bmw]
;; TODO: definiteness
infl-lexeme := const-ltol-rule & rule &
 [ INFLECTION [GEND #2, NUMB #1 ],
   C-CONT.HOOK.INDEX.PNG.NG [ GEN #2, NUM #1 ] ].

noun-infl-lexeme := infl-lexeme & noun-lxm &
  [ SYNSEM.LOCAL.CAT #1 & [ VAL [ SPR list,
                                  SUBJ list,
                                  COMPS <>,
                                  ICOMPS list,
                                  SPEC list ],
                            HEAD noun ],
    SYNSEM.LOCAL.CONT.HOOK #hook,
    SYNSEM.LOCAL.BINDING #3,
    SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.CMPAR-PENDING #4,
    SYNSEM.LOCAL.PROPERNAME #pn,
    SYNSEM.LOCAL.FIRSTNAME #fn,
    EXTRINSIC-ORD output-from-noun-infl-lexeme,
    DTR lexeme,
    DTR.SYNSEM.LOCAL.CAT #1,
    DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    DTR.SYNSEM.LOCAL.BINDING #3,
    DTR.EXTRINSIC-ORD input-to-noun-infl-lexeme,
    DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
    DTR.SYNSEM.LOCAL.CMPAR-PENDING #4,
    DTR.SYNSEM.LOCAL.PROPERNAME #pn,
    DTR.SYNSEM.LOCAL.FIRSTNAME #fn,
    INFLECTION #2 & inflection,
    DTR.INFLECTION #2 & inflection ].


quant-noun-infl-lexeme := noun-infl-lexeme &
  [ SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    SYNSEM.LOCAL.CONT [HOOK #1,
                       HCONS #2,
                       RELS <! [],#8 !>],
    DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [ LTOP #6 ],
    DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    C-CONT.RELS <! #8 & [ARG0 #3,
                         RSTR #5 ] !>,
    C-CONT.HCONS #2 & <! [HARG #5,
                           LARG #6 ] !>,
    C-CONT.HOOK.INDEX #3].

; changed HEAD.DEF bool from HEAD.DEF -, to get "p√• fredag". perhaps costly
bare-sg-noun-lexeme := quant-noun-infl-lexeme & sing-noun &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel"] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH bool, ; -
                                   PNG.NG sg ],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF bool,
                       HEAD.BARE +,
                       VAL.SPR <> ]].

;HEAD.DEFINITE +                   
def-noun-lexeme := quant-noun-infl-lexeme & def-noun &
  [ C-CONT.RELS <! def-q-rel !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ BOUNDED +,
                                   WH - ], ; -
;    SYNSEM.LOCAL.CAT.VAL.SPR <>, ; the irule based on it requires a SPR
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CAT [ HEAD.DEF +,
                       HEAD.BARE - ]].


def-bare-noun-lexeme := noun-infl-lexeme & def-noun &
  [ C-CONT.RELS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ BOUNDED +,
                                   WH bool ], ; -
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CAT [ HEAD.DEF +,
                       HEAD.BARE + ]].


sg-indef-cum-det-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD art]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3],
    DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway ].

sg-indef-cum-poss-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD poss]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-poss-and-enumerator-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD poss], [LOCAL.CAT.HEAD.PROXIM +]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-nounspec-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           DEF -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD noun]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-quant-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD quant]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3],
    DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway ].

sg-indef-cum-card-noun-lxm := quant-noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD card]>,
;    SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
;    SYNSEM.LOCAL.CONT [ RELS #2,
;                        HCONS #3 ],
    C-CONT [ RELS <! [PRED "_udef_q_rel" ] !>,
             HCONS <! [] !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender ]].


;                           RELS #2,
;                           HCONS #3
;					     ] ].

; this actually redoes bare-sg-noun-lexeme := quant-noun-infl-lexeme & sing-noun from above, which Elias had nullified in lrules. Seems I want it back again, mostly for the need of predicative nouns.
sg-indef-bare-noun-lxm := sing-indef-noun & quant-noun-infl-lexeme &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender ],
    SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           DEF -,
                           BARE + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    C-CONT [ RELS <! indef-q-rel & [PRED "_indef_q_rel"] !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX #1],
    DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender] ].

#|
sg-indef-bare-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender ],
    SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! indef-q-rel & [ PRED "_indef_q_rel",
					     ARG0 #1,
					     RSTR #2] !>,
             HCONS <! [HARG #2,
		       LARG #3 ]!> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX #1],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender] ].
|#

pl-indef-noun-lexeme := noun-infl-lexeme & plur-indef-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG pl & #1 & gender ],
;    SYNSEM.LOCAL.CAT.HEAD.DEF -,  ; would be resonable,but feeds possessive rule LH131113: well, let's see again what the problem is - reactivating; LH090114: yes, all sorts of things get blocked- 'mine katter sover', 'mine glade katter ...', etc. Why was the '-' done in the first place? LH131113 should have been explicit about that ... Whatever effects were attempted must be achieved through specifications of daughter types.
    SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender]].

quant-pl-indef-noun-lexeme := pl-indef-noun-lexeme & quant-noun-infl-lexeme &
  [ C-CONT.RELS <! plurindef-q-rel !>,
    SYNSEM.LOCAL.CAT.VAL.SPR cons,
    SYNSEM.LOCAL.CAT.HEAD.BARE - ].

; designed for 'bare plural' occurrences (incl with adjectives)
leak-pl-indef-noun-lexeme := pl-indef-noun-lexeme & quant-noun-infl-lexeme &
  [ C-CONT.RELS <! plurindef-q-rel !>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.HEAD.BARE +,
    SYNSEM.LOCAL.CAT.HEAD.DEF -,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [BOUNDED -,
                                  WH bool], ;-
    RULE [ NEEDS-CARD -,
           NOMORE-CARD + ],
    DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway ].

nonleak-pl-indef-noun-lexeme := pl-indef-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CAT.HEAD.BARE -,
    RULE.NEEDS-CARD + ].

; designed for combination with cardinals (to, tre...)
;    SYNSEM.LOCAL.CAT.VAL.SPR cons & [FIRST [LOCAL.CONT.HOOK.INDEX.SORT card-unit,
cum-card-pl-indef-noun-lexeme := quant-pl-indef-noun-lexeme & nonleak-pl-indef-noun-lexeme &
  [ SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.CAT.HEAD.DEF -,
    SYNSEM.LOCAL.CAT.VAL.SPR 1-list & [FIRST [LOCAL.CONT.HOOK.INDEX.SORT sort,
                                            LOCAL.CAT.HEAD card & [KEYS.KEY crdnum,
								   DEGREE positive]]] ].


nonleak-nonquant-pl-indef-noun-lexeme := nonleak-pl-indef-noun-lexeme & 
  [ SYNSEM #1,
    DTR.SYNSEM #1 ].

; designed for combination with quantifiers (noen, ingen)
cum-q-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD n-quant ] >,
   SYNSEM.LOCAL.CAT.HEAD.DEF -].

; designed for combination with possessives (min...)
cum-posspron-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD poss ] >].

; designed for combination with determiners (de/disse glade gutter...)
cum-det-pl-indef-noun-lexeme := quant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD det ] >].

;SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & < [LOCAL.CONT.HOOK.INDEX.SORT card-unit]
cum-posspron-and-card-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & 
			    < [LOCAL.CONT.HOOK.INDEX.SORT sort], 
			      expressed-synsem & [LOCAL.CAT.HEAD poss ] >].

;SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & < [LOCAL.CONT.HOOK.INDEX.SORT card-unit]
cum-det-and-card-pl-indef-noun-lexeme := quant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & < [LOCAL.CONT.HOOK.INDEX.SORT sort], expressed-synsem & [LOCAL.CAT.HEAD det ] >].

; designed for combination with measure-nps (en sekk...)
cum-measure-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.HEAD.DEF -,
   SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD noun,
					LOCAL.CONT.HOOK.INDEX.SORT measure-unit] >].

sg-def-noun-lexeme := def-noun-lexeme & sing-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG sg ]].

plur-def-noun-lexeme := def-noun-lexeme & plur-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG pl ] ].

; experiment 15112018
sg-masc-def-noun-lexeme := sg-def-noun-lexeme & m-noun &
  [ C-CONT.HOOK.INDEX.PNG.NG masc-sg ].

; experiment 15112018 - not yet valid  quant-noun-infl-lexeme + m- ... as word
;sg-masc-def-noun-lexeme := sg-def-noun-lexeme & m-strict-noun-lexeme.
;sg-masc-def-noun-lexeme := def-noun-lexeme & m-strict-sg-noun-word.not yet working

sg-fem-def-noun-lexeme := sg-def-noun-lexeme & f-noun &
  [ C-CONT.HOOK.INDEX.PNG.NG fem-sg ].

sg-neut-def-noun-lexeme := sg-def-noun-lexeme & n-noun &
  [ C-CONT.HOOK.INDEX.PNG.NG neutsg,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway ].

;;;;;;;; ADJECTIVE LEXEMES
#|
; SYNSEM.LKEYS.KEYREL.ARG0 individual - should be adevent, but 
; in "to centimeter h√∏yere", the measure-np-cmpar-phrase seems
; to enforce index id
; made XARG individual, to get the right ARG1 in adv-from-adj-pos-lxm.
adj-lxm := lbl-ltop-lex-item & lexeme &
  [ SYNSEM.LOCAL.CAT [ HEAD adj & [ KEYS.KEY adj-selct ],
                       VAL.SUBJ <>,
                       VAL.SPR list,
                       VAL.SPEC <>],
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.XPRED #1 & predsort,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LKEYS.KEYREL.PRED #1,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL.SLASH <!!>,
    INFL-MORPH adjective_inflection ].
|#
; SYNSEM.LKEYS.KEYREL.ARG0 individual - should be adevent, but 
; in "to centimeter h√∏yere", the measure-np-cmpar-phrase seems
; to enforce index id
; made XARG individual, to get the right ARG1 in adv-from-adj-pos-lxm.
; LH260612: the outcomments are to make 'han synes meg syk' possible, with 'han' and 'meg' with distinct index.
adj-lxm := lbl-ltop-lex-item & lexeme &
  [ SYNSEM.LOCAL.CAT [ HEAD adj & [ KEYS.KEY adj-selct ],
                       VAL.SUBJ <>,
                       VAL.SPEC <>],
;    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.XPRED #1 & predsort,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #2 & [ ROLE #3 ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE #3,
    SYNSEM.LKEYS.KEYREL.PRED #1,
;    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.DERIVED-HEAD -,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL.SLASH <!!>,
    INFL-MORPH adjective_inflection ].


; fin_abs; "det er fint i Hardanger"
abs0-adj-lxm-sup := adj-lxm &
  [ SYNSEM.LOCAL.CAT [ HEAD adj-reg & [ DEGREE positive,
                                        KEYS.KEY absadj0 ]],
    SYNSEM.LKEYS.KEYREL adj0_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 & expl-ind,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1 & ref-ind & [PNG 3nsg],
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.AGR #1,
    SYNSEM.LOCAL.CAN-MODIFY - ].

abs0-adj-lxm := abs0-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].

abs-obl-adj-lxm-sup := abs0-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1,
                                                  SELECTED +]]> ].

abs-obl-adj-lxm := abs-obl-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


abs-obl-decl-adj-lxm := abs-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

abs-obl-inf-adj-lxm := abs-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

abs-obl-interr-adj-lxm := abs-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


; fin_abs-epon; "det er fint at han kommer", "det er fint √• komme"
; TODO, mystery: 'hyggelig √• hilse p√• deg' with oblN version of hilse, allows only reflexive deg (incorrect by itself), not pronominal.
abs-adj-epon-lxm := adj-lxm & 1arg-1comps &
  [ SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.AGR #2,
;    SYNSEM.LOCAL.AGR [PNG.NG neutsg],
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & handle,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #1] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY -  ].   
;,;
;				   LOCAL.CAT.HEAD [TRANSPAR -]

abs-adj-epon-decl-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD fin-comp,
				   LOCAL.CAT.HEAD.DECL + ] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

abs-adj-epon-infin-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD infin-comp,
				   LOCAL.CAT.HEAD.DECL +,
				   LOCAL.CAT.HEAD.TRANSPAR -] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

abs-adj-epon-pp-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep-or-adv] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

abs-adj-tough-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.AGR #2,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-tough,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD verb-all,
				   LOCAL.HAS-WH-MOVED +,
				   LOCAL.CONT.HOOK.XARG #2,
				   LOCAL.MUST-COORDINATE -] > ].
; LOCAL.CAT.HEAD infin-comp,
                                   


; "uvisst om/hvorvidt han kommer /hvem/hva...hvem som..."
abs-adj-epon-quest-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL -,
				   LOCAL.CAT.HEAD.CONDITIONAL -] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

; fin_abs-nonepon; "at han kommer er fint"
abs-adj-non-epon-lxm := adj-lxm &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.POSTHEAD +,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX event ].


abs-adj-nonepon-decl-lxm := abs-adj-non-epon-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj-decl-selct,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL +,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg]  ].

abs-adj-nonepon-quest-lxm := abs-adj-non-epon-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj-quest-selct,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL -,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.CONDITIONAL -,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg]  ].

abs-adj-nonepon-infin-lxm := abs-adj-non-epon-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj-quest-selct,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT [ LOCAL.CAT.HEAD infin-comp,
				   LOCAL.CAT.HEAD.DECL +,
				   LOCAL.CAT.HEAD.TRANSPAR -],
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.CONDITIONAL -,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg]  ].

#|
; replaced by  abs-adj-tough-lxm
;,
;                                   LOCAL.CONT.HOOK.INDEX.E.TENSE infin
tough-adj-lxm := adj-lxm & 1arg-1comps &	
  [ SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.AGR #2,
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & handle,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
                                   LOCAL.CONT.HOOK.XARG #2,
                                   LOCAL.CONT.HOOK.LTOP #1 ] >].
|#

; should have built in a restr that subj be non-expl, but without a syntactic position, that's hard, since expletives now have ref-ind
stnd-adj-lxm-sup := adj-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG #8,
    SYNSEM.LOCAL.AGR.PNG.NG #8,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY propt],
    SYNSEM.LOCAL.CAT.VAL.COMPS <> ].

; associated with strong-adj-lxm:
;& [DEF - ,
;							     DEFINITE -]
;
;SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun ]>,
;    							     DEFINITE -]
stnd-adj-lxm := stnd-adj-lxm-sup & reg-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD head,  ; previous np-head, but blocks coordination of adjectives, which goes as adjunction
				  LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY + ].

stnd-non-mod-adj-lxm := stnd-adj-lxm-sup & reg-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY - ].

; ,
;    SYNSEM.LKEYS.KEYREL arg1obl-rel;,
;    SYNSEM.LKEYS.KEYREL adjObl_rel                             
; not inheriting from reg-mod-lex-item!
stnd-obl-adj-lxm-sup := stnd-adj-lxm-sup & 
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod,
     SYNSEM.LOCAL.CONT.HOOK hook & [ VARG #3],
;    SYNSEM.LOCAL.CAT.HEAD.MOD list, ; was <>, but that prevents adjective-mod-indef-postnom-phrase from applying to 'avhengig av sport'
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <#obl & [LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY #1,
							       SELECTED +]]>,
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #obl & [LOCAL.CONT.HOOK.LTOP #2 & handle,
				LOCAL.CONT.HOOK.VARG #3],
    SYNSEM.LKEYS.KEYREL adjObl_rel & [ ARGOBLad #2 ]].

stnd-obl-adj-lxm := stnd-obl-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT [ VAL.ICOMPS < #1 & [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]>],;fct-spec
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #1 & [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nom & [ACCUSATIVE +],
				     LOCAL.BINDING nontamed & [REFL-I -]]].

stnd-dir-obl-adj-lxm := stnd-obl-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY dir ]]> ].

stnd-obl-decl-adj-lxm := stnd-obl-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.CAT [ VAL.ICOMPS < #1 & [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]>],
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #1 & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD comp & [DECL +],
                                                             CONT.HOOK.INDEX.E.TENSE finite]],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < #1 & [LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

stnd-obl-inf-adj-lxm := stnd-obl-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.CAT [ VAL.ICOMPS < #1 & [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]>],
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #1 & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD infin-comp & [DECL +],
                                                             CONT.HOOK.INDEX.E.TENSE infin]]].

stnd-obl-interr-adj-lxm := stnd-obl-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.CAT [ VAL.ICOMPS < #1 & [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]>],
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #1 & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                             CONT.HOOK.INDEX.E.TENSE finite]]].

; not inheriting from reg-mod-lex-item!
trans-adj-lxm-sup := adj-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <>,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.AGR #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nom] >].

trans-adj-lxm := trans-adj-lxm-sup & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].


trans-obl-adj-lxm-sup := trans-adj-lxm-sup & 2arg-1comps-1obl & 
  [ SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1,
                                                  SELECTED +]]>].

trans-obl-adj-lxm := trans-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


; weak and strong adj-lxm are ltol-rules. they are both positive
; both used to be reg-mod-lex-item, before clean-up
weak-adj-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ MOD < [LOCAL.CAT.HEAD np-head & [DEF bool ]] >, ; +
                                      WEAK +,
;                                      DEGREE positive, ; "de snilleste" good
                                      KEYS.KEY #7  ],
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CAT.HEAD.ORDINAL #8,
    SYNSEM.LOCAL.N-COMB-PENDING +,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.VAL #2,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #7,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
                    SYNSEM.LOCAL.CAT.HEAD.ORDINAL #8,
		    SYNSEM.NON-LOCAL #3]].


; MOD < #1 & [LOCAL.CAT.HEAD noun & [DEF - ,
;                                                                    DEFINITE -]]>
strong-adj-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ MOD #1,
				      WEAK -,
;                                      DEGREE positive,
                                      KEYS.KEY #7 ],
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT #51,
    SYNSEM.LKEYS.KEYREL ad-rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
    SYNSEM.LOCAL.CONT.HOOK.XPRED #4,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.AGR #8,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    SYNSEM.LOCAL.CAN-MODIFY #mod,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ #der,
    SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    SYNSEM.NON-LOCAL #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.VAL #2,
                    SYNSEM.LOCAL.CAT.HEAD.WEAK -,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #7,
                    SYNSEM.LOCAL.CAT.QVAL.SUBJECT #51,
                    SYNSEM.LOCAL.CAT.HEAD.MOD #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #4,
                    SYNSEM.LOCAL.AGR #8,
                    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
		    SYNSEM.LOCAL.CAN-MODIFY #mod,
		    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ #der,
		    SYNSEM.LOCAL.CAT.POSTHEAD #ph,
		    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
		    SYNSEM.NON-LOCAL #3 ]].

#|
comparative-adj-lxm := lbl-ltop-lex-item-4rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ DEGREE comparative,
                                      KEYS.KEY #19 ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7 & [ ROLE compare-top ],
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #2,
                                   ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
                    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #19,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].
|#
; reduced number of 'measure-out's

comparative-adj-lxm := lbl-ltop-lex-item-2rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ DEGREE comparative,
                                      KEYS.KEY #19, ; has been commented out, don't remember why. Useful to avoid adj-tough as being a candidate whenever there is a comparative form
				      COMPAR-DEP enn-cmpar],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7 & [ ROLE compare-top ],
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING #pend,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #4,
                                   ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
                    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
		    SYNSEM.LOCAL.CMPAR-PENDING #pend,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #19,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].

#|
sup-adj-lxm := lbl-ltop-lex-item-5rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ DEGREE superlative,
                                  KEYS.KEY #keys ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #2,
                                   ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5],
                            arg1-relation & [ LBL #1,
					      PRED #9,
					      ARG0 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.HEAD adj & [ KEYS.KEY #keys ],
                    SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].
|#

sup-adj-lxm := lbl-ltop-lex-item-3rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ DEGREE superlative,
                                  KEYS.KEY #keys ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #4,
                                   ARG2 #5 ],
                            arg1-relation & [ LBL #1,
					      PRED #9,
					      ARG0 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.HEAD adj & [ KEYS.KEY #keys ],
                    SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].

sup-adj-standalone-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <>, ;< >, blocked 'den h√∏yeste gutten'
    SYNSEM.LOCAL.SUBJ-ONLY + ].

sup-adj-cum-part-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD part-prep,
                                 LOCAL.CONT.HOOK.XARG #10,
                                 LOCAL.CONT.HOOK.CMPAR-ARG #7] >,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    C-CONT.RELS <! [], [ ARG1 #10] !>].

sup-adj-weak-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD np-head & [DEF bool ], ;+
                                   LOCAL.CAT.VAL.SPR list ] >, ;< [] >
                            WEAK + ] ].

sup-adj-strong-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD np-head & [DEF - ] ] >,
                            WEAK - ] ].

sup-adj-weak-standalone-lxm := sup-adj-weak-lxm & sup-adj-standalone-lxm.
sup-adj-strong-standalone-lxm := sup-adj-strong-lxm & sup-adj-standalone-lxm.
sup-adj-weak-cum-part-lxm := sup-adj-weak-lxm & sup-adj-cum-part-lxm.
sup-adj-strong-cum-part-lxm := sup-adj-strong-lxm & sup-adj-cum-part-lxm.



; here could come one more sup-adj suitable for free-predicative combination






adv-from-adj-pos-lxm := reg-mod-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM.LOCAL.CAT.HEAD a & [ MOD < [LOCAL.CAT.HEAD verb-all,
                                       LOCAL.CONT.HOOK.INDEX event]>,
;                                DEGREE positive,
                                KEYS.KEY index-sit ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
;    SYNSEM.LOCAL.DERIVED-HEAD +, ; reasonable constraint, but heavy protests
    INFLECTION #1,
    DTR stnd-adj-lxm & [ SYNSEM.LOCAL.CAT.VAL #2,
 ;                        SYNSEM.LOCAL.DERIVED-HEAD +,
			 SYNSEM.LOCAL.CAN-ADV-DERIV-ADJ +,
			 INFLECTION #1]].

; "fundamentalt forskjellig"
degadv-from-adj_t-pos-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD degspr, ; & [ DEGREE positive ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD adj] >,
                          COMPS <>,
                          ICOMPS <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    INFLECTION #1,
    DTR stnd-adj-lxm & [ SYNSEM.LOCAL.CAN-ADV-DERIV-ADJ +,
			 INFLECTION #1]].

; "eitrende forbannet"
degadv-from-adj_nde-pos-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD degspr, ; & [ DEGREE positive ],
    SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD adj] >,
                          COMPS <>,
                          ICOMPS <> ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    DTR presparticpl-adj-lxm ].

#|
adv-from-adj-cmpar-lxm-sup := lbl-ltop-lex-item-4rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD a & [ MOD < [LOCAL.CAT.HEAD verb,
                                       LOCAL.CONT.HOOK.INDEX #7]>,
                                KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #2,
                                   ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !> ]].
|#

adv-from-adj-cmpar-lxm-sup := lbl-ltop-lex-item-2rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD a & [ MOD < [LOCAL.CAT.HEAD verb,
                                       LOCAL.CONT.HOOK.INDEX #7]>,
                                KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #4,
                                   ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !> ]].

adv-from-adj-cmpar-lxm := adv-from-adj-cmpar-lxm-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative ].

adv-from-adj-superlat-lxm := adv-from-adj-cmpar-lxm-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative ].



;adv-from-adj-t-pos-lxm := adv-from-adj-pos-lxm & infl-ltol-rule.
;adv-from-adj-√∏-pos-lxm := adv-from-adj-pos-lxm & const-ltol-rule.

; PHRASAL TYPES

;without message
;non-rel-clause & 
imperative-phrase := head-valence-phrase & head-only & rule &
  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ olist & antilist,
;			       SPR olist,
			       COMPS < >,
                               ICOMPS <> ],
                         HEAD.INV - ] ],
    SYNSEM.LOCAL.CONT.HOOK #hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF comm,
    SYNSEM.LOCAL.NEED-IMP-UNARY -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
   ; SYNSEM.NON-LOCAL #5, ;; MHS 190713 This is superflous. The same work is done by head-valence-phrase, which this is already a daughter of.
    EXTRINSIC-ORD complete-imp,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb-all & [IMPERATIVE +,
                                                   INV -,
                                                   KEYS.KEY mainvb],
                                  VAL [ SUBJ < []  >,
                                        COMPS < >,
                                        ICOMPS <> ] ],
			    CONT.HOOK #hook],
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imperative,
    HEAD-DTR.EXTRINSIC-ORD noncomplete-imp,
   ; HEAD-DTR.SYNSEM.NON-LOCAL #5,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].


;LH may24-11
; this rule introduces a 'NIL' EP and free variables in so far not explored ways. The rule itself is commented out. Needs an overhaul before brought back into the grammar.
;                               VAL [ SUBJ < []  >,
interjection-phrase := non-rel-clause & head-valence-phrase & head-only & rule &
  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ olist & antilist,
			       SPR olist,
			       COMPS < >,
                               ICOMPS <> ]] ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    SYNSEM.LOCAL.NEED-IMP-UNARY -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
;    SYNSEM.NON-LOCAL #5, ;; MHS 190713
    EXTRINSIC-ORD complete-imp,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD interjection & [KEYS.KEY interjct,
						   INTERJECT +],
                                  VAL [ SUBJ < >,
                                        COMPS < >,
                                        ICOMPS <> ] ] ],
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP <>,
 ;   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD hortative,
    HEAD-DTR.EXTRINSIC-ORD noncomplete-imp,
 ;   HEAD-DTR.SYNSEM.NON-LOCAL #5,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

left-parenthesis-phrase := basic-head-spec-phrase & head-final & rule &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD parenthesis & [KEYS.KEY start-parenth ],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].
right-parenthesis-phrase := basic-head-comp-phrase & head-initial & rule &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD parenthesis & [KEYS.KEY end-parenth ],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].
left-quote-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quotation-mark & [KEYS.KEY start-quote ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].
right-quote-phrase := basic-head-comp-phrase & head-initial & rule &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quotation-mark & [KEYS.KEY end-quote ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].


; 'SYNSEM.LOCAL.SPEC-TO-BARE-N #deriv,' only to constrain
; interaction with unary-rel -rule
; SYNSEM.LOCAL.CAT.VAL.SPR <> - made it list instead, for "de fleste av guttene";
; cf superlat-cum-part-quantity-word

head-spec-phrase-super-sup := head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.SPEC-TO-BARE-N #deriv,
    SYNSEM.LOCAL.BND-RESP #5,
 ;   HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [EXPLETIVE -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #1]].

; ,strange that this was commented out - gives mismatching det and N in NPs
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX ref-ind]

head-spec-phrase-super := basic-head-spec-phrase & head-spec-phrase-super-sup.

    

#|
;mal-head-spec-phrase-super := mal-basic-head-spec-phrase & head-spec-phrase-super-sup.
|#


; for "den tredje av guttene", headed by "av" - prep-part
head-spec-det-adj-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltp,
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.AGR.PNG.NG #agr,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DERIVED-HEAD #dh,
    SYNSEM.LOCAL.COORD-RELEASED #coord,
    SYNSEM.LOCAL.BND-RESP #5,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #png,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +, 
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltp,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #agr,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #agr,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #agr,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #coord,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #dh,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #agr,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #png,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD det,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltp,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].


head-spec-phrase-cardsift-sup := head-spec-phrase-super-sup &
  [HEAD-DTR.RULE [ NEEDS-CARD bool,
                   NOMORE-CARD bool ],
   C-CONT.RELS <! !>,
   C-CONT [ HCONS <! !>] ].

head-spec-phrase-cardsift := head-spec-phrase-cardsift-sup & head-spec-phrase-super.


head-spec-phrase-cardblock-sup := head-spec-phrase-super-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #1,
    SYNSEM.LOCAL.COORD-RELEASED #coord,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #1,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #coord,
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                   NOMORE-CARD - ]].

head-spec-phrase-cardblock := head-spec-phrase-super & 
[ NON-HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX #index,
			      AGR #index ]].

; does 'nom' here yield overgeneration? possibly - but necessary
; for combination with part-prep


head-spec-quantor-phrase-sup := head-spec-phrase-cardblock-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CONT.HOOK #sh & super-hook,
    SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #sh & super-hook,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head,; rather than nom, to allow 'alle fire'. That also allows 'hver fire sover', which is less good
;    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; 'alle gule sover' must be allowed
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    C-CONT.RELS <! !>,
    C-CONT [ HCONS <! !>]  ]. 

head-spec-quantor-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom & [DEF -], ; nom, in order to branch off from the q-type heads. "minst en" in "minst en dag" should not combine by this rule. 
HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING -,
   HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD -]. ; to avoid duplicate versions of adj

head-spec-quantor-q-phrase := head-spec-quantor-phrase &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quant ].

;redundant
partitive-fem-av-phrase := head-spec-quantor-phrase &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card ].

head-spec-allquant-card-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card & [DEF -], ; nom, in order to branch off from the q-type heads. "minst en" in "minst en dag" should not combine by this rule. 
   HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING -,
   HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD -, ; to avoid duplicate versions of adj
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quant ]. 

; for "de fleste"
head-spec-def-quantor-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ SYNSEM.LOCAL.CAT.VAL.SPR cons,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre] ]. 


head-spec-plurquant-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cardquant ]. 

head-spec-partitive-quantor-phrase := head-spec-phrase-cardblock &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ]. 

head-spec-art-phrase-super-sup := head-spec-phrase-cardblock-sup &
  [ SYNSEM.LOCAL.CMPAR-PENDING #2,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD art,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>  ].

head-spec-art-phrase-sup := head-spec-art-phrase-super-sup & head-spec-phrase-cardblock &
  [ HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N - ].

head-spec-art-phrase := head-spec-art-phrase-2sup & head-spec-phrase-cardblock.

;LH040513 turning this to 'list' is for n-connect-spr-phrase
head-spec-art-phrase-2sup := head-spec-art-phrase-super-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N - ].


head-spec-art-cum-plurspec-phrase := head-spec-art-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-pl-spc ].

head-spec-art-cum-singspec-phrase := head-spec-art-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc ]. 


head-spec-card-phrase-sup := head-spec-phrase-cardblock &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep, 
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ]. 

head-spec-card-phrase := head-spec-card-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH bool, ;-
    NON-HEAD-DTR word].

head-cmplxspec-card-phrase := head-spec-card-phrase-sup &
  [ NON-HEAD-DTR measure-quantword-a-phrase ].


head-spec-noun-phrase := head-spec-phrase-cardblock &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ]. 

; SYNSEM.LOCAL.CONT.HOOK.INDEX #xarg,
;    
;
head-spec-cardderivnoun-phrase := head-spec-phrase-cardblock &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    C-CONT.RELS <! arg12-relation & [ LBL #lbl,
				      PRED "coreferential_rel",
				      ARG1 #xarg,
				      ARG2 #ind ], indef-q-rel & [PRED "_udef_q_rel",
								  ARG0 #ind,
								  RSTR #rstr], [ PRED "_pron_rel",
										 LBL #lbl,
										 ARG0 #ind ] !>,
    C-CONT.HCONS <! [HARG #rstr,
		     LARG #lbl] !> ]. 

; for "gutter flest". Mostly taken from head-spec-phrase-super, head-spec-phrase-cardblock and head-spec-quantor-phrase

head-spec-post-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.SPEC-TO-BARE-N #deriv,
    SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #10,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #10,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [DEF -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                   NOMORE-CARD - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-post,
						    DEGREE superlative],
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].

; 'h√∏yeste av guttene'
head-spec-adj-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #7 ] >,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

head-spec-det-phrase-sup := head-spec-phrase-cardsift-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD det].


;;; DPF addenda

head-spec-det-phrase := head-spec-det-phrase-sup & head-spec-phrase-cardsift &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX #index,
				AGR #index ] ].



;head-spec-det-phrase := head-spec-det-phrase-sup & head-spec-phrase-cardsift. 



complex-spec-n-phrase-super := basic-head-spec-phrase & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
;    HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>].

complex-spec-n-phrase-sup := complex-spec-n-phrase-super & head-final.
;complex-spec-n-prenom-phrase-sup := complex-spec-n-phrase-super & head-initial.

;; Alternative path created for normal. 30.03.11.
complex-spec-n-phrase-head-initial-sup := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list].

complex-spec-n-phrase := complex-spec-n-phrase-sup &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    C-CONT.RELS.LIST.FIRST[LBL #8,
			   ARG1 #2,
			   ARG2 #1]].

complex-spec-n-phrase-head-initial := complex-spec-n-phrase-head-initial-sup &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    C-CONT.RELS.LIST.FIRST[LBL #8,
			   ARG1 #2,
			   ARG2 #1]].

#|

  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3 ].




complex-spec-n-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    C-CONT.RELS <![LBL #8,
		   ARG1 #2,
		   ARG2 #1], indef-q-rel & [ PRED "_indef_q_rel",
					     ARG0 #2,
					     RSTR #9 ] !>,
    C-CONT.HCONS <! [ HARG #9,
                      LARG #8 ] !>].

|#


;    C-CONT [ RELS <! [ARG1 #2,
;                      ARG2 #1],... !>]].

; temporarily taken out 
; HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
; in order to enable "et par dusin", where "dusin" is not referential-thing
    
; the marking 'WH -' may need amendment to accommodate "hvor mange dusin egg"

measure-np-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK #sh & super-hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
					   DEFINITE -],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #sh & super-hook,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY measnoun],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-item ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
					       DEFINITE -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    C-CONT [ RELS <! measure-out-rel &
		   [LBL #5], indef-q-rel & [ PRED "_indef_q_rel",
					     ARG0 #1,
					     RSTR #2]  !>,
	     HCONS <! [HARG #2,
		       LARG #5 ] !>],
    RULE.NOMORE-CARD + ].


parameter-spec-phrase := basic-head-spec-phrase & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.XARG #3],
    HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.LTOP #8],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    C-CONT [ RELS <! [LBL #8,
		      ARG1 #2,
                      ARG2 #1] !>,
	     HCONS <! !>]].


klokka-spec-phrase := parameter-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT time-item],
    HEAD-DTR klokka-word,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    C-CONT [ RELS <! measure-out-rel !> ]].

order-spec-phrase := parameter-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
;    HEAD-DTR klokka-word,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    C-CONT [ RELS <! measure-out-rel !> ]].

title-spec-phrase := parameter-spec-phrase & head-final &
  [ NON-HEAD-DTR title-word,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prop-noun,
    C-CONT [ RELS <! title-of-rel !> ]].

title-suffix-spec-phrase := parameter-spec-phrase & head-initial &
  [ NON-HEAD-DTR title-word,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prop-noun,
    C-CONT [ RELS <! title-of-rel !> ]].


; probably have NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
; HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY crdfix],
weekday-spec-phrase := parameter-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT time-item,
				  WH -],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY weekday-noun,
						    DEF -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SPR <>,
				       SUBJ <>,
				       COMPS <>,
				       ICOMPS <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY crdfix],
;    the above line restricts too much, perhaps, but saying nothing gives wild consequences
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT.RELS <! arg12-relation & [ PRED "contains-in-time-rel" ] !> ].

; "fem tusen to hundre menn"
complex-number-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #png,
    ARGS < 
           [SYNSEM.LOCAL.CAT.HEAD #head,  ; card-cum-plurspec-mod-phrase & 
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LOCAL.CARD-TO-BARE-N -,
	    SYNSEM.LOCAL.SPEC-TO-BARE-N -,
	    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -],
  ;         card-cum-plurspec-mod-phrase & 
           [SYNSEM.LOCAL.CAT.HEAD #head & [KEYS.KEY takes-pl-spc],
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LOCAL.CARD-TO-BARE-N -,
	    SYNSEM.LOCAL.SPEC-TO-BARE-N -,
	    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
	    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #png ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].

; "han hoppet fem femti"
complex-card-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD cardquant,
    SYNSEM.LOCAL.CAT.HEAD.DEGREE positive,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [WH -,  ; perhaps too strong: 'hvilke fem femti...'
				       PNG.NG.NUM plur], 
    ARGS < [SYNSEM.LOCAL.CAT.HEAD #head & cardnum,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1],
           [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2 ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].
    

; "fem tusen femti menn"
numbernoun-plus-card-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & noun & [KEYS.KEY takes-pl-spc], ;KEY to ensure 'tusen' or 'hundre'
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LOCAL.CARD-TO-BARE-N -,
            SYNSEM.LOCAL.SPEC-TO-BARE-N -,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -],
           [SYNSEM.LOCAL.CAT.HEAD cardnum,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LOCAL.CARD-TO-BARE-N -,
            SYNSEM.LOCAL.SPEC-TO-BARE-N -,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
            SYNSEM.LEX - ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].

    
; "fem tusen og femti menn"
numbernoun-plus-coord-card-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -],
           [SYNSEM.LOCAL.CAT.HEAD word-coord,
	    SYNSEM.LOCAL.XCAT.HEAD cardnum,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.XCAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].

    
compound-noun-phrase := rule & basic-head-final &
  [ SYNSEM.LOCAL.CAT.HEAD noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
;    SYNSEM.LEX +, ; rule not used anyway
    ARGS < noun-lexeme &
           [SYNSEM.LOCAL.CAT.HEAD noun,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LEX +],
           [SYNSEM.LOCAL.CAT.HEAD noun,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LEX + ] >,
    C-CONT [ RELS <! compound-rel & [ ARG1 #1,
                                      ARG2 #2 ] !>,
	     HCONS <! !>]].

; "mer intelligent", "like stor"
comparative-spec-a-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY #key,
				 WEAK #wk & -],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #6,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2 & predsort,
;    SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #key, ; LH130713  this line blocks 'litt for Adj', for all adjectives with KEY anonym-k. Outcommenting probably loosens the control on comparative combinations, so uncertain... ALERT
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK #wk,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv & [KEYS.KEY #key],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING +,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

; "mer enn fem meter stor"
morethan2feet-spec-a-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD adjectival & [ DEGREE positive ],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #4,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-close-adv,
                              VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #1 ]>,
                              VAL.COMPS <>],
            SYNSEM.LOCAL.CONT.HOOK.XARG #1,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #8],
           [ SYNSEM.LOCAL.CONT.HOOK.XARG #4,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

; "mer enn fem meter st√∏rre", "mer enn to dusin flere"
morethan2feet-spec-a-cmpar-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #4,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.CONT.HOOK.VARG #7,
    SYNSEM.LOCAL.COORD-RELEASED #coord,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
    SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.DERIVED-HEAD -]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CMPAR-PENDING #9 & +,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-close-adv,
                              VAL.SPEC < [ LOCAL.CONT.HOOK.CMPAR-ARG #1 ]> ],
            SYNSEM.LOCAL.CONT.HOOK.XARG #1,
	    SYNSEM.LOCAL.CMPAR-PENDING #9,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
            SYNSEM.LOCAL.IS-PUNCT -],
           [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative,
;	     SYNSEM.LOCAL.CAT [HEAD cmpar-close-adv],
	     SYNSEM.LOCAL.CONT.HOOK.XARG #4,
             SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #1,
             SYNSEM.LOCAL.CONT.HOOK.VARG #7,
             SYNSEM.LOCAL.COORD-RELEASED #coord,
	     SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
             SYNSEM.LOCAL.CMPAR-PENDING #9,
             SYNSEM.LEX + ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

; removed from the above, without harm
; ,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1


; "to meter lang" "???kommer to dager sent"
measure-np-a-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [ DEGREE positive ], - try to subsume measure-np-dir-phrase
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adj-or-adv & [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
                                               KEYS.KEY takes-sg-spc],
    NON-HEAD-DTR card-cum-adj-mod-phrase & [SYNSEM.LOCAL.CAT.VAL.SPR <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit,
					       BOUNDED +],
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; "to kilometer vestover/ mot vest"
measure-np-dir-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
                                               KEYS.KEY takes-sg-spc],
    NON-HEAD-DTR card-cum-prep-or-adv-mod-phrase & [SYNSEM.LOCAL.CAT.VAL.SPR <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; LH Feb18-06: removed 'NON-HEAD-DTR.SYNSEM.LEX -'
; looks as if this enforces index-id between the two sisters; should not
; "to meter st√∏rre", "to dusin flere"
measure-np-cmpar-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK comp-hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CMPAR-PENDING #10,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit ],
;  careful here - 'adjectival' cuts it down too much... 
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival & [ DEGREE comparative ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
                                               KEYS.KEY measurnoun],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.CMPAR-ARG #4]>,
    C-CONT [ RELS <! measure-out-rel & [ARG1 #3,
                                        ARG2 #4] !>,
             HCONS <! !> ],
    RULE.NOMORE-CARD + ].

; seems redundant, given measure-np-cmpar-phrase
; "to meter mer..."
measure-np-adv-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CMPAR-PENDING #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
					       KEYS.KEY measurnoun],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; for "meget/sv√¶rt stor"
measure-quantword-a-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CONT.HOOK.INDEX #ind,
;				 LOCAL.CONT.HOOK.LTOP #lbl ]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
;    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD.DEGREE #deg]>,
    SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg,
    SYNSEM.LOCAL.DERIVED-HEAD #bool,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #bool,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival & [ DEGREE positive ], ;adjectival, too wide, also covered by qualifadv-card-phrase
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD.DEGREE #deg]>,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CONT.HOOK.INDEX #ind,
;					  LOCAL.CONT.HOOK.LTOP #lbl] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; must allow fullstendig forsvarli
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

;; Alt path for mal-rule. EAA. 30.03.11.
measure-quantword-a-phrase-head-initial := complex-spec-n-phrase-head-initial &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; for "stor nok"; most of the specification replicates complex-spec-n-phrase
measure-a-quantword-phrase := basic-head-spec-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR degreepos-post-spec-word,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! measure-out-rel & [ARG1 #2,
                                        ARG2 #1] !>,
	     HCONS <! !>]].

; for "sv√¶rt stor"
;measure-adv-a-phrase := measure-quantword-a-phrase &
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE positive ] ].

; for "meget stor"  - not activated - perhaps all are adv
;measure-q-a-phrase := measure-quantword-a-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD q ]. 

; "mye/atskillig st√∏rre", "mange/langt flere"
measure-quantword-cmpar-phrase-sup := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #adj & adjectival,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    SYNSEM.LOCAL.CAT.VAL.SPEC #11 & <[LOCAL.CAT.HEAD adjectival]>,
    SYNSEM.LOCAL.CONT.HOOK comp-hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CMPAR-PENDING #10,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2 & predsort,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #adj,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC #11,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #10,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2,
    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9 ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CMPAR-PENDING #10,
					     LOCAL.CONT.HOOK.INDEX #4]>,
    C-CONT [ RELS <! measure-out-rel & [ARG1 #3,
                                        ARG2 #4] !>,
             HCONS <! !> ],
    RULE.NOMORE-CARD + ].

; from 'comparative'
measure-quantword-cmpar-phrase := measure-quantword-cmpar-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative,
				     WEAK - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD q]. ; inst of q, perhaps too narrow - cmpar-reg-adv
measure-quantword-sup-phrase := measure-quantword-cmpar-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE superlative ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr ].
    
; "atskillig st√∏rre", "langt flere"
measure-adv-cmpar-phrase := measure-quantword-cmpar-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr ].

; redundant, and not active - same as measure-quantword-cmpar-phrase
; "mye st√∏rre", "mange flere" - not activated - perhaps all are adv
;measure-q-cmpar-phrase := measure-quantword-cmpar-phrase &
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD q ].

; the WH #9 marking provides the piedpiping effect for "hvem sin gutt
; sitter", but has the consequence that both the interrogative x-
; variable and the gutt-variable carry 'WH +' in the MRS. For
; interpretation, we have to rule that only an 'x WH +' bound by
; 'interrog-q-rel' counts as a 'questioned' variable.


;  & head-final 
general-genitive-phrase-sup := basic-head-spec-phrase & rule. 

; "Olas katt" - Ola #2 (non-head), katt #1
general-genitive-phrase := general-genitive-phrase-sup & head-final &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.BINDING #35,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #1 & [ SORT semsort ],
                                     LTOP #7 ],
    HEAD-DTR.SYNSEM.LOCAL.BINDING #35,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    C-CONT [ RELS <! [ LBL #7,
		       ARG1 #2,
                       ARG2 #1], def-q-rel & [ ARG0 #1,
                                               RSTR #6 ]  !>,
             HCONS <! [HARG #6,
                       LARG #7] !>]].

; LH090416 Enables the same possessive lex-items to serve both pre- and postnominally.
general-genitive-post-phrase := general-genitive-phrase-sup & head-initial &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.BINDING #35,
    SYNSEM.LOCAL.BND-RESP #bnd,
;    SYNSEM.LOCAL.ADJ-SITE-OPEN -, ; '-' blocks "gi gutten min mat"
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #1 & [ SORT semsort ],
                                     LTOP #7 ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #35,
    C-CONT [ RELS <! [ LBL #7,
		       ARG1 #2,
                       ARG2 #1] !>,
             HCONS <! !>]].


poss-general-genitive-post-phrase := general-genitive-post-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    C-CONT.RELS.LIST.FIRST poss-rel  ].



; the six thematic varieties of a genitive ('poss' is
; the 'unmarked' one)
agentive-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT init-und,
    C-CONT.RELS.LIST.FIRST agent-rel ].

agentive-general-genitive-post-phrase := general-genitive-post-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT init-und,
    C-CONT.RELS.LIST.FIRST agent-rel ].

undergoer-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT init-und,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST undergoer-rel  ].

undergoer-general-genitive-post-phrase := general-genitive-post-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT init-und,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST undergoer-rel  ].

actor-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT actor,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST agent-rel ].

actor-general-genitive-post-phrase := general-genitive-post-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT actor,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST agent-rel ].

theme-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT theme,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST undergoer-rel ].

theme-general-genitive-post-phrase := general-genitive-post-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT theme,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST undergoer-rel ].

poss-general-genitive-phrase := general-genitive-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT sort, ;referential-thing,
    C-CONT.RELS.LIST.FIRST poss-rel  ].

relational-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum,
    C-CONT.RELS.LIST.FIRST related-rel  ].
  
relational-general-genitive-post-phrase := general-genitive-post-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum,
    C-CONT.RELS.LIST.FIRST related-rel  ].
  
; ... and the according 8 rules...- not yet for the post-versions LH081412

agentive-genitive-np-phrase := agentive-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

agentive-genitive-posspron-phrase := agentive-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].

undergoer-genitive-np-phrase := undergoer-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

undergoer-genitive-posspron-phrase := undergoer-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].

actor-genitive-np-phrase := actor-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

actor-genitive-posspron-phrase := actor-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].

theme-genitive-np-phrase := theme-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

theme-genitive-posspron-phrase := theme-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].


; NOTE: 
;poss-general-genitive-phrase := general-genitive-phrase & 
;  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT sort, ;referential-thing,
;    C-CONT.RELS.LIST.FIRST poss-rel  ]. - - C-CONT's first EP is where "_possess_rel" gets introduced. Same as for poss-genitive-posspron-phrase.
poss-genitive-np-phrase := poss-general-genitive-phrase &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [DEF +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp].

;LH070416 experm - here the contextual-q-rel and HCONS must be induced in C-CONT. One just has to make sure that the identities of contextual-q-rel and HCONS in old poss-pron-word-sup will carry over.
; NOTE: 
;poss-general-genitive-phrase := general-genitive-phrase & 
;  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT sort, ;referential-thing,
;    C-CONT.RELS.LIST.FIRST poss-rel  ]. - - C-CONT's first EP is where "_possess_rel" gets introduced.  Same as for poss-genitive-np-phrase.

poss-genitive-posspron-phrase := poss-general-genitive-phrase &
  [ SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    HEAD-DTR.SYNSEM [LOCAL.CAT.HEAD comm-noun,
		     LOCAL.CAT.HEAD.DEFINITE -,
		     LOCAL.CAT.HEAD.DEF + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3].

;LH070416 experm - here the definite suffix induces def-q-rel, one just has to make sure that the identities of contextual-q-rel and HCONS in poss-pron-word-sup match
postnom-poss-phrase := poss-general-genitive-post-phrase & 
[ SYNSEM.LOCAL.BND-RESP #3,
  SYNSEM.LOCAL.POST-NOM-POSS-APPLIED +,
;    SYNSEM.LOCAL.CAT.VAL.SPR < [] >, ;"*glade gutten min" is accepted if SPR-requirement is removed. But keeping it rules "gutten min" out.
    SYNSEM.LOCAL.CMPAR-PENDING -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    HEAD-DTR.SYNSEM [LOCAL.CAT.HEAD.DEFINITE +,
		    LOCAL.CAT.HEAD.DEF + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3].

#|
;LH070416 experm - here the contextual-q-rel and HCONS must be induced in C-CONT. One just has to make sure that the identities of contextual-q-rel and HCONS in old poss-pron-word-sup will carry over.
poss-genitive-posspron-phrase := poss-general-genitive-phrase & head-final &
  [ SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    HEAD-DTR.SYNSEM [LOCAL.CAT.HEAD.DEFINITE -,
		    LOCAL.CAT.HEAD.DEF + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
;    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3].

;LH070416 experm - here the definite suffix induces def-q-rel, one just has to make sure that the identities of contextual-q-rel and HCONS in poss-pron-word-sup match
postnom-poss-phrase := poss-general-genitive-phrase & head-initial &
[ SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    HEAD-DTR.SYNSEM [LOCAL.CAT.HEAD.DEFINITE +,
		    LOCAL.CAT.HEAD.DEF + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
;    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3].
|#



relational-genitive-np-phrase := relational-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

relational-genitive-posspron-phrase := relational-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].


; this works, but maybe weekday-spec-rule is sufficient

;;weekday-genitive-np-phrase := basic-head-spec-phrase & head-final & rule &
weekday-genitive-np-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY weekday-noun,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT semsort],
    C-CONT.RELS.LIST.FIRST poss-rel   ].


;;;; appositions

; specific like 'HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +' in order to make sure no adv has
; combined - otherwise "huset bak skogen" gets a parse as apposition

#|
fact-that-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BINDING #6,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [ DEF +,
                                                 KEYS.KEY fact ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #6,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    C-CONT [ RELS <! reside-in-rel & [ARG1 #1,
                                      ARG2 #2] !>,
	     HCONS <! !>]].
|#

fact-that-phrase := head-mod-phrase-simple & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BINDING #6,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [ DEF +,
                                                 KEYS.KEY fact ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #6,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    C-CONT [ RELS <! reside-in-rel & [ARG1 #1,
                                      ARG2 #2] !>,
	     HCONS <! !>]].

; due to OK "Ola leder i sosialkomiteen", only weak requirements on the heads
; LH240116  Currently denying the above, will go only with comma. TODO: 'min glade gutt Ola' parses, but not 'den glade gutt Ola', merkw√ºrdig.
apposition-for-introduction-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.APPOSITION-COMPLEX +,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ COORDINABLE +,
					    DEF bool], ; from '+',
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3, ;perhaps not warranted, but N+N combinations are running wild ...
                                                WH -,
						SORT referential-thing],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,  
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,  
    HEAD-DTR.SYNSEM.LOCAL.PROPERNAME -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR proper-name-word,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF +], ; now it covers 'Moholt studentby'
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3,
                                                              SORT referential-thing],
    ;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [COORDINABLE +,
;                                                  DEF bool,
;						KEYS.KEY plainnoun,
;                                                  BARE bool],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! partitive-rel & [LBL #ltop,
				      ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].

; first name is head
name-plus-name-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CAT.HEAD #propn &  prop-noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    SYNSEM.LOCAL.MUST-APP -,
;    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.PROPERNAME +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG #3, 
						WH -,
						SORT referential-thing],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #propn,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,  
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #propn,
    NON-HEAD-DTR.SYNSEM.LOCAL.PROPERNAME +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG #3,
                                                              SORT referential-thing],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! [LBL #ltop,
		      ARG1 #2,
		      ARG2 #1] !>,
	     HCONS <! !> ]].


firstname-plus-firstname-phrase := name-plus-name-phrase &
 [ SYNSEM.LOCAL.FIRSTNAME +,
   SYNSEM.LOCAL.AGR.PNG.NG #gen,
   HEAD-DTR.SYNSEM.LOCAL.FIRSTNAME +,
   HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #gen,
   NON-HEAD-DTR.SYNSEM.LOCAL.FIRSTNAME +,
   NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #gen,
   C-CONT [ RELS <! [ PRED "same-first-named-individual-as-rel" ] !> ]].

firstname-plus-lastname-phrase := name-plus-name-phrase &
 [ SYNSEM.LOCAL.FIRSTNAME -,
   HEAD-DTR.SYNSEM.LOCAL.FIRSTNAME +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
   NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   NON-HEAD-DTR.SYNSEM.LOCAL.FIRSTNAME -,
   C-CONT [ RELS <! [ PRED "same-first-named-individual-as-rel" ] !> ]].

lastname-plus-lastname-phrase := name-plus-name-phrase &
 [ SYNSEM.LOCAL.FIRSTNAME -,
   HEAD-DTR.SYNSEM.LOCAL.FIRSTNAME -,
   NON-HEAD-DTR.SYNSEM.LOCAL.FIRSTNAME -,
   C-CONT [ RELS <! [ PRED "same-last-named-individual-as-rel" ] !> ]].





enumeration-by-identity := verb-word & lbl-ltop-lex-item & 
  [ SYNSEM arg2-comps-synsem & 
	   [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX ref-ind ] >],
	     LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
	     LKEYS.KEYREL.ARG1 #1,
	     LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
	     LOCAL.CONT.HCONS <! !>],
    EXTRACTED-FROM -].






enumeration-by-card-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY regnoun],;plainnoun
;    SYNSEM.LOCAL.CAT.HEAD noun & [ DEF -],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF bool, ; from '-' - missed genitival nouns as head
					    DEFINITE -],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3, ;perhaps not warranted, but N+N combinations are running wild ...
                                                WH -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [COORDINABLE +,
                                                  DEF bool,
						KEYS.KEY name-of-card,
                                                  BARE bool],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].

; mandag ettermiddag[head]
enumeration-by-day-and-daytime-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY daytime-noun],
;    SYNSEM.LOCAL.CAT.HEAD noun & [ DEF -],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF -,
;					    BARE +,
					    DEFINITE -,
					    KEYS.KEY daytime-noun],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3, ;perhaps not warranted, but N+N combinations are running wild ...
                                                WH -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [COORDINABLE +,
                                                  DEF -,
						  KEYS.KEY weekday-noun,
                                                  BARE +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <!  [PRED "_has-as-subpart_rel",
		       ARG1 #2,
                       ARG2 #1] !>,
	     HCONS <! !>]].



; adjoing a comma-surrounded apposition to the head noun. Has non-restr function
; due to OK "Ola leder i sosialkomiteen", only weak requirements on the heads

rightmod-nonrestr-apposition-phrase := head-mod-phrase-simple & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3,
                                       WH -],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR comma-leftmod-nonrestr-apposition-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [DEF bool],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].



; adjoing an  apposition-np with comma to the right to the noun. Has restr function

rightmod-restr-apposition-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.APPOSITION-COMPLEX +,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [ DEF + ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR comma-rightmod-app-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].



; head-subject...
#|
;;; BACKUP for mal rules

head-subject-phrase-sup := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK #hook,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   EXTRACTED-FROM #10,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   SYNSEM.NON-LOCAL #18,
   SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
					       WH-COMPLETE -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.EXTRACTED-FROM #10,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
   HEAD-DTR.SYNSEM.NON-LOCAL #18,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I -,
   NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
   NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   C-CONT.HOOK.INDEX.SF prop,
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].


|#

; commented out ;   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop, since '?' and '!' often go with declarative word order. SF-specification should probably only come with the marked cases, i.e., the imperative rule and head-subject-interr-phrase.
; for some reason, 'NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>' had been commented out, probably in order to avoid some wild extraparses. But needed, to avoid dem-words being accepted without a noun.
head-subject-phrase-super := basic-head-subj-phrase-sup & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK #hook,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
;   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   EXTRACTED-FROM #10,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   SYNSEM.NON-LOCAL #18, ;; MHS 190713 This is a daughter of head-valence-rule.
   SYNSEM.LOCAL.ADJ-SITE-OPEN -,
   SYNSEM.LOCAL.IS-PUNCT -,
   SYNSEM.LOCAL.HEAD-SUBJ-APPLIED +,
   SYNSEM.LOCAL.WH-EXTRACTION-APPLIED #whextr,
;   SYNSEM.LOCAL.BND-RESP #bndresp,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
   SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
   HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
   HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
;   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
;   HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
HEAD-DTR.INFLECTED +,
   HEAD-DTR.EXTRACTED-FROM #10,
   HEAD-DTR.SYNSEM.LOCAL.WH-EXTRACTION-APPLIED #whextr,
HEAD-DTR.SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
;   HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -, ; LH280118 again deactivated. The 'connect' rules see to that SLASH is empty. LH170416 reactivated - to avoid subject combining with VP starting with 'og'; LH240116: restriction correct to have, but to fake apposition with comma, as in "Ola, gutten, ...", the restr can be commented out - - all the comma-rules surrounding apposition seem to be abgeschaltet, and until reactivated, thus 
;   HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
   NON-HEAD-DTR.SYNSEM.LOCAL.XLBL #2,
   HEAD-DTR.SYNSEM.NON-LOCAL #18,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>, ; for maten til barna sover
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, ; Experiment only
   NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I -,
   NON-HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
   NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;   C-CONT.HOOK.INDEX.SF prop,
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].


head-subject-phrase-sup := head-subject-phrase-super & basic-head-subj-phrase &
[ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -].

head-subject-phrase-simple := head-subject-phrase-super &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TRANSPAR bool, ; '-' rules out '√• l√∏pe gagner meg'
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ ACCUSATIVE - ]].  ;, ; there is one construction which wants this as '+' - 'en mann √• fort√¶re sover', where identity through the relative requires full head identity. Loosened that, to only require expletive id or not - not sure if that was the main purpose ...
                   ;                      KEYS.KEY adhoc-norm ]].

;LH041015  Removed 'SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-comm', because that prevents 'jeg vet hva du sa'.
head-subject-phrase := head-subject-phrase-simple & head-subject-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE -], ; -
;   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   SYNSEM.LOCAL.NEED-Q-MARK -,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ]].

head-subject-yn-phrase := head-subject-phrase-simple & head-subject-phrase-sup &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.NEED-Q-MARK +,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE -,
					       MAIN-CL +],
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH - ]].


#|

head-subject-wh-maincl-phrase := head-subject-phrase-simple & head-subject-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD.DECL -,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE +,
					       INV -,
					       MAIN-CL +,
					       WH-MOVED -],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH + ],
   NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-SOM +, ; a constraint enforcing the presence of "som". There is "jeg vet hva hvem har spist", which is then ruled out: it's marginal - we say that by "jeg vet hvem som har spist hva" - and we then let the malgrammar accept "jeg vet hvem kommer", which a grammar tutorial definitely should not accept.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.CAN-MAIN-CLAUSE +]. ; to prevent "hvem som snorker" as main clause (see 'hvem-som' in lex_close).
|#

head-subject-wh-maincl-phrase := head-subject-phrase-simple & head-subject-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD.DECL -,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE +,
					       INV -,
					       MAIN-CL +,
					       WH-MOVED -],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH + ],
;   NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-SOM +, ; a constraint enforcing the presence of "som". There is "jeg vet hva hvem har spist", which is then ruled out: it's marginal - we say that by "jeg vet hvem som har spist hva" - and we then let the malgrammar accept "jeg vet hvem kommer", which a grammar tutorial definitely should not accept.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.CAN-MAIN-CLAUSE +]. ; to prevent "hvem som snorker" as main clause (see 'hvem-som' in lex_close).


head-subject-wh-subord-phrase := head-subject-phrase-simple & head-subject-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD.DECL -,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #bool,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE +,
					       INV -,
					       MAIN-CL -,
					       WH-MOVED -],
   HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING -,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH + ],
   NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-SOM +, ; a constraint enforcing the presence of "som". There is "jeg vet hva hvem har spist", which is then ruled out: it's marginal - we say that by "jeg vet hvem som har spist hva" - and we then let the malgrammar accept "jeg vet hvem kommer", which a grammar tutorial definitely should not accept.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.CAN-MAIN-CLAUSE -]. ; to prevent "hvem som snorker" as main clause (see 'hvem-som' in lex_close).




;NON-HEAD-DTR head-subjfiller-subord-wh-phrase
    
head-indirwhquest-subjwh-subject-phrase := head-subject-phrase-sup &
  [ NON-HEAD-DTR head-subject-wh-subord-phrase & [SYNSEM.LOCAL.CAT.HEAD.DECL -,
					   SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].

head-indirwhquest-objwh-subject-phrase := head-subject-phrase-sup &
  [ NON-HEAD-DTR head-filler-subord-wh-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].


;without message:

;; "(mann) som || kommer"

head-relative-subject-phrase := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #4,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                     DECL +,
                                     MAIN-CL -,
				     WH-COMPLETE +,
				     WH-MOVED -],
   SYNSEM.LOCAL.REL-CL-SOM-INIT +,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV - ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR subj-relpron & [RESUMPTIVE - ],
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
  NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD head & [ ACCUSATIVE - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   C-CONT [ RELS <!  !>,
            HCONS <!  !> ] ].

; gutten [[hvis katt] [sover]] ...:
head-wh-relative-subject-phrase := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #4,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                     DECL +,
                                     MAIN-CL -,
				     WH-COMPLETE +,
				     WH-MOVED -],
   SYNSEM.LOCAL.REL-CL-SOM-INIT +,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV - ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR poss-genitive-posspron-phrase,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #4, ; "hvis" in "hvis hund sover"
  NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD head & [ ACCUSATIVE - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   C-CONT [ RELS <!  !>,
            HCONS <!  !> ] ].

; for 'hvem kommer?'  (inevitably, "hest kommer" can then undergo this rule)
head-subject-interr-phrase := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CAT.HEAD.DECL -,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ DISC-MOVE question ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
					       WH-COMPLETE -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RESUMPTIVE -,
   NON-HEAD-DTR.RULE card-ok,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH + ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ ACCUSATIVE -,
                                               KEYS.KEY adhoc-norm  ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP <>,
   C-CONT.HOOK.INDEX.SF ques,
   C-CONT [ RELS <!  !>,
            HCONS <!  !> ] ].


;;;;;;;
head-resumptsubject-interr-phrase := basic-head-subj-phrase-super & head-final & rule & 
  [SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                      MAIN-CL -,
				      WH-COMPLETE + ],
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.CONT.HOOK.XARG #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   EXTRACTED-FROM #16,
   SYNSEM.NON-LOCAL.SLASH 1-dlist & [ LIST < [ CAT.HEAD nom,
					       CONT.HOOK.INDEX #ind ] > ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
 ;  HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                               MAIN-CL - ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.EXTRACTED-FROM #16,
   HEAD-DTR.SYNSEM.NON-LOCAL.SLASH 0-dlist & [ LIST < > ],
   NON-HEAD-DTR som-resumpt-word,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #12,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind & ref-ind & [ WH + ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD rel-pron & [ ACCUSATIVE -,
                                                   KEYS.KEY som-subjgap  ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].


;;;;;;
;;; ALTERED for mal rules

head-invertsubject-decl-phrase-super := another-basic-head-subj-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #3 & list,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #30,
;    SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV + ],
    SYNSEM.LOCAL.CONT.HOOK #40,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
;    SYNSEM.NON-LOCAL.SLASH #7,
    SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    EXTRACTED-FROM #bool,
    SYNSEM.VAL-CLASS #vc,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL +,
					        WH-COMPLETE -], 
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #30,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #40,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.INFLECTED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    HEAD-DTR.EXTRACTED-FROM #bool,
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ ACCUSATIVE -,
                                                   KEYS.KEY adhoc-norm,
						   RELATIVPRON -,
						   EXPLETIVE #expl ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-SUBJ-V-INVERTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.MUST-APP +,
;    NON-HEAD-DTR.FRONT-TO-FILL #ff & -, ;no wh-mov out of subject, esp not inverted
;    FRONT-TO-FILL #ff,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].


head-invertsubject-decl-phrase-simple-sup := head-invertsubject-decl-phrase-super &
[ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV + ],
  SYNSEM.LOCAL.INV-DECL-PRECARIOUS +, 
;  FRONT-TO-FILL +, ;; will be overridden by head-filler and adv-mod-front-vp-phrase, and 'conceiled' by correlative-inv rule. To prevent 'kommer han' from being accepted as a freestanding declarative clause. As for INV+, the mal-counterpart has -
;  FRONT-TO-FILL bool, ;; MHS 060813 Temporary change. This needs to be moved down the hierarchy.
  HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL bool ].; from '+', to allow spec as '-' in correlative 'sover du, kommer jeg'; ,
;HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>


head-invertsubject-decl-phrase := head-invertsubject-decl-phrase-simple-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT non-pron-discbnd ].


head-clit-invertsubject-decl-phrase := head-invertsubject-decl-phrase-simple-sup &
 [ SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   SYNSEM.LOCAL.ADJ-SITE-OPEN +,
   SYNSEM.LOCAL.CLIT-PRON-CONFIRMED -,
   HEAD-DTR.SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   NON-HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CTXT pron-discbnd ].


; without message

; HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN + was in order to reduce ambig with finite main verb fronting - non-fronting
head-invertsubject-interr-phrase-sup := another-basic-head-subj-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
   SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL +,
                                       INV +,
                                       DECL -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #3,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
 ;    EXTRACTED-FROM #bool & +,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.VAL-CLASS #valclass,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.VAL-CLASS #valclass,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL +,
                                                INV +,
                                                DECL -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    HEAD-DTR.INFLECTED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
;    HEAD-DTR.EXTRACTED-FROM #bool,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD poss-subj-head & [ ACCUSATIVE -,
                                                          KEYS.KEY adhoc-norm,
							  RELATIVPRON -   ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>, ; was commented out - not clear why
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist, ; was commented out - not clear why - doch: prevents "hva fort√¶rer du for √• snorke?"
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH - ],; rules out "ig√•r kom ikke hvem", perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-SUBJ-V-INVERTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    C-CONT [ RELS <! !>,
            HCONS <! !> ] ].

;;;;;;;;;;

; old version- blocks "ser gutten'a?" and "ser gutten ofte Ola?"
;head-invertsubject-interr-phrase := head-invertsubject-interr-phrase-sup &
;  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
;    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT non-pron-discbnd ].

; ADJ-SITE-OPEN -  blocked "har gutten aldri kommet", so has been relaxed
head-invertsubject-interr-phrase := head-invertsubject-interr-phrase-sup &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN bool,
;    SYNSEM.LEX -, ; requires changing the main type to neutral regarding phrase synsem - concerns avoiding "kommer senere Ola?" Same for declarative inversion. TODO
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT non-pron-discbnd ].

head-clit-invertsubject-interr-phrase := head-invertsubject-interr-phrase-sup &
 [ SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   SYNSEM.LOCAL.ADJ-SITE-OPEN +,
   SYNSEM.LOCAL.CLIT-PRON-CONFIRMED -,
;   SYNSEM.LEX +,; requires changing the main type to neutral regarding phrase synsem - concerns avoiding "kommer senere Ola?" Same for declarative inversion. TODO
   HEAD-DTR.SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
   NON-HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CTXT pron-discbnd ].


;head-pero-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule & 
;  [ SYNSEM.LOCAL.CAT.HEAD connect ].

; the BOUNDED restriction means that in ditrans, the objects have to
; agree in boundedness, excluding "gi Ola penger"
; verb-all, to accommodate copula nom 
;SYNSEM.NON-LOCAL #5, 
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
;SYNSEM.LOCAL.WAIT-BND-RESP #resp,
;HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp

head-verb-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & verb-all,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED #2 & bool,
    SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    SYNSEM.LOCAL.HAS-WH-MOVED #hm,
;    EXTRACTED-FROM #extracted-from,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ARG-S #arg-s,
    SYNSEM.LOCAL.BND-RESP #resp,  ;this identity blocked 'det setter seg en gutt', forcing collision in gender between 'det' and 'gutt' due to seg bound to gutt, by the subtype of this rule. Instead we lose the semantics of 'han ga seg selv seg selv', but we have to live with that...
    SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    SYNSEM.LOCAL.ARG-S #arg-s, 
    SYNSEM.VAL-CLASS #vc,
    SYNSEM.NON-LOCAL.SLASH #slash,  ; this just a desperate attempt...; MHS 070713 This kind of re-entrancy of SLASH values shouldn't occur. (I had commented out this re-entrancy the day before yesterday, as well as remarking that these "tricks" shouldn't be used, but it's been somehow reverted on the SVN, or so it would seem. )
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.ARG-S #arg-s & list,
    HEAD-DTR.SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
;    HEAD-DTR.EXTRACTED-FROM #extracted-from,
;    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.ARG-S #arg-s, 
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ACCUSATIVE +,
					EXPLETIVE -],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [BOUNDED #2],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #hm,
;    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,  ; too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-ONLY - ].

; note funny asymmetry here...:
;head-verb-reg-comp-phrase := head-verb-comp-phrase-sup &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head ].

; ,
;                                              ANAPH-TYPE [REFL-II +]
; NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT referential-thing],

; drop NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun,
;    SORT referential-thing - to allow "han kaster fire"

#|
head-verb-reg-comp-phrase := head-verb-comp-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head,    
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3 & [FIRST [ANAPH-INDX #1]],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ]].

head-verb-comp-phrase := head-verb-reg-comp-phrase &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].
|#

; not just for NPs, but also PPs as PREDICs; not any more - head-verb-prepcomp-phrase are for these
head-verb-comp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.WH-ISLAND #bool, ;LH29092021
    SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    HEAD-DTR.SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND #bool,
;    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ;cannot be used, blocks 'jeg ser 
;  ni av guttene', where 'ni' currently undergoes card-to-bare-n
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal-or-connect-n & [ACCUSATIVE +],; this outcomm excludes cardinals and quantifiers - unless these are projected to N ...
;    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],    
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],; han m√• hit
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind, ;LH200713: excluding clauses as objects for this rule - by now, all clause-types have their dedicated rules. At least try this ...with massifcentral_200713
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-INTERJECTION -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-COMBINED-BY-V-COMP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].; from '+', temprary to make longdistref work; LH240713 back to +, to avoid 'unner han ikke seg den', where seg combines by this rule. 
 
head-verb-lightverb-comp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #lvc,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.GOVERNOR <[LOCAL.CAT.HEAD.KEYS.KEY #lvc]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.LVC-GVRNOR.LOCAL.CAT.HEAD.KEYS.KEY #lvc,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +,
						  KEYS.KEY fact],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind, 
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-INTERJECTION -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].
 
head-gapping-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & word-coord,
    SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    SYNSEM.LOCAL.HAS-WH-MOVED #hm,
;    EXTRACTED-FROM #extracted-from,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
;    HEAD-DTR.EXTRACTED-FROM #extracted-from,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.GAPPING +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +,
						  EXPLETIVE -],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #hm,
    NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-ONLY - ].

head-gapping-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & word-coord,
    SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    SYNSEM.LOCAL.HAS-WH-MOVED -,
    SYNSEM.LOCAL.CAT.VAL.COMPS #21,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    SYNSEM.LOCAL.WH-EXTRACTION-APPLIED -,
    SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #21,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.GAPPING +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.WH-EXTRACTION-APPLIED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED +],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-EXTRACTION-APPLIED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND +,
    NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-ONLY -,
    NON-HEAD-DTR.SYNSEM.LEX - ].

head-gapping-subj-phrase := another-basic-head-subj-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & word-coord,
    SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    SYNSEM.LOCAL.HAS-WH-MOVED #hm,
;    EXTRACTED-FROM #extracted-from,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    SYNSEM.LOCAL.CAT.VAL.COMPS #26,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init, 
    SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #26,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
;    HEAD-DTR.EXTRACTED-FROM #extracted-from,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
 ;   HEAD-DTR.SYNSEM.LOCAL.GAPPING +, 
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom & [ACCUSATIVE -,
					      EXPLETIVE -],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #hm,
    NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-ONLY - ].

head-gapping-subj-plus-obj-phrase := head-gapping-subj-phrase &
[ SYNSEM.LOCAL.CAT.VAL.COMPS cons ].

head-gapping-subj-plus-obl-phrase := head-gapping-subj-phrase &
[ SYNSEM.LOCAL.CAT.VAL.ICOMPS cons ].

head-verb-allquant-comp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant & [ACCUSATIVE +],    
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].
 
head-verb-prepcomp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL.SLASH #nl, ; culpameaLH310721
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY prim-mod],    ; LH28092018 from ultra. back to ultra, to get 'synes meg som en kandidat'
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],; han m√• hit
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LEX -, ; to block invisible extraction from the PP; the slash mech doesn't seem able to catch this, allowing the effect to pass tracelessly up
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #nl ]. ; culpameaLH310721

head-verb-som-or-for-comp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY prim-mod],    ; LH28092018 from ultra
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],; han m√• hit
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].

head-verb-clit-comp-phrase-sup := head-verb-comp-phrase-sup &
 [ SYNSEM.LOCAL.CLIT-SITE-OPEN +,
;   SYNSEM.LOCAL.ADJ-SITE-OPEN +,
   HEAD-DTR.SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],    
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron & [KEYS.KEY persprn],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH -,
                                              SORT referential-thing],
   NON-HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CTXT pron-discbnd ].

; for "seg" to be bound outside minimal VP
head-verb-reflclit-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 & [FIRST [ANAPH-TYPE [REFL-II -]]],
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ BOUND +,
                                        REFL-I +,
                                        LEX-TAME - ]].

#|
head-verb-reflclit-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3 & [FIRST [ANAPH-TYPE [REFL-II -]]],
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ BOUND +,
                                        REFL-I +,
                                        LEX-TAME - ]].
|#

; for lexically bound reflexives
;LH020216  Emergency solution: see roots.tdl and trans-arg1-2refl-synsem
head-verb-tame-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.VAL-CLASS #vc,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ BOUND +,
                                        REFL-I +,
                                        REFL-II -,
                                        LEX-TAME + ],
    NON-HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    NON-HEAD-DTR.SYNSEM.LEX +].

#|
head-verb-tame-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3 & [FIRST [ANAPH-TYPE [REFL-II -]]],
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ BOUND +,
                                        REFL-I +,
                                        REFL-II -,
                                        LEX-TAME + ]].
|#

; SYNSEM.LOCAL.CLIT-PRON-CONFIRMED - means that only s-adv or other 'first-after-finite-verb' can sanction the use of this rule. To eliminate ambiguity when there is no 'disambiguating' adverb
head-verb-pronclit-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED bool, ; from '-'
    SYNSEM.LOCAL.CAT.HEAD.MAIN-CL +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ REFL-I -,
                                        REFL-II -,
                                        LEX-TAME - ]].


; impossible/hard to restrict head-verb-comp-rule to not cover the same constructions, so commented this out in rules.tdl
head-verb-meas-comp-phrase := head-verb-comp-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measurnoun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT measure-unit ].


head-verb-expl-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT #3,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.CAT.VAL.COMPS 1-list,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD expl-pron,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; to start with a
; restr ADJ-SITE-OPEN - on NON-HEAD-DTR  in order to prevent
; "*gutten vil komme ikke". But it also prevents "jeg s√• gutten ikke komme",
; with subord negation, which should be allowed. So, deleted the restr
;LH181215 But allowing 'jeg vil spise fisken ikke' is far worse, so restriction reinstantiated
;SYNSEM.NON-LOCAL #4,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4

head-verb-verbal-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.HIGHEST-V-PROJ #hip,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ #hip,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT +,
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +, ; it's combination with s-adv that should have such effects
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    EXTRACTED-FROM #10,
    NON-HEAD-DTR.EXTRACTED-FROM #10,
;    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -, ; ; ok: kan danse og synge
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, ; for "vi lot fisken fort√¶re" - the special rule (with infix 'sangen-synge' in rule name) enjoys the missing restriction, whereas for all other sub-rules the restriction is reinstated.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +].


head-verb-bareinfin-comp-phrase-sup := head-verb-verbal-comp-phrase &
  [ 
;    SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
;    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    SYNSEM.LOCAL.BND-RESP #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT trans-ncomps-secpred-cat,  ; LH29092018so that 'jeg lot(ditr) ham komme' does not use the rule
;    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,; ok: kan danse og synge
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
    ;    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE non-finite, ;infin,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE - ].

head-verb-bareinfin-comp-phrase := head-verb-bareinfin-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <> ].

head-verb-bareinfin-la-sangen-synge-comp-phrase := head-verb-bareinfin-comp-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY la-sangen-synge-vb,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT trans-nosecpred-empty-icomps-cat ].


head-verb-barefinite-comp-phrase := head-verb-verbal-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR head-subject-phrase,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DECL +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE - ].


head-auxverb-bareinfin-comp-phrase := head-verb-verbal-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
;    SYNSEM.LOCAL.CONT.HOOK #hook,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    SYNSEM.LOCAL.COMPS-BEGUN +,
;    SYNSEM.LOCAL.ADJ-SITE-OPEN #sop,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-aux & [INV -],
;    HEAD-DTR.SYNSEM.LEX +, ; it has to apply to '[vil ikke] komme', which of course makes the head dtr LEX -
;    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #sop,
    NON-HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ -,
    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,; out, to allow 'hun skal kose seg'
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -, ; ok: kan danse og synge
    NON-HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE -  ].

head-auxverb-invert-bareinfin-comp-phrase := head-verb-verbal-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-aux & [INV +],
    HEAD-DTR.SYNSEM.LEX -, ; 'skal Ola hoste?' in inversion not lex+
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
;    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,; out, to allow 'n√• skal hun kose seg'
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE -  ].

; subsumes perf participle and passive participle, and also complex passive
head-verb-perf-comp-phrase := head-verb-verbal-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.WAIT-BND-RESP #3,
    SYNSEM.LOCAL.CONNECT-PENDING #cp,
    FRONT-TO-FILL #ff,
;    HEAD-DTR.SYNSEM.LEX +,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-aux,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>, ; what if something extracted
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #cp,
    NON-HEAD-DTR.FRONT-TO-FILL #ff ].

    
head-verb-indirwhquest-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN #op,
;    SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN bool,
    SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN #cop,; out, otherwise blocking 'han vil fortelle oss hvorvidt han hoster'. But we then also allow '*han vil fortelle oss ikke hvorvidt han hoster'
;    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
;    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #3,
;    SYNSEM.LOCAL.HAS-WH-MOVED #hm,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD <>], ;for the gapping 'og' .
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #op,
;    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN #cop,
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
 ;   HEAD-DTR.SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    EXTRACTED-FROM #10,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL -,
					 DECL - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +, ;blocked all hvorvidt-complement constructions. The feature 'WH' concerns only constituents, it seems. 'SF ques' is what specifies clausal interrogative.
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT +,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].

head-verb-indirwhquest-y-n-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp ].

; for copula as head the construction type is 'sp√∏rsm√•let er om han kommer'
head-verb-indirwhquest-subjwh-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED -,
						   WH-COMPLETE +],
    NON-HEAD-DTR.SYNSEM.LEX -].;filler-subord

; for copula as head the construction type is 'sp√∏rsm√•let er om han kommer'
head-verb-indirwhquest-objwh-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
;    NON-HEAD-DTR.SYNSEM head-filler-subord-wh-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +],
    NON-HEAD-DTR.SYNSEM.LEX - ]. ;;from 'WH-COMPLETE +' - lost 'vet hva han liker'+

; for copula as head the construction type is 'sp√∏rsm√•let er om han kommer'
head-verb-indirwhquest-advwh-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR adv-interr-mod-front-subordcl-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LEX - ]. ; adv-interr-mod-front-subordcl-phrase ].



; when doing copulas, it should perhaps promote AGR-values from the adj.
; But, with the abs-adj treatment, where "fint" in e.g. "det er fint at du kom"
; is lexically neuter, no need for phrasal enforcement arises.
head-verb-adj-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
 ;   SYNSEM.NON-LOCAL #1, ;; MHS 190713
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #37,
;    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
;    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
;    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -].
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
 ;   NON-HEAD-DTR.SYNSEM.NON-LOCAL #1 ].

#|
head-verb-adj-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #1 ].
|#

head-verb-prep-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD verb & [KEYS.KEY #key],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
  ;  SYNSEM.NON-LOCAL #2, ;; MHS 190713
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.WAIT-BND-RESP #wresp,
    EXTRACTED-FROM #5,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [KEYS.KEY #key],
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #keys]],...>,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #wresp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                     KEYS.KEY #keys],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].

;head-verb-preprais-comp-phrase := head-verb-prep-comp-phrase-sup &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY rais] ].

; tentatively commenting these rules away in rules.tdl. They seem to always be paralleled by more general rules
head-verb-prepsit-comp-phrase := head-verb-prep-comp-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit1] ].
; "Jon lurer p√• hva som skjer"
; having suspended prep-indirwhquest-word, this rule is non-operative
;head-verb-prepindirwhquest-comp-phrase := head-verb-prep-comp-phrase-sup &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY indirqu] ].


; extending it to cover 'han er fra Kairo'
head-cop-prepadv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY index-sit1],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; previously NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY adv-selct] -
; changed to NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY dir], to make
; more inclusive
; differs from head-verb-particleshift-comp-phrase in NOT requiring one COMP 
; more. Difference could be sharpened - "sparke tilbake ballen" gets two
; parses - but if we do, we lose "gutten ser ut til √• komme"
head-verb-advparticle-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.NON-LOCAL.SLASH #slsh, ; culpameaLH310721
    SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    HEAD-DTR.SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY pcl],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slsh ]. ; culpameaLH310721

; assume KEYS.KEY index-sit is too strict: we also want "ha Ola tilbake"
; trying 'SELECTED -' instead of orig '+'
; MOD <> in order to avoid preps designed for modifying an adverb or prep
; but that lost us all the Path'-cases and shifted particles
;,
;						      MOD <[LOCAL.CAT.HEAD verb-all]>
; NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv -> adv. 
; before that, comment it out, since head-verb-comp-rule seems to cover all
head-verb-adverb-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS #20,
    SYNSEM.LOCAL.CAN-CMB-FIXPT #fp,
    SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR #nfp,
    SYNSEM.NON-LOCAL #nl,
    SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS.REST #20,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT #fp,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR #nfp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [SELECTED -,
					      MOD <[LOCAL.CAT.HEAD verb-all]>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl].

head-verb-mannadverb-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD.KEYS.KEY fct-spec]>,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [KEYS.KEY advoblvb],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY adv-m,
                                              SELECTED +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1].

; this rule overlaps too much with head-verb-adverb-comp-phrase, so will be for the time being commented out.
; differs from head-verb-advparticle-comp-phrase in requiring one more COMP
; Difference should be sharpened - "sparke tilbake ballen" gets two parses
head-verb-particleshift-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pathconsumpt-dir,
                                                  SELECTED + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

head-verb-ppshift-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].


head-verb-som-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.CLIT-PRON-CONFIRMED #conf,
    SYNSEM.NON-LOCAL #nl,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED #conf,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; by     SYNSEM.LOCAL.BND-RESP #2,  we manage to catch reflexives that fail to have a binder. Of course, by this point, they should have been bound anyway, but if we don't mediate the track upwards, there is no arrest made.
; However, with this, "det hjelper √• sette seg" fails to parse, because 'seg', being ref-ind, fails to unify with the expletive 'det', as the mechanics dictate. TODO is to devise a way of releasing the reflexive at the point when absinf combines, but that we don't have yet. Hence we get a lot of overgenerations of non-bound reflexives. Short term solution: create a special version of the present rule for absinf-combination.
;SYNSEM.NON-LOCAL #4,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #4

 head-complementizer-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    SYNSEM.LOCAL.WAIT-BND-RESP #2,
;    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    EXTRACTED-FROM #6,
;    SYNSEM.NON-LOCAL #nonlocal,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comp & [INV #inv],
    NON-HEAD-DTR.EXTRACTED-FROM #6,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING -,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       ICOMPS <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV #inv,
						   WH-COMPLETE -],
;    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nonlocal,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init ].

head-complementizer-comp-fin-phrase := head-complementizer-comp-phrase-sup & 
  [ SYNSEM.LOCAL.BND-RESP #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.NEED-Q-MARK -,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2 ].

head-complementizer-comp-absinf-phrase := head-complementizer-comp-phrase-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #varg,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
						   DECL +,
						   KEYS.KEY infinit-comp-arb ]],
    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    NON-HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg].

head-complementizer-comp-equinf-phrase := head-complementizer-comp-phrase-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #varg,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
						   DECL +,
						   KEYS.KEY infinit-comp-eq ]],
    HEAD-DTR.SYNSEM.LEX +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #varg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>].

;SYNSEM.NON-LOCAL #4,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
; gave too many parses with multiple PPS:   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adj

head-complementizer-adj-or-prep-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [WEAK -], ;, KEYS.KEY propt
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

head-complementizer-derivedadj-or-prep-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [WEAK -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>, 
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD +  ].

head-complementizer-noun-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ list,
  ;  SYNSEM.NON-LOCAL #4, ;; MHS 190713
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comp,
    HEAD-DTR.SYNSEM.LEX +,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.INFLECTED +,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD - ].

;NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #3,
    
; NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp  since head-verb-comp-rule takes care of that-clauses  - - no more
;SYNSEM.NON-LOCAL #4,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
  ; SYNSEM.LOCAL.BND-RESP #2,
  ;  SYNSEM.LOCAL.WAIT-BND-RESP #3

head-verb-inf-or-s-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
   [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.VAL-CLASS #val,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAN-CMB-FIXPT #fp,
    SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR #nfp,
    SYNSEM.NON-LOCAL.SLASH #4,
     HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
 ;   HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
 ;   HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #3,
    HEAD-DTR.SYNSEM.VAL-CLASS #val,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT #fp,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR #nfp,
    NON-HEAD-DTR.INFLECTED +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [ DECL bool,
;						     KEYS.KEY comptizer ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative],
   ; NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #4,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
     NON-HEAD-DTR.SYNSEM.LOCAL.UNARY-INFIN-REL - ]. 

head-verb-complementized-s-comp-phrase := head-verb-inf-or-s-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [ DECL +,
						     KEYS.KEY comptizer ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
   NON-HEAD-DTR.SYNSEM.LEX -].

; for 'jeg ber henne + komme'
head-verb-inf-or-v-comp-phrase := head-verb-inf-or-s-comp-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL +,
						   IMPERATIVE -] ]. ; DECL+ in order to not double indirquest-rule

head-verb-copula-inf-or-v-comp-phrase := head-verb-inf-or-s-comp-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].



; "hun sier ja"
head-verb-interjct-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
 ;   SYNSEM.NON-LOCAL #4, ;; MHS 190713
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD interjection & [ KEYS.KEY interjct],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD hortative],
 ;   NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

; give a SORT value to those verbs that undergo this rule - "kaste
; til Ola" - and include this feature also in this rule, to
; exclude v√¶re_3 from undergoing it.
head-verb-2comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS olist,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

; actually not used Apr 23
head-cop-adj-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

head-cop-prep-adv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; used to have TENSE infin, perhaps for tough-adj, but must also accommodate
; "uvistt hvorvidt han kommer", where the CP is present/past
;SYNSEM.NON-LOCAL #1,  - in again ...
;, NON-HEAD-DTR.SYNSEM.NON-LOCAL #1
; ;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [TRANSPAR -], outcomment loses 'uvisst hvem som ...'  but leaves in some unwanted inf-comps instead
head-adjective-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    SYNSEM.NON-LOCAL #1,
    SYNSEM.LOCAL.CAT.POSTHEAD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,  ; not adj-reg - this is used for tough adj etc
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj-selct,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.N-COMB-PENDING -,
    NON-HEAD-DTR.INFLECTED +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE tense ].

head-adjective-adv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    SYNSEM.LOCAL.CAN-MODIFY -,
    SYNSEM.LOCAL.CAT.POSTHEAD +,
    SYNSEM.NON-LOCAL #nl,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv & -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.N-COMB-PENDING -,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl ].

head-adjective-np-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    SYNSEM.LOCAL.CAT.POSTHEAD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv & -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.N-COMB-PENDING -,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT - ].


head-prep-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & prep-ultra & [ KEYS.KEY actv-prep ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.IDIOMOD #2,
;    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.CAT.QVAL #71,
    SYNSEM.LOCAL.XCAT #81,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CAN-CMB-V #72,
    SYNSEM.LOCAL.modification-performed #MP,
;    EXTRACTED-FROM #10, ;; MHS 070713 Desperate measure.
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    HEAD-DTR.SYNSEM.LEX +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #71,
    HEAD-DTR.SYNSEM lex-synsem & [IDIOMOD #2],
;    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.XCAT #81,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V #72,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.modification-performed #MP,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD poss-subj-head & [ACCUSATIVE +,
							 EXPLETIVE -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
	NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,	; EAA. Added to avoid problems in NorMal. LH believes this to be problematic. LH. Yes, he does, we lose "..synge for √• gjenopprette livsgleden.  Made a new rule, see below  
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

head-prep-for-√•-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.IDIOMOD #2,
;    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.CAT.QVAL #71,
    SYNSEM.LOCAL.XCAT #81,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CAN-CMB-V #72,
    SYNSEM.LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #71,
    HEAD-DTR.SYNSEM lex-synsem & [IDIOMOD #2],
;    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.XCAT #81,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V #72,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;	NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,	; EAA. Added to avoid problems in NorMal. LH believes this to be problematic. LH. Yes, he does, we lose "..synge for √• gjenopprette livsgleden. This rule is to compensate
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

; removed NON-HEAD-DTR head-complementizer-comp-phrase - but why?
; for ICOMPS P+clause next step up - "om + at han kommer"
; "jeg stoler p√• at han kommer"
head-prep-compclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [SELECTED +,   ; LH28092018 from ultra
                                                 KEYS.KEY clse ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
							E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [MAIN-CL -], ; verb-or  so as to comprise "hvem som" complements
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].


head-prep-non-selected-compclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,   ; LH28092018 from ultra
                                                 KEYS.KEY clse ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
														E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [MAIN-CL -], ; verb-or  so as to comprise "hvem som" complements
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

;,
;                                                 KEYS.KEY clse
; EAA. Added & [INV - ]¬†to the head on NON-HEAD-DTR. MalGram-reasons, but I expect this to be a vaild constraint.
head-prep-bareclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
  ;  SYNSEM.NON-LOCAL #4, ;; MHS 190713
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp, ; will apply only for conjunctions of type prep-s-word or descendants
    ;HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp, ; with prep-ultra was missing da/mens/hvis-constrs
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    ;HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
						    MOD <> ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING -,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                        E.TENSE finite],
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ ocons & [FIRST anti-synsem], ;olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

; for "dersom+clause"
head-adjctcomp-bareclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp,
    HEAD-DTR.SYNSEM.LEX +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
						    MOD <>,
						    MAIN-CL -],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.NEED-Q-MARK -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                        E.TENSE finite],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

; for adjunct combination next step up - "l√∏pe for at han vinner"
; cf also head-prep-infclause-comp-phrase, with "√•"
; "vi snakker ang√•ende hva han fort√¶rer"
head-prep-regclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -,
						 KEYS.KEY index-sit1,
						 MOD <[LOCAL.CAT.HEAD verb-all]>],
;    HEAD-DTR.SYNSEM.LEX +, ;"det er under tvil at han kommer"
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp, ;fin-comp, to also get "vi starter etter hvem som kommer"
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DECL -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <> ].

; removed ,
;    NON-HEAD-DTR basic-head-filler-phrase,
; to get both "lure p√• hvem som" and "lure p√• hvorvidt"
; having suspended prep-indirwhquest-word, this rule also works with prep-word-clause
head-prep-indirwhquestclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4, ;; MHS 120713 Search for $MHS_COMMENT1. ; LH240713 reintroduced the constraint, since I didn't see any higher type that could induce the means of blocking a sprious extraction in 'han virker som om han kommer'. TODO
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                 KEYS.KEY fct-spec ], ; indirqu
    HEAD-DTR.SYNSEM.LEX +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR  [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                         E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [ DECL -,
							MAIN-CL -],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LEX -,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT +, ;; MHS 090813 Adding this constraint to block unary-fin-rel-head-phrases from being complements in cases such as 'jeg sakker om et hav av katter'. In this case, a solution by way of controlling the propagation of SLASH values is not possible due to the way these unary relative clauses are handled. 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].

; cl-adjct rather than prep-or-adv
head-prep-prepadv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL.SLASH <!!>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    HEAD-DTR.SYNSEM.LEX +, ; to prevent some absurd stuff - 'over brua og til skogen' as head
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cl-adjct,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!> ].

head-prep-prep-or-adv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    HEAD-DTR.SYNSEM.LEX +, ; to prevent some absurd stuff - 'over brua og til skogen' as head
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].


#|
head-prep-bareclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR head-subject-phrase & [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                                              E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list ].
|#

; removed HEAD noun in second ARG, to at least parse other types of complement

head-cmpardep-reg-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPEC #2,
    SYNSEM.NON-LOCAL #4,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-dep-reg,
                              VAL [SPR <>,
                                   SPEC #2]]],
	   [ SYNSEM.LOCAL.CAT [VAL [SPR <>,
				    SPEC <>,
				    COMPS <>]],
	     SYNSEM.LOCAL.CAT.HEAD n-or-adj-or-adv,
	     SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
	     SYNSEM.NON-LOCAL #4,
	     SYNSEM.CMPAR-SAT - ]>,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

head-cmpardep-close-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-close,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPEC #2,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-dep-close,
                              VAL [SPR <>,
                                   SPEC #2]]],
    [ SYNSEM.LOCAL.CAT [HEAD noun,
                        VAL [SPR <>,
                             SPEC <>,
                             COMPS <>]],
      SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ SORT measure-unit ] ]>,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

     
head-cmpadv-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv & [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL.SPEC #5,
    SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    ARGS < [ SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
	     SYNSEM.LOCAL [ CAT [ HEAD cmpar-close-adv & [ DEGREE comparative ],
                                  VAL [ SPR list,
                                        SPEC #5,
                                        COMPS cons ]],
                            CONT [ HOOK.INDEX.WH #9,
                                   HOOK.XARG #2,
                                   HOOK.LTOP #4,
                                   RELS.LIST.FIRST.ARG2 #1,
                                   RELS.LIST.REST.FIRST.ARG2 #2 ]]],
    [ SYNSEM.LOCAL.CAT [HEAD cmpar-dep-close,
                        VAL [ SPR <>,
                              SPEC <>,
                              COMPS <> ]],
      SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ] >,
    C-CONT [ RELS <! !>, 
             HCONS <! !> ]].


head-prep-s-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
   ; SYNSEM.NON-LOCAL #4, ;; MHS 120713 Search for $MHS_COMMENT1. 
    SYNSEM.IDIOMOD #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp,
    HEAD-DTR.SYNSEM.IDIOMOD #2,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
   ; NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].

;  & [ KEYS.KEY rais ]
head-prep-rais-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
   ; SYNSEM.NON-LOCAL #4, ;; MHS 120713 Search for $MHS_COMMENT1. 
;    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
;    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep], tried this to get "han sover uten √• puste", with "uten..." combined via atelic-vp-mod-rule; but lost 19 rais-constr, and return to using prep-comp
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-comp],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.XARG #1],
    NON-HEAD-DTR [SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
		  SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl],
    NON-HEAD-DTR head-complementizer-comp-phrase-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp, ; glob rather than infin, in order to cover det later til at det sn√∏r
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>].

head-prep-exlnk-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE +,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-comp],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.XARG #1],
    NON-HEAD-DTR head-complementizer-comp-phrase-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp, 
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>].

; head-prep-comp-phrase seems to be sufficient. so, comment out the rule
; for adjunct combination next step up - "l√∏pe for √• vinne"
; cf also head-prep-regclause-comp-phrase, with "at"


head-prep-infclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all,
                                 LOCAL.CONT.HOOK.XARG #1] >,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
  ;  SYNSEM.NON-LOCAL #4, ;; MHS 120713 Search for $MHS_COMMENT1. 
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [ KEYS.KEY index-sit1 ],
    NON-HEAD-DTR head-complementizer-comp-phrase-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].



head-coord-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #2,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf, - this is fine for v-coord, but blocks for n. Consider two different such pharses
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.XSORT #7,
    SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE #coord,
    SYNSEM.LOCAL.COORD-POL #12,
  ;  SYNSEM.NON-LOCAL #5, ;; MHS 120713 Search for $MHS_COMMENT1. 
    SYNSEM.LOCAL.XCAT.VAL.SUBJ #subj,
    SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #10,
    SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED #hs,
    FRONT-TO-FILL #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD coord,
    HEAD-DTR.SYNSEM.LOCAL.COORD-POL #12,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #2,
;                                               SF #sf,
					       SORT #7 ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-POL #12,
    NON-HEAD-DTR.SYNSEM.LOCAL.MUST-APP -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-COORD-COMP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COORDINABLE #coord,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
    NON-HEAD-DTR.SYNSEM.LOCAL.HEAD-SUBJ-APPLIED #hs,
    NON-HEAD-DTR.FRONT-TO-FILL #8 ].

;SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #3] >

head-wordcoord-comp-phrase := head-coord-comp-phrase &
 [ SYNSEM.LOCAL.COORD-RELEASED +,
   SYNSEM.LOCAL.XCAT.HEAD #3,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   HEAD-DTR.FRONT-TO-FILL #8,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #3,
   NON-HEAD-DTR.FRONT-TO-FILL #8].

head-wordcoord-nonequal-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD adv-reg & [KEYS.KEY dir]] >,
   SYNSEM.LOCAL.COORD-RELEASED +,
   SYNSEM.LOCAL.XCAT.HEAD #3 & verb-all,
   NON-HEAD-DTR.SYNSEM.LOCAL.XCAT.HEAD #3,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin ].


#|
head-wordcoord-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #3] >,
   SYNSEM.LOCAL.XCAT.HEAD #3,
   SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #3].
|#

; If we want to allow listing ,  ,  , wthout final "og" through, then
; the part 'SYNSEM.LOCAL.COORD-RELEASED -,' can be omitted
; ,
;   NON-HEAD-DTR.SYNSEM.LEX - 

head-commacoord-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comma-coord,
;   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #3] >,
   SYNSEM.LOCAL.COORD-RELEASED -,
   SYNSEM.LOCAL.XCAT.HEAD #3,
   SYNSEM.LOCAL.HAS-PUNCT +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #3 ].

head-numbercoord-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD comm-noun,
                                LOCAL.CONT.HOOK.INDEX.SORT number-unit,
                                LOCAL.CAT.HEAD.KEYS.KEY measnoun] >,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cardnum].


head-quant-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.BINDING.BOUND -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant & [KEYS.KEY #key],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEFINITE +,
                                                KEYS.KEY #key]].

head-quant-gen-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N #pp,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant & [KEYS.KEY #key],
 ;   NON-HEAD-DTR poss-general-genitive-phrase & [INFLECTED +],
    NON-HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N #pp,
    NON-HEAD-DTR.C-CONT.RELS.LIST.FIRST poss-rel,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEFINITE -,
                                                KEYS.KEY #key ],
    NON-HEAD-DTR [INFLECTED +]].

head-part-prep-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [  SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
     HEAD-DTR.SYNSEM.LEX +,
     NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     SYNSEM.LOCAL.CONT.HCONS #1,
     SYNSEM.LOCAL.BINDING.BOUND - ,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #1,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort].


head-part-prep-comp-phrase2 := basic-head-comp-phrase & head-initial & rule &
  [  SYNSEM.LOCAL.CAT.VAL.SPR < [] >,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep & [DEF #def],
     NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant & [DEF #def],
;     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS <! [], [] !>,
     C-CONT.RELS <! !>,
     C-CONT.HCONS <! !>].

;; "Ola sine katter" - "Ola" is NON-HEAD-DTR/COMPS, "katter" is SPEC, "sine" is HEAD-DTR, and "s" likewise. The SYNSEM will have same specification as "min" in "min katt".
#| ;2
head-possparticle-comp-phrase-sup := basic-head-comp-phrase & head-final & rule &
  [  SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
				   LOCAL.CONT.HOOK.INDEX ref-ind & [PNG #png]] >],
     SYNSEM.LOCAL.BND-RESP #resp,
;     SYNSEM.LOCAL.CONT.HOOK.INDEX #3, ; won't work since "sine" and "Ola" have diff number
;     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.AGR.PNG #png,
;     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [PNG #png],
;     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #2,
    NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
;     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
     NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <> ]. ; & [PNG #png]
|#

;NEW - from svn 558
head-possparticle-comp-phrase-sup := basic-head-comp-phrase & head-final & rule &
  [  SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD.DEFINITE -] >],
     SYNSEM.LOCAL.BND-RESP #resp,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
     NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind ].


;LH310116 previously HEAD noun, to avoid han sin, meg sin etc. But 'han som der sin ..." is fine, and rather than introduce adhoc feature for 'having adjuncts' or not, widening this to also allow "hun sin butikk".
head-possparticle-comp-noun-phrase := head-possparticle-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers ].

head-possparticle-comp-pronoun_2-phrase := head-possparticle-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
   NON-HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL + ].

; maybe have more, but most other candidates can project to noun by l-rule
head-possparticle-comp-pronoun-phrase := head-possparticle-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron  & [KEYS.KEY interr-word] ].



;,
;				    QUE 0-dlist & [ LIST null ]
;, 
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop
;HEAD-DTR.SYNSEM.LOCAL.CAT icomps-cat,
    
#|
basic-head-icomp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase & phrasal &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
			       COMPS #comps,
			       ICOMPS #icomps,
			       SPR #spr ]],
             NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    EXTRACTED-FROM #11,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
					COMPS #comps,
                                        ICOMPS < #synsem . #icomps >,
                                        SPR #spr ]] ],
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    NON-HEAD-DTR.EXTRACTED-FROM #11,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ SLASH [ LIST #first,
					    LAST #last ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].
|#

basic-head-icomp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase & phrasal &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
			       COMPS #comps,
			       ICOMPS #icomps,
			       SPR #spr ]],
             NON-LOCAL [ 
    ;SLASH [ LIST #first,  MHS 070713 As in previous cases, I had commented out this on 050513, but again it's been reverted on the SVN.
    ;				  LAST #last ],
			 REL 0-dlist ] ],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    EXTRACTED-FROM #11,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
					COMPS #comps,
                                        ICOMPS < #synsem . #icomps >,
                                        SPR #spr ],
				  QVAL.OBL1.LOCAL.CAT.QVAL #dobj] ],
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #dobj,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.EXTRACTED-FROM #11,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem,
   ; NON-HEAD-DTR.SYNSEM.NON-LOCAL [ SLASH [ LIST #first,
   ;					    LAST #last ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].



; check as to 'KEYS.KEY prim-mod'
; since head-prep-comp-phrase doesn't declare any WAIT-BND-RESP, 
; the part  SYNSEM.LOCAL.WAIT-BND-RESP #38 is here idle, and we lack a way
; of propagating binding out of an infinitive - so, "Jon ber meg snakke om seg"
; does not get the "seg" bound. This remains a problem.
;SYNSEM.NON-LOCAL #2,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
;NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #varg,
;HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
; perhaps too strong:    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +], that rules out 'han bor i Oslo', where prep is 'free' locative
        
head-verb-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.NON-LOCAL.SLASH #nl,
    SYNSEM.VAL-CLASS #valcl,
;    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    FRONT-TO-FILL #front,
    EXTRACTED-FROM #5,   ;; MHS 070713 Again, this was commented out the day before yesterday. Somehow, however, it's been reverted on the SVN. Agree LH310721, but...; culpameaLH310721
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
 ;   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
 ;   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.VAL-CLASS #valcl,
 ;   HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
 ;   HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
;    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +],
 ;                                                    KEYS.KEY prim-mod],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -, ; ].
    NON-HEAD-DTR.EXTRACTED-FROM #5 ]. ; culpameaLH310721


; [KEYS.KEY fct-actv-spec --- pass-prep
head-actv-verb-icomp-phrase := head-verb-icomp-phrase &
  [  SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
     SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl, ;to mediate exlnk-rule
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
     HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY prim-mod],
     NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

head-actv-verb-icomp-for-expl-obj-phrase := head-verb-icomp-phrase &
  [  SYNSEM.LOCAL.CAT.VAL.COMPS < #remain-epon >,
     SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
     SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl, ;to mediate exlnk-rule
     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.EXPLETIVE +,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < #remain-epon & [LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
							   LOCAL.CAT.HEAD.IMPERATIVE -]>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.EXPLETIVE +,
     HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY prim-mod],
     NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

   ; [KEYS.KEY fct-pass-spec ]
head-pass-verb-icomp-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE passive ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv, ; & [KEYS.KEY prim-mod],;to allow passive with obj-equi-pp-synsem-sup
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD + ]. ;,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fct-spec] ].

;are these for exlnk-const?
head-actv-verb-icomp-infinepon-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                                  LOCAL.CONT.HOOK [INDEX #2]]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY prim-mod],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

;head-actv-verb-icomp-finepon-phrase := head-verb-icomp-phrase &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp]>,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

; SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp,
;                                  LOCAL.CONT.HOOK [LTOP #2]]

; for at and YN epon
head-actv-verb-icomp-finepon-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG semarg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp,
                                  LOCAL.CONT.HOOK [LTOP semarg]]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY fct-spec],
    NON-HEAD-DTR.SYNSEM.LEX -].

; provisionally left out head of NON-HEAD
head-actv-verb-icomp-fineponWH-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG semarg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all,
                                  LOCAL.CONT.HOOK [LTOP semarg]]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra ].

; not clear what distinguishes this from head-verb-icomp-phrase so much that one needs two. Tentatively comment out the rule. They double for 'det setter seg en gutt her', but with identical mrs
head-verb-loc-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
 ;   SYNSEM.NON-LOCAL #2, ;; MHS 120713 Search for $MHS_COMMENT1. 
    EXTRACTED-FROM #5,
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [SELECTED -,
                                                     KEYS.KEY prim-mod],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [XARG #1,
                                         INDEX[SORT non-fix-point,
                                               ROLE xdim-to-xdim-spatial]],
 ;   NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].

head-actv-verb-loc-icomp-phrase := head-verb-loc-icomp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].
; [KEYS.KEY fct-pass-spec ]
head-pass-verb-loc-icomp-phrase := head-verb-loc-icomp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE passive ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].


head-verb-detachposs-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ <synsem>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED +,
                                               KEYS.KEY detch ],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

head-verb-preprais-comp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #obl1,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.NON-LOCAL #2, ;; MHS 120713 Search for $MHS_COMMENT1. 
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    EXTRACTED-FROM #5,
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS < #obl1 & [LOCAL.CONT.HOOK.LTOP #varg,
						    LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.OBL1 #obl1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #varg,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].



head-adjective-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD list, ; should be zero, to avoid comb with noun ..TODO
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.CAT.VAL.COMPS #8,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.LOCAL.CAT.POSTHEAD +,
    SYNSEM.NON-LOCAL #2, ;; MHS 120713 Search for $MHS_COMMENT1. LH160214 cannot find that comment. Overruled, for now
    EXTRACTED-FROM #5,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #8,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.N-COMB-PENDING -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                     MOD list,
                                                     KEYS.KEY fct-actv-spec],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1, ; LH01122018 this is probably a sound constraint, but had to be cancelled in order to get "En gutt avhengig av √• fort√¶re Ola sover". Of course other solutions could be tried, but not at the moment.
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].


correlcoord-mod-phrase-sup := adj-head-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CORRCOORD-CLOSED +,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.COORD-POL #2,
;    HEAD-DTR coordinating-phrase,
;    HEAD-DTR connect-n-spr-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR correlative-coord-word & [SYNSEM.LOCAL.CAT.HEAD correl-coord & [ MOD <[LOCAL.COORD-POL #2]>]],
    C-CONT [RELS <! !>,
            HCONS <! !>]  ].

correlcoord-mod-n-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR connect-n-spr-phrase,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].
correlcoord-mod-vp-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR vp-connect-phrase,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].
correlcoord-mod-s-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR s-connect-phrase-sup,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].
correlcoord-mod-inf-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR s-infin-connect-phrase,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].
correlcoord-mod-a-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR a-connect-phrase,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].
correlcoord-mod-p-adv-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR p-adv-connect-phrase,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].
correlcoord-mod-p-adv-dir-phrase := correlcoord-mod-phrase-sup &
  [ HEAD-DTR p-adv-dir-connect-phrase,
    SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val ].


a-mod-phrase-sup := head-mod-phrase & basic-binary-headed-phrase &
  [ SYNSEM phr-synsem,
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; to ensure that PPs adjoint to N before ADJ does
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal-or-connect-n,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8].

;; some additional types...

a-mod-phrase := a-mod-phrase-sup & adj-head-phrase &
  [ SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    C-CONT [RELS <! !>,
	    HCONS <! !>]]. 

a-mod-postnom-phrase := a-mod-phrase-sup & adj-head-postnom-phrase &
[  SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    C-CONT [RELS <! !>,
         HCONS <! !>]]. 

; to accept 'den snille gutt..', and 'den snille sover'- DEFINITE + > DEFINITE bool
a-mod-def-phrase := a-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR cons,  ;"beste fremgangsm√•te er √•" - no need for a SPR, but for this type of 'peeled' subjects a better approach is needed
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-MODIFY +].

a-mod-def-postnom-phrase := a-mod-postnom-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD comm-noun,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK -].

; not needed
;a-mod-def-selve-phrase := a-mod-phrase &
;  [ SYNSEM.LOCAL.CAT.VAL.SPR null,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +,
;;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY selve-k ].

;; Backup. Will introduce split adj-head-phrase and a-mod-phrase so that c-cont may introduce additional EP _commsg...etc so that mal sentence mrs matches ben sentence mrs.
#|

a-mod-phrase := adj-head-phrase &
  [ SYNSEM phr-synsem,
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].

mal-a-mod-def-phrase := a-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR null,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
    GENRE robust].
|#

a-mod-indef-phrase := a-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

a-mod-indef-postnom-phrase := a-mod-postnom-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
;    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].


;NON-HEAD-DTR.INFL-MORPH #6,
;     HEAD-DTR.INFL-MORPH #6
     
adjective-mod-phrase-sup := a-mod-phrase-sup & rule & no-slash &
  [  RULE #3,
     SYNSEM.LOCAL.DERIVED-HEAD #2,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
     SYNSEM.LOCAL.MODIFICATION-PERFORMED +,
;     SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.RULE #3,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
     HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #2,
     HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY propt],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAN-MODIFY +,
     NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !> ].  ; 'left-branch condition Ross'

adjective-mod-phrase := adjective-mod-phrase-sup & a-mod-phrase.

; makes "tre gutter" non-wh. To get "hvilke tre gutter", see below

; changing from a-mod-phrase to head-spec-phrase
; see also 'cardinal-word'
#|
card-mod-phrase-sup := complex-spec-n-phrase-sup &
  [  SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     SYNSEM.LOCAL.BINDING [ BOUND -,
                            REFL-I - ],
     SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     SYNSEM.LEX -,
     RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #10,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     HEAD-DTR.RULE [ NEEDS-CARD bool,
                     NOMORE-CARD - ],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     C-CONT [ RELS <! quant-relation & [PRED "_udef_q_rel",
					ARG0 #5,
					RSTR #6], 
		    measure-out-rel & [ LBL #8,
					ARG1 #5,
					ARG2 #10]   !>,
	     HCONS <!  [HARG #6,
			LARG #8 ]!>]].
|#

;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #5,
; XARG inst of INDEX  - - LH130613 and why that? lets card 'en' combine with neuter noun. repaired
card-mod-phrase-sup := complex-spec-n-phrase-sup &
  [  SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     SYNSEM.LOCAL.CONT.HOOK.XARG #5,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     SYNSEM.LOCAL.BINDING [ BOUND -,
                            REFL-I - ],
     SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     SYNSEM.LOCAL.CMPAR-PENDING #cmpar,
     SYNSEM.LEX -,
     RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     HEAD-DTR.RULE [ NEEDS-CARD bool,
                     NOMORE-CARD - ],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #cmpar,
;     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.AGR #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG.PNG #1,
     C-CONT [ RELS <! !>,
	     HCONS <! !>]].

#|
; LH040513 - replace by rule below, to enable n-connect-spr-phrase for '7 gutter og jeg'
card-mod-phrase := card-mod-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>].
|#
card-mod-phrase := card-mod-phrase-sup.

card-cum-singspec-mod-phrase := card-mod-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD noun,
                                 LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

card-cum-plurspec-mod-phrase := card-mod-phrase-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD noun,
                                 LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-pl-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1].

card-cum-adj-mod-phrase := card-mod-phrase-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD adj-reg ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

card-cum-prep-or-adv-mod-phrase := card-mod-phrase-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD prep-or-adv ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

adjective-mod-def-phrase := a-mod-def-phrase & adjective-mod-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD -].
;    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY - ]. ; , NON-HEAD-DTR weak-adj-word-sup

; After shifting to counting these as indef. adjective-mod-indef-rule covers "rette l√∏sning er √•...", without need for pseudoweak-superlative-adj-word. Same for adjective-mod-superlative-indef-rule. So, the following two rules are now commented out in rules.tdl. Well, not quite. 02032019
adjective-mod-pseudoweak-indef-phrase := a-mod-indef-phrase & adjective-mod-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD -,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR pseudoweak-designated-adj-word ].

adjective-mod-pseudoweak-ordinal-indef-phrase := a-mod-indef-phrase & adjective-mod-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD -,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR pseudoweak-ordinal-adj-word ].

adjective-mod-superlative-indef-phrase := a-mod-indef-phrase & adjective-mod-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD -,
    NON-HEAD-DTR sup-adj-weak-word ].



; & adjective-mod-phrase - commented out since it has embedded a head-final constraint which will take time to unwind - it's a terrible type hierarchy in this case.
adjective-mod-def-postnom-phrase := a-mod-def-postnom-phrase.

;adjective-mod-def-selve-phrase := a-mod-def-selve-phrase & adjective-mod-phrase.

adjective-mod-indef-phrase := a-mod-indef-phrase & adjective-mod-phrase &
  [ SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep,
    SYNSEM.LOCAL.CAT.POSTHEAD -,; had to outcomment to get 'en snill, hyggelig mann sover' LH24022021: That however allows for '(flere) snill barn sover'. so must be in-commented.
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING -,
;HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.MAL-INFLECT-LEEWAY #leeway] >,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.MAL-INFLECT-LEEWAY #leeway,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -, ; a modifying AP might contain comma - snill, s√∏t
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD -,;; had to outcomment to get 'en snill, hyggelig mann sover' LH24022021: That however allows for '(flere) snill barn sover'. so must be in-commented.
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK - ]. 

;& adjective-mod-phrase - commented out since it has embedded a head-final constraint which will take time to unwind - it's a terrible type hierarchy in this case.

adjective-mod-indef-postnom-phrase := a-mod-indef-postnom-phrase &
  [ SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING -,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep ]. 


; #spr to carry on the weak adj's requirements, if any
card-mod-phrase-def := card-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY #key,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY #key,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

card-mod-phrase-indef := card-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -, ; sounds reasonable, but the rule feeds also 'mine fem gutter', where the genitive requires a DEF+ head noun
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

; for "tre gutter" to get "hvilke tre gutter"
card-mod-phrase-indef-with-interr := complex-spec-n-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < expressed-synsem & [ LOCAL.CONT.HOOK.INDEX.WH + ] >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I - ],
    RULE [ NEEDS-CARD -,
           NOMORE-CARD + ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                    NOMORE-CARD - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
    C-CONT [ RELS <! quant-relation & [PRED "_udef_q_rel",
					ARG0 #5,
					RSTR #6], 
		    quant-relation & [PRED "_udef_q_rel",
					ARG0 #3,
					RSTR #4], 
		    measure-out-rel & [ LBL #8,
					ARG1 #3 ]   !>,
	     HCONS <![HARG #6,
			LARG #7 ], [HARG #4,
				    LARG #8 ] !>]].

; for "hvor mange gutter"
;  NON-HEAD-DTR measure-quantword-a-phrase &
interr-card-mod-phrase := a-mod-indef-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    RULE [ NEEDS-CARD - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +],
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                    NOMORE-CARD - ]].

;SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH +,
    
; "bygg femten"
;SYNSEM.LOCAL.CONT.HOOK.LTOP #11

card-mod-phrase-head-initial-sup := complex-spec-n-phrase-head-initial &
  [  SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     SYNSEM.LOCAL.BINDING [ BOUND -,
                            REFL-I - ],
     SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     SYNSEM.LEX -,
     RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [DEF #2],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #10,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     HEAD-DTR.RULE [ NEEDS-CARD bool,
                     NOMORE-CARD - ],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
 ;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     C-CONT [ RELS <! measure-out-rel & [ ARG1 #5,
					ARG2 #10], 
		    quant-relation & [PRED "_udef_q_rel",
					ARG0 #10,
					RSTR #6], 
		    quant-relation & [PRED "_udef_q_rel",
					ARG0 #5,
					RSTR #12]   !>,
	     HCONS <!  [HARG #6,
			LARG #11 ], [HARG #12,
				     LARG #8 ]!>]].


card-mod-phrase-head-initial := card-mod-phrase-head-initial-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>].

card-mod-phrase-head-initial-indef := card-mod-phrase-head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].




connector-mod-phrase-sup := headed-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !> ].


connector-mod-phrase := connector-mod-phrase-sup &
  [ SYNSEM.LOCAL.MUST-COORDINATE +,
    C-CONT [RELS <! !>,
            HCONS <! !>]  ].

connector-mod-phrase-2 := connector-mod-phrase-sup &
  [ C-CONT [RELS <! [] !>,
            HCONS <! !>]  ].

; both for connector-words and for punctuation
connector-leftmod-phrase-sup := connector-mod-phrase & adj-head-phrase.
connector-leftmod-phrase := connector-leftmod-phrase-sup.
;connector-leftmod-comma-phrase := connector-leftmod-phrase-sup.
connector-leftmod-phrase-2 := connector-mod-phrase-2 & adj-head-phrase-2.
; only for punctuation
connector-rightmod-phrase := connector-mod-phrase & head-adj-phrase. ; connector-mod-phrase & 

gapping-serial-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.EXTRACTED-FROM -,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord & [MOD <[LOCAL.CAT.QVAL #qval]>],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND +,
    NON-HEAD-DTR.EXTRACTED-FROM - ]. 

end-punctuation-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.NON-LOCAL.SLASH #slash,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.BND-RESP #bresp,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    FRONT-TO-FILL #ftf,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #1],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH  #slash & <! !>,
    HEAD-DTR.FRONT-TO-FILL #ftf,
    C-CONT [RELS <! !>,
            HCONS <! !>]  ].

; 03022020 from lex.closed, to be insrted there
;og-comma_a-connect := a-connect-comma &
;  [ STEM < "," >,
;    SYNSEM.LKEYS.KEYREL [PRED "_og-connect_rel"]].


;these all three look strange
;MOD < [ LOCAL.CAT.HEAD verb-all ] - well why not
punctuation-mod-for-v-phrase := phrasal &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all] >].

punctuation-mod-for-ndir-phrase := phrasal &
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun & [KEYS.KEY dirnoun] ] >], [] >].

punctuation-mod-for-n-phrase := phrasal &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >].


#|
; produces the wrong tree structure for "gul og frodig sti", but ok mrs,
; as far as the fake mrs'es produced by this and the above type go
connector-mod-phrase2 := adj-head-phrase &
  [ SYNSEM #1,
    ARGS < connector, sign & [ SYNSEM #1 & [ LOCAL.CAT.HEAD adj ]] >].
|#

comma-leftmod-phrase := connector-leftmod-phrase &
 [  SYNSEM.LOCAL.HAS-PUNCT +,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD connect & [KEYS.KEY comma-punctuation],
	    SYNSEM.LOCAL.IS-PUNCT +], 
	   [GENRE regular] >]. ; one wouldn't use the wromg comma ...

comma-rightmod-phrase-3 := connector-rightmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < [], p-clse-connect-punctuation >].

comma-rightmod-phrase := connector-rightmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < [], vcond-connector >]. 
comma-rightmod-phrase-2 := connector-rightmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < [], vcond-connector-2 >].
comma-rightmod-interjct-phrase := connector-rightmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < sign, interject-connect-punctuation >].
comma-rightmod-adj-interjct-phrase := connector-rightmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < sign, adj-interject-connect-punctuation >].
comma-rightmod-quotation-phrase := connector-rightmod-phrase &
  [ SYNSEM.LOCAL.HAS-PUNCT +,
    ARGS < right-quote-phrase, quotation-connect-punctuation >].
comma-rightmod-relcl-phrase := connector-rightmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < [SYNSEM.NON-LOCAL.SLASH <! !>,
             SYNSEM.LOCAL.CAT.HEAD.DECL + ], rel-cl-connect-punctuation >].
comma-leftmod-relcl-phrase := connector-leftmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     ARGS < rel-cl-nonrestr-connector, [SYNSEM.NON-LOCAL.SLASH <! !>,
                                        SYNSEM.LOCAL.CAT.HEAD.DECL + ] >].

comma-rightmod-app-phrase := connector-rightmod-phrase &
  [ SYNSEM.LOCAL.MUST-APP +,
    ARGS < [SYNSEM.NON-LOCAL.SLASH <! !> ], app-punctuation >].

comma-leftmod-app-phrase := connector-leftmod-phrase &
  [  SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.MUST-APP +,
     ARGS < app-nonrestr-punctuation, [SYNSEM.NON-LOCAL.SLASH <! !> ]  >].

period-mod-phrase := end-punctuation-mod-phrase &
  [  ARGS < [], end-punct >].


comma-leftmod-for-v-phrase := comma-leftmod-phrase & punctuation-mod-for-v-phrase.
comma-leftmod-for-ndir-phrase := comma-leftmod-phrase & punctuation-mod-for-ndir-phrase.
comma-rightmod-for-v-phrase := comma-rightmod-phrase-3 & punctuation-mod-for-v-phrase.
comma-rightmod-for-ndir-phrase := comma-rightmod-phrase & punctuation-mod-for-ndir-phrase.
comma-rightmod-for-inv-v-phrase := comma-rightmod-phrase & punctuation-mod-for-v-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DECL +,
    HEAD-DTR.SYNSEM [LOCAL.RIGHT-ADJ-SITE-OPEN +,
                     LOCAL.CAT.HEAD.INV +]].


; actually not v-phrase at all - 'hvis[adjct-comp] han kommer, s√•...'
comma-rightmod-for-non-inv-v-phrase := comma-rightmod-phrase-2 & punctuation-mod-for-v-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DECL +,
    HEAD-DTR.SYNSEM [LOCAL.RIGHT-ADJ-SITE-OPEN +,
                     LOCAL.CAT.HEAD.INV -]].

;punctuation-mod-for-v-phrase &
comma-rightmod-for-interjct-v-phrase := comma-rightmod-interjct-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    HEAD-DTR interjection-phrase & [SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop],
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop]].

comma-rightmod-for-quotation-v-phrase := comma-rightmod-quotation-phrase & punctuation-mod-for-v-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    HEAD-DTR right-quote-phrase ].

comma-rightmod-relsubj-som-phrase := comma-rightmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR head-relative-subject-phrase & [ SYNSEM.LOCAL.CONT.HOOK #1],
    SYNSEM.LOCAL.CONT.HOOK #1].

comma-rightmod-relsubj-√∏-phrase := comma-rightmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR unary-rel-head-filler-phrase & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1].

comma-rightmod-relcomp-som-phrase := comma-rightmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR rel-head-filler-phrase & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1].


comma-leftmod-nonrestr-relcomp-phrase:= comma-leftmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR comma-rightmod-relcomp-som-phrase & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1].

comma-leftmod-nonrestr-relsubj-phrase:= comma-leftmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR comma-rightmod-relsubj-som-phrase & 
             [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
               SYNSEM.LOCAL.CAT.VAL.SPR #2 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.CAT.VAL.SPR #2 ].

; this is a head-adj-phrase, with comma as adjunct. It will combine with an NP,
; succeding and serving as SPR for this NP, by the rule
; comma-rightmod-restr-apposition-phrase (head-init head-spec rule)


comma-rightmod-apposition-phrase := comma-rightmod-app-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR [ SYNSEM.LOCAL.CONT.HOOK #1,
               SYNSEM.LOCAL.CAT.HEAD nominal],
    SYNSEM.LOCAL.CONT.HOOK #1,
    SYNSEM.LOCAL.APPOSITION-COMPLEX +,
    SYNSEM.LOCAL.HAS-PUNCT +,
    RULE #2,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ SYNSEM.LOCAL.CAT.HEAD nominal ] >,
    HEAD-DTR.RULE #2 & [ NOMORE-CARD + ]].


; this is a head-adj-phrase, with comma as adjunct. It will combine with an NP,
; succeding and serving as MOD for this NP, by the rule
; rightmod-nonrestr-apposition-phrase (head-init head-adj rule)
comma-leftmod-nonrestr-apposition-phrase := comma-leftmod-app-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR comma-rightmod-app-phrase & [ SYNSEM.LOCAL.CONT.HOOK #1],
    SYNSEM.LOCAL.CONT.HOOK #1].


; omitted: SPR antilist and SPR <> in ordr to allow "(mannen smiler.)"
; now applies for all heads
period-mod-for-v-phrase := period-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.INV-DECL-PRECARIOUS #prec,
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-comm,
    HEAD-DTR.SYNSEM.LOCAL.INV-DECL-PRECARIOUS #prec,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1 & null,
                                    ICOMPS #2 & null,
                                    SPR #3 & null,
                                    SPEC #4 & null ]].

period-yn-mod-for-v-phrase := period-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    SYNSEM.LOCAL.NEED-Q-MARK -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    HEAD-DTR.SYNSEM.LOCAL.NEED-Q-MARK +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1 & null,
                                    ICOMPS #2 & null,
                                    SPR #3 & null,
                                    SPEC #4 & null ]].

period-mod-for-n-or-adj-or-adv-phrase := period-mod-phrase &
  [  SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD n-or-adj-or-adv,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ #0 & antilist,
                                    COMPS #1 & null,
                                    ICOMPS #2 & null,
                                    SPR #3 & null,
                                    SPEC #4 & null ]].

period-mod-for-p-phrase := period-mod-phrase &
  [  SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1 & null,
                           ICOMPS #2 & null,
                           SPR #3 & null,
                           SPEC #4 & null ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1,
                                    ICOMPS #2,
                                    SPR #3,
                                    SPEC #4 ]].

period-mod-for-interjection-phrase := period-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1 & null,
                           ICOMPS #2 & null,
                           SPR #3 & null,
                           SPEC #4 & null ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD interjection,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1,
                                    ICOMPS #2,
                                    SPR #3,
                                    SPEC #4 ]].

connect-p-adv-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LEX -,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY index-sit1]],
    ARGS < p-adv-connect-word, sign & [SYNSEM.LOCAL.HAS-PERIOD -] >].

;ARGS < [p-adv-dir-connect-word
connect-p-adv-dir-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LEX -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY dir-sup],
;    HEAD-DTR.SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-line-rel],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY dir]]>]].
    
connect-v-mod-phrase := connect-v-mod-phrase-sup &
 [ GENRE regular ].

; sup to also feed mal-connect-v-mod-phrase. Should do the same for connect-v-mod-2-phrase TODO
connect-v-mod-phrase-sup := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ #subj & list, ;1-list,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CAT.HEAD.DECL #decl,
    SYNSEM.LOCAL.CAT.HEAD.VOICE #voice,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #tense,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.SUBJ #subj,
				 LOCAL.CAT.HEAD.DECL #decl,
				 LOCAL.CAT.HEAD.VOICE #voice,
				 LOCAL.CONT.HOOK.INDEX.E.TENSE #tense]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all]>,
    ARGS < v-connector & [SYNSEM.LOCAL.IS-PUNCT -,
			  SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.MAL-INFLECT-LEEWAY +]>], 
	   sign & [SYNSEM.LOCAL.HAS-PUNCT bool, ;-, ; a hack, for interjec
		   SYNSEM.LOCAL.HAS-PERIOD -,
		   SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
		   SYNSEM.LOCAL.CONNECT-PENDING -,
		   SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
		   SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #tense,
		   SYNSEM.LOCAL.CAT.HEAD.INV -,
		   SYNSEM.LOCAL.CAT.HEAD.DECL #decl,
		   SYNSEM.LOCAL.CAT.HEAD.VOICE #voice,
		   SYNSEM.LOCAL.CAT.VAL [SUBJ #subj,
					 SPR #spr,
					 COMPS #comps,
					 ICOMPS #icomps,
					 SPEC #spec]] >].
; for s-coordination
connect-v-mod-2-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-or-comp, ;verb-all,
				 LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 LOCAL.CAT.VAL.SUBJ olist,
				 LOCAL.HAS-WH-MOVED #bool]>,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-or-comp, ;verb-all,
					  LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 LOCAL.HAS-WH-MOVED #bool]>,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; maybe too strong
    HEAD-DTR.FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL +,
    ARGS < v-connector, sign & [SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec],
				SYNSEM.LOCAL.CAT.QVAL #qval,
				SYNSEM.LOCAL.CONNECT-PENDING #connpend,
				SYNSEM.LOCAL.HAS-WH-MOVED #bool] >].

connect-wh-v-mod-2-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all & [MAIN-CL #maincl],
				 LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 LOCAL.CAT.VAL.SUBJ olist]>,
;    SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE +,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all & [MAIN-CL #maincl], 
					  LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; maybe too strong
    HEAD-DTR.FRONT-TO-FILL -,
    ARGS < v-connector, sign & [SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec],
				SYNSEM.LOCAL.CAT.QVAL #qval,
				SYNSEM.LOCAL.HAS-WH-MOVED #bool] >].

connect-relative-v-mod-2-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all & [IMPERATIVE -]] >,
;				 LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
;				 LOCAL.CAT.VAL.SUBJ olist]>,
;    SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE +,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    SYNSEM.LOCAL.WH-ISLAND +,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all & [MAIN-CL #maincl], 
;					  LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; maybe too strong
    HEAD-DTR.FRONT-TO-FILL -,
    ARGS < v-connector, sign & [SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec],
				SYNSEM.LOCAL.HAS-WH-MOVED #bool] >].

connect-comp-v-mod-2-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ #sbj, ;olist,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD fin-comp,
				 LOCAL.CONT.HOOK.INDEX.E.TENSE finite,	 
				 LOCAL.CAT.VAL.SUBJ #sbj, 
				 LOCAL.HAS-WH-MOVED #bool]>,
    SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD fin-comp,
					  LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 LOCAL.HAS-WH-MOVED #bool]>,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; maybe too strong
    HEAD-DTR.FRONT-TO-FILL -,
 ;   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
    ARGS < v-comp-connector, sign & [SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ #sbj, ;olist,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec],
				SYNSEM.LOCAL.HAS-WH-MOVED #bool] >].

;;
connect-infin-comp-v-mod-2-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ #sbj, ;olist,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD infin-comp,
				 LOCAL.CONT.HOOK.INDEX.E.TENSE infin,	 
				 LOCAL.CAT.VAL.SUBJ #sbj, 
				 LOCAL.HAS-WH-MOVED #bool]>,
    SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
				 SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD infin-comp,
					  LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
				 LOCAL.HAS-WH-MOVED #bool]>,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; maybe too strong
    HEAD-DTR.FRONT-TO-FILL -,
 ;   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
    ARGS < v-infin-comp-connector, sign & [SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ #sbj, ;olist,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec],
				SYNSEM.LOCAL.HAS-WH-MOVED #bool] >].
;;;
;connect-a-mod-phrase := connector-leftmod-phrase & 
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun]>,
;    ARGS < a-connect-word, sign >].

connect-a-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.AGR #agr,
    SYNSEM.LOCAL.CONT.HOOK.VARG #arg1,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.MUST-COORDINATE +,
;    SYNSEM.LOCAL.HAS-PUNCT +, ; adhoc
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [MOD < [LOCAL.CAT.HEAD adj-reg]>],
    ARGS < a-connector, sign & [SYNSEM.LOCAL.CAT.HEAD adj-reg,
				SYNSEM.LOCAL.AGR #agr,
				SYNSEM.LKEYS.KEYREL.ARG1 #arg1,
;				SYNSEM.LOCAL.CONT.RELS <! [ARG1 #arg1] !>,
				SYNSEM.LOCAL.CAT.VAL [COMPS <>,
						      ICOMPS <>],
				SYNSEM.LOCAL.HAS-PERIOD -]> ].

connect-a-mod-right-phrase := connector-rightmod-phrase & 
  [ SYNSEM.LOCAL.AGR #agr,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    ARGS < sign & [SYNSEM.LOCAL.CAT.HEAD adj-reg,
		   SYNSEM.LOCAL.AGR #agr,
		   SYNSEM.LOCAL.CAT.VAL [COMPS <>,
					 ICOMPS <>],
		   SYNSEM.LOCAL.HAS-PERIOD -],
	   sign & [SYNSEM.LOCAL.CAT.HEAD adj-reg,
		   SYNSEM.LOCAL.AGR #agr,
		   SYNSEM.LOCAL.CAT.VAL [COMPS <>,
					 ICOMPS <>],
		   SYNSEM.LOCAL.HAS-PERIOD -]> ].

connect-interject-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD interjection,
    ARGS < sign & [SYNSEM.LOCAL.CAT.HEAD connect], sign & [SYNSEM.LOCAL.CAT.HEAD interjection,
							   SYNSEM.LOCAL.HAS-PERIOD -]> ].

; combines 'og' and 'Ola'
connect-n-mod-phrase := connector-leftmod-phrase-2 & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.MUST-COORDINATE -,
    SYNSEM.LOCAL.XLBL #lbl,
    C-CONT.RELS <! arg12-relation & [ LBL #lbl,
				      PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
    ARGS < n-connector-projection-phrase &
	   [SYNSEM.LKEYS.KEYREL.ARG0 #1 ], 
	   sign & [SYNSEM.LOCAL.CAT.HEAD nom,
		   SYNSEM.LOCAL.CONT.HOOK.INDEX #2]> ].

;n-connect-word
;SYNSEM.LOCAL.XLBL #lbl,

; spec-comp approach

; combines 'og' and 'Ola'
#|
connect-n-comp-phrase := head-valence-phrase & head-compositional &
			  phrasal & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD connect-n,
;    SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #wh,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD connect-n,
    C-CONT.RELS <! arg12-relation & [ PRED "_member-of-set_rel",
;				      LBL #ltop,
				      ARG1 #2,
				      ARG2 #1 ] !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #wh,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [HEAD np-head & [ACCUSATIVE #acc],
				    VAL [ SUBJ <>,
;					  SPR #spr,
;					  SPR olist,
					  SPR <>, ; to avoid 'ti' using cum-def-dem lrule in 'og ti'. olist doesn't suffice.; but sorry, to get 'Per, og Ola' with same rule for 'og' and ',', this condition must be erased. however, this leaves the N unconstrained relative to the many SPR-sensitive l-to-l-rules. Rather define ", og" as a single sign.
					  SPEC olist,
					  COMPS <>,
					  ICOMPS <>]],
ARGS < n-connector &
	   [SYNSEM.LOCAL.HAS-PUNCT -,
	    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ], 
       sign & [SYNSEM.LOCAL.CAT.HEAD np-head,
	       SYNSEM.LOCAL.CARD-TO-BARE-N -,
	       SYNSEM.LOCAL.SPEC-TO-BARE-N -,
	       SYNSEM.LOCAL.HAS-PUNCT -, ; not good for n-connect-comma as head, if the comma is marked as '+'
;		   SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
	       SYNSEM.LOCAL.CONT.HOOK.INDEX #2]>,
SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr & <[LOCAL.CAT.HEAD.ACCUSATIVE #acc]> ],
                         QVAL #qval,
                         POSTHEAD #ph ],
	     LOCAL.COMPS-BEGUN +,
             NON-LOCAL [ REL 0-dlist  ]],
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                        COMPS < #synsem . #comps >,
                                        SPR #spr ],
                                  QVAL #qval,
                                  POSTHEAD #ph ]],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,  ; not good for n-connect-comma
    HEAD-DTR.FRONT-TO-FILL #front, 
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE 0-dlist & [ LIST null ] ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem & [ LOCAL.COORD-RELEASED +,
                                                       LOCAL.MUST-APP -  ],
    C-CONT [ HCONS <! !> ] ].
|#
;;;;
connect-n-comp-phrase := head-valence-phrase & head-compositional &
			  phrasal & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD nominal-or-connect-n & [ACCUSATIVE #bool],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD nominal-or-connect-n]>,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.COORD-RELEASED -,
    SYNSEM.LOCAL.HAS-PUNCT #hp,
    SYNSEM.NON-LOCAL #nl,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LEX +,  ; it is just "og"
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD connect-n, ; nominal-or-
    C-CONT.RELS <! arg12-relation & [ PRED "_member-of-set_rel",
				      ARG1 #2,
				      ARG2 #1 ] !>,
    C-CONT [ HCONS <! !> ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [HEAD nominal-or-connect-n & [ACCUSATIVE #bool], ;np-head, to avoid complementized clauses in n-coordination. but losing quant-headed phrases, then... TODO
				    VAL [ SUBJ <>,
					  SPR <>, 
					  SPEC <>, ;olist, extra parses for "...7 dager og 52 uker"
					  COMPS <>,
					  ICOMPS <>]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT #hp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM canonical-synsem & [ LOCAL.COORD-RELEASED +,
					     LOCAL.MUST-APP -  ] ].
;;;;;;

; combines  jeg  +  og Ola  ( #2 = jeg)
connect-n-spr-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE #acc,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.HAS-PUNCT #pkt,
    SYNSEM.NON-LOCAL #5,
    HEAD-DTR connect-n-comp-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal-or-connect-n & [EXPLETIVE -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ <>,
				   SPEC <>,
				   COMPS <>,
				   ICOMPS <>],				   
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0 #1,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT #pkt,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE #acc],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
;    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -, ; would enable only right-branching multiple coordinations, in conflict with the SYNSEM.LOCAL.HAS-PUNCT #pkt between head phrase "og Ola" and top node.
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-INTERJECTION -,
    NON-HEAD-DTR.SYNSEM.LOCAL.APPOSITION-COMPLEX -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    C-CONT [RELS <! arg12-relation & [ PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
            HCONS <! !>]].



#|
"Per √• Ola sover" in malgram. Generation in lkb, but not in ACE.

Alle EPene skal danne et tre, men du har for f√• hull.
 
Jeg velger h6 som top.
 
h6:node(h7=h3,h8=h9) ---> her har jeg plassert h3 i hull h7 som qeq bestemmer
h3:node()

h9:node(h10=h12,h11=h16) --> h12 plassert i h10 if√∏lge qeq
h12:node()

h16:node(h17=h13,h18=h23) --> h13 plassert i h17 if√∏lge qeq
h13:node()
h23:node()
 
For √• danne resten av treet s√• plasserer jeg h9 i h8 og h16 i h11.
S√• legger jeg h23 i h18.

Noder som ikke er plassert
h21:node()
h19:node()
 
Da har du ikke et tre, men du har tre.
 
 
Lars Hellan
Sun 12/20/2015 6:25 PM
Innboks; Sendte elementer
Hei,

Kan du se hva som mangler i nedenst√•ende for at h19 og h21 skulle v√¶re hypernormally connected?
('og-connect_rel' er her kvantoren som binder x2).  Jeg antar dette er hva som hindrer generering for 'Ola √• Per sover' i ACE. (Generering g√•r greit i LKB.)


head-subject-rule
   connect-n-spr-rule
    Ola-pn
     "ola"
    connect-n-comp-rule
     mal_√•__n-coord
      "√•"
     Per-pn
      "per"
   pres-infl_rule
    sove_intr
     "sover" 	3.708992
1.127974
0.367738

0.128669
0.000000

-0.091114

2.477519
0.936234
	ltop=h0, index=e1
h3:named_rel([carg:ola, arg0:x5])
h6:_def_q_rel([arg0:x5, rstr:h7, body:h8])
h9:_og-connect_rel([arg0:x2, rstr:h10, body:h11])
h12:_set_rel([arg0:x2])
h13:named_rel([carg:per, arg0:x15])
h16:_def_q_rel([arg0:x15, rstr:h17, body:h18])
h19:_member-of-set_rel([arg0:u20, arg1:x15, arg2:x2])
h21:_member-of-set_rel([arg0:u22, arg1:x5, arg2:x2])
h23:_sove_v-intr_rel([arg0:e1, arg1:x2])
< qeq(h7, h3), qeq(h10, h12), qeq(h17, h13) >
e1, sort=verb-act-specification, sf=prop, e.tense=pres, e.mood=indicative, e.aspect=semsort
x5, wh=-, png.ng.num=sing, png.ng.gen=m, png.pers=thirdpers
x2, wh=-
x15, wh=-, png.ng.num=sing, png.ng.gen=m, png.pers=thirdpers
A semantic error occurred while decoding the graph.The dominance children h19 and h21 of the root h9 are not hypernormally connected with each other.

	The word "√•" is not a conjunction, try using "og" instead. More description

Lars

|#	    


#|
; this rule does not accommodate "ham selv" as an NP, as in
; "fortelle Ola om ham selv" (gives too many parses with "meg/deg selv"
REAL-selv-refl-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.BINDING #2 & [REFL-II +,
                               REFL-I #3 & +,
                               LEX-TAME -],
    SYNSEM.LOCAL.BINDING.BOUND +,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-TYPE #2 & binding,
                                            ANAPH-INDX #index & ref-ind ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [VARG #index,
                                          LTOP #top],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD refl-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    C-CONT [RELS <! !>,
            HCONS <! !>]].
|#

REAL-selv-refl-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.BINDING #2 & [REFL-II +,
                               REFL-I #3 & +,
                               LEX-TAME -],
    SYNSEM.LOCAL.BINDING.BOUND +,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.BND-RESP #resp &  < bindee & [ ANAPH-TYPE #2 & binding,
						ANAPH-INDX #index & ref-ind ] >,
;    SYNSEM.LOCAL.CONT.RELS <! [], [], [ARG2 #arg2], [ARG1 #arg2] !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [VARG #index,
                                          LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS <! [], [], [ARG2 #arg2] !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD refl-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; fake version compared to above, 
; by omission of  SYNSEM.LOCAL.BINDING.REFL-I #3
selv-refl-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.BINDING.REFL-II +,
    SYNSEM.LOCAL.BINDING.BOUND #2,
    SYNSEM.LOCAL.CONT.HOOK #1 & [INDEX #index,
                                 LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.BOUND #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [INDEX #index,
                                          LTOP #top],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD refl-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    C-CONT [RELS <! !>,
            HCONS <! !>]].



; to avoid proliferation of parses
;SYNSEM.LOCAL [ CAN-CMB-FIXPT -  - kills 'l√∏per fra x til y'
fixpt-mod := basic-binary-headed-phrase & 
  [ SYNSEM.LOCAL [ CAN-CMB-FIXPT bool],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD head,
			    CONT.HOOK dir-hook,
                            CAN-CMB-FIXPT +],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY fixpt-dir]].

nonfixpt-dir-mod := basic-binary-headed-phrase & 
  [ SYNSEM.LOCAL [ CAN-CMB-NONFIXPT-DIR -],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD head,
			    CONT.HOOK dir-hook,
                            CAN-CMB-NONFIXPT-DIR +],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY nonfixpt-dir,
				CONT.HOOK dir-hook]].

;; HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD head,
;;                         CAN-CMB-INDEX-SIT +],

; LTOP id to get label identity in N modification. although doesn't work
index-sit-mod := basic-binary-headed-phrase & 
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL [ CAN-CMB-INDEX-SIT -],
    HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #ltop],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #ltop,
				CAT.HEAD.KEYS.KEY index-sit]].
    



; removed ,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top
; why on earth was it there, making everything LBL h1?
;SYNSEM.NON-LOCAL #5,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
; C-CONT.RELS <! !>
            
pp-mod-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK [INDEX #index,
			    LTOP #ltop],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
 ;   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index,
				     LTOP #ltop],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>, ; to open for "frist ang√•ende hvem som kan sove" in the case of prep-mod-n-rel
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [RELS <! !>,
	    HCONS <! !>]].

;pp-mod-vp-phrase-unique := pp-mod-phrase &
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <synsem> ].

pp-freerel-mod-vp-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #2,
    HEAD-DTR.FRONT-TO-FILL #3,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <synsem>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ 1-list,
                                                            COMPS <>]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -,
                                                     KEYS.KEY der-n√•r ] ]. 


vp-connect-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
				   IMPERATIVE #imper ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.SUBJ 1-list]>,
    SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    SYNSEM.LOCAL.WH-ISLAND +,
;    SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
					    IMPERATIVE #imper ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #tense,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SIT-TYPE #sitype,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
;    NON-HEAD-DTR connect-v-mod-phrase-sup,
    NON-HEAD-DTR connect-v-mod-2-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
						    IMPERATIVE #imper ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CONT.HOOK.INDEX.E.TENSE #tense]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #tense,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SIT-TYPE #sitype,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    C-CONT [RELS <! !>,
            HCONS <! !>]].
;;
s-infin-connect-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ DECL #decl ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    SYNSEM.LOCAL.CAT.VAL.SUBJ #ol & olist,
    SYNSEM.LOCAL.CAT.VAL.SPR null,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    SYNSEM.LOCAL.WH-ISLAND +,
;    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    ;HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DECL #decl],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #ol,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DECL #decl ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR connect-infin-comp-v-mod-2-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #ol,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX semarg,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CONT.HOOK.INDEX.E.TENSE infin]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    C-CONT [RELS <! !>,
            HCONS <! !>]].
;;

s-connect-phrase-sup := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ DECL #decl, ; verb-all & 
			    IMPERATIVE #imper ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.VAL.SPR null,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DECL #decl, ;verb-all & 
				     IMPERATIVE #imper],
    SYNSEM.LOCAL.CONNECT-PENDING -,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DECL #decl, ; verb-all & 
					 IMPERATIVE #imper ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ ocons & [FIRST anti-synsem],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX semarg,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

s-connect-phrase := s-connect-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD #fin-comp & [INV -, ;verb-all
				     DECL +],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #fin-comp & verb-or-comp & [INV -, ;verb-all
						  DECL +],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   NON-HEAD-DTR connect-v-mod-2-phrase,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [INV -, ;verb-all
						      DECL +]].

s-connect-objdel-phrase := s-connect-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD #fin-comp & [INV -, ;verb-all
				     DECL +],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   SYNSEM.LOCAL.CAT.QVAL.DOBJECT #qval,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED -,
   HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #fin-comp & verb-or-comp & [INV -, ;verb-all
						  DECL +],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT #qval,
;   HEAD-DTR.SYNSEM.BY-DELETION +,
;   NON-HEAD-DTR.SYNSEM.BY-DELETION -,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT #qval,
   NON-HEAD-DTR connect-v-mod-2-phrase,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [INV -, ;verb-all
						      DECL +]].

s-wh-connect-phrase := s-connect-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
				     DECL -,
				     MAIN-CL #maincl],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
					      DECL -,
					      MAIN-CL #maincl,
					      WH-COMPLETE bool], ;+
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
;   HEAD-DTR.SYNSEM.BY-DELETION -,
   NON-HEAD-DTR connect-wh-v-mod-2-phrase, ; why would this specification be too restrictive? without it, any two VPs can be taken as coordinated, it seems.
   NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
						  DECL -,
						  WH-COMPLETE bool, ;+
						  MAIN-CL #maincl]].

s-wh-connect-objdel-phrase := s-connect-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
				     DECL -,
				     MAIN-CL #maincl],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.CAT.QVAL.DOBJECT #qval,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED -,
   HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
					      DECL -,
					      MAIN-CL #maincl,
					      WH-COMPLETE bool], ;+
   HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT #qval,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
;   HEAD-DTR.SYNSEM.BY-DELETION +,
   NON-HEAD-DTR connect-wh-v-mod-2-phrase, ; why would this specification be too restrictive? without it, any two VPs can be taken as coordinated, it seems.
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT #qval,
   NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
						  DECL -,
						  WH-COMPLETE bool, ;+
						  MAIN-CL #maincl]].

s-rel-connect-phrase := s-connect-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
				     DECL +,
				     MAIN-CL -],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   SYNSEM.LOCAL.CONT.HOOK.XARG #4,
;   SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom]>,
;   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
;					      DECL +,
;					      MAIN-CL -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #4,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
;   NON-HEAD-DTR connect-relative-v-mod-2-phrase,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #4,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
						  DECL +,
						  MAIN-CL -]].

s-comp-connect-phrase := s-connect-phrase-sup &
 [ SYNSEM.LOCAL.CAT.HEAD fin-comp,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp,
   NON-HEAD-DTR connect-comp-v-mod-2-phrase,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp].

;s-connect-inv-phrase := s-connect-phrase-sup &
; [ HEAD-DTR another-basic-head-subj-phrase ].

s-connect-inv-phrase := s-connect-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +],
   HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
   NON-HEAD-DTR connect-v-mod-2-phrase ].

;s-connect-gap-phrase := head-adj-phrase & rule &
; [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -],
;   HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;   NON-HEAD-DTR head-pero-comp-phrase-sup ].



#|
a-connect-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    NON-HEAD-DTR connect-a-mod-phrase,
;    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    C-CONT [RELS <! !>,
            HCONS <! !>]].
|#

; gul  +  og gr√∏nn
 a-connect-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.AGR #agr,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.IS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #arg1,
    HEAD-DTR.SYNSEM.LOCAL.AGR #agr,
    HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR #agr,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG1 #arg1,
    NON-HEAD-DTR connect-a-mod-phrase, ; was commented out, with consequence that en glad hyggelig gutt was parsed as a case of a-connect-rule, with enormous parse wood. Not sure why the line was commented out, will probably see.... LH08012021
     C-CONT [RELS <! !>,
             HCONS <! !>]].


; her  +  og der
p-adv-connect-phrase := head-adj-phrase & rule &
  [ NON-HEAD-DTR connect-p-adv-mod-phrase,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY index-sit1],
	      SYNSEM.LOCAL.HAS-PUNCT -],
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; hit  +  og dit
p-adv-dir-connect-phrase := head-adj-phrase & rule &
  [ NON-HEAD-DTR connect-p-adv-dir-mod-phrase,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY dir-sup],
	      SYNSEM.LOCAL.HAS-PUNCT -],
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; combines  jeg  +  og Ola
n-connect-phrase := head-adj-phrase-2 & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    SYNSEM.LOCAL.MUST-COORD-PROJECT +,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR [SYNSEM.LOCAL.MUST-COORDINATE -,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #2],
    NON-HEAD-DTR connect-n-mod-phrase & [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
					 SYNSEM.LOCAL.XLBL #lbl],
    C-CONT [RELS <! arg12-relation & [ LBL #lbl,
				       PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
            HCONS <! !>]].

; projects 'jeg og Ola' from n-connect-phrase to a smuggling of XARG into INDEX role - required by this adjunction-based approach to n-coordination
n-coord-projection-phrase := headed-phrase &
  [ SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
 ;   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.MUST-COORD-PROJECT -,
    SYNSEM.LOCAL.CONT.RELS #rels,
    SYNSEM.LOCAL.CONT.HCONS #hcons,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.LOCAL.MUST-COORDINATE #11,
    SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR #hd,
    HEAD-DTR n-connect-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS #rels,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #hcons,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE #11,
    HEAD-DTR.SYNSEM.LOCAL.MUST-COORD-PROJECT +,
    ARGS < #hd >,
    C-CONT [RELS <! !>,  ;LH050416
            HCONS <! !>] ].
    
; projects 'og' to a fs where the lbl of its first ep is 'forgotten'
n-connector-projection-phrase := headed-phrase &
  [ SYNSEM.LOCAL.CAT #cat,
 ;   SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG0 #1,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.CONT.RELS #rels,
    SYNSEM.LOCAL.CONT.HCONS #hcons,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR #hd,
;    HEAD-DTR n-connect-word,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG0 #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS #rels,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #hcons,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR.SYNSEM.LOCAL.MUST-CONNECT-PROJECT +,
    ARGS < #hd >,
    C-CONT [RELS <! !>,  ;LH050416
            HCONS <! !>] ].
   

; projects 'Ola' before joing with 'og' so that its labels are 'forgotten' before the adjunction travel up the tree
n-projection-phrase := headed-phrase &
  [ SYNSEM.LOCAL.CAT #cat,
 ;   SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG0 #1,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.MUST-COORDINATE +,
    SYNSEM.LOCAL.CONT.RELS #rels,
    SYNSEM.LOCAL.CONT.HCONS #hcons,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.LOCAL.BND-RESP #resp, 
    SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR #hd,
;    HEAD-DTR proper-name-word,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD postposspron,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG0 #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS #rels,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #hcons,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR.SYNSEM.LOCAL.MUST-CONNECT-PROJECT +,
    ARGS < #hd >,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].



parenthesis-mod-vp-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR right-parenthesis-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [RELS <! !>,
            HCONS <! !>]].


postnom-poss-phrase-sup :=  basic-head-mod-phrase-simple-sup & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
    SYNSEM.LOCAL.BINDING #35,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM lex-synsem,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #35,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD postposspron,
    C-CONT [RELS <! !>,
            HCONS <! !>]].


; LH050513: NON-HEAD-DTR n-projection-phrase, is in order to force labels to differ between poospron and noun, to create wellformed mra

#|
postnom-poss-phrase-experm := postnom-poss-phrase-sup & head-adj-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [PNG.NG #4],
    SYNSEM.LOCAL.BND-RESP #bnd,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    NON-HEAD-DTR n-projection-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #5]>].


postnom-poss-phrase := postnom-poss-phrase-sup & head-adj-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [PNG.NG #4],
    SYNSEM.LOCAL.BND-RESP #bnd,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    NON-HEAD-DTR n-projection-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #5]>].
|#
telic-mod-vp-phrase := head-adj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ].


atelic-mod-vp-phrase := head-adj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

#|
; new ancestry, due to MalGram
; has been moved to exp-types.tdl, and there defined from a type defined in mal-types.tdl in turn! But the content is the same.

front-mod-vp-phrase := adj-head-phrase &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC bool,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.FRONT-TO-FILL + ].
|#

atelic-front-mod-vp-phrase := front-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY reg ].

telic-front-mod-vp-phrase := front-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixpt-dir ].

; does not inherit from front-mod-vp-phrase, since this inherits from 
;adj-head-phrase, where C-CONT.RELS is empty. Since this holds for all 
;'normal' front-adj, rather have this one inherit from 
; basic-head-mod-phrase-simple.
np-front-mod-vp-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD #infl,
    SYNSEM.LOCAL.CONT.HOOK [ INDEX #1,
                             LTOP #40 ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2 & <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    FRONT-TO-FILL -,
    HEAD-DTR.FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #infl & non-copula & [INV +,
						       DECL +,
						       MAIN-CL +,
						       IMPERATIVE -,
						       MOD <>],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ <>,
				       SPR <>,
				       SPEC <>,
				       COMPS <>,
				       ICOMPS <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT time-item ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY crdfix],
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    C-CONT.RELS <! arg12-relation & [ PRED "time-sit-at_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !>  ].



non-aspect-mod-vp-phrase := head-adj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

;perhaps split into two: one for adv modifying V-proj, where we want a
; non-null subject, and one for modify N and Adv-proj, where SUBJ is 
; empty
adv-mod-phrase := head-adj-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv,

    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; n-or-adj-or-adv
cmpar-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.CMPAR-SAT +,
    SYNSEM.LOCAL.CAT.VAL.COMPS #cmps,
    SYNSEM.NON-LOCAL #41,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD n-or-adj,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    RULE #7,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG.ROLE compare-top &
;			     [ COMPARE-INSTNCE #cmp ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #cmps,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING +,
    HEAD-DTR.SYNSEM.CMPAR-SAT -,
    HEAD-DTR.RULE #7,
    HEAD-DTR.SYNSEM.LEX bool, ; - , to ensure 's√•' in 's√• stor som mulig' as cmpar-dep-reg-cluster-word. But not in general.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [MOD <[LOCAL.CONT.HOOK.CMPAR-PRED #4]>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #dep,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #41,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE compare-ref &
;			     [ COMPARE-INSTNCE #cmp ],
    C-CONT [RELS <! !>,
            HCONS <! !>] ].


mod-front-phrase := var-cc_opn-adj-head-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < anti-synsem >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

#|
; temp redefined
mod-front-phrase := var-cc_opn-adj-head-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < anti-synsem >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #ind, LTOP #lbl ], ;; MHS 180511 Add re-entrancy of LTOP and LBL to fix leaf/hole mismatch.
    C-CONT [RELS.LIST.FIRST fpos_prom_rel & [ ARG1 #ind, LBL #lbl ],
            HCONS <! !>]].
|#

; var-cc_opn-adj-head-phrase is defined in mal-types.tdl, in turn based on new types in matrix.tdl. Regular types shouldn't emerge from a mal-dedicated file.

front-mod-vp-phrase := var-cc_opn-adj-head-phrase &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC bool,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.FRONT-TO-FILL + ].


#|
mod-front-phrase := adj-head-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.LOCAL.HAS-REL-CL #hrlc,		;; EAA. NorMal. 140211. PXB-NS.
    SYNSEM.LOCAL.REL-CL-SOM-INIT #rlsci,	;; EAA. NorMal. 140211. PXB-NS.
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL #hrlc,		;; EAA. NorMal. 140211. PXB-NS.
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #rlsci,	;; EAA. NorMal. 140211. PXB-NS.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

|#

adv-mod-front-phrase := mod-front-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv ].

pp-mod-front-phrase := mod-front-phrase &
  [ SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp ].

;adjective-mod-front-phrase := mod-front-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg ].




; does not inherit from front-mod-vp-phrase, since this inherits from 
;adj-head-phrase, where C-CONT.RELS is empty. Since this holds for all 
;'normal' front-adj, rather have this one inherit from 
; basic-head-mod-phrase-simple.
; removed SYNSEM.LOCAL.ADJ-SITE-OPEN - from mother, to allow recursion, but...


np-mod-vp-time-phrase-sup := basic-head-mod-phrase-simple & head-initial &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CAT.QVAL #4q,
    SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
     SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
;    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #bind,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb ],
             SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL #4,
	     SYNSEM.LOCAL.CAT.QVAL #4q,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             FRONT-TO-FILL #3,
              EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.NEED-IMP-UNARY #43 & +,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
	     SYNSEM.LOCAL.BND-RESP #bind ],
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT time-item ],
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL.SPEC <>,
             SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
             SYNSEM.LOCAL.CAT.VAL.SPR <>,
             SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
	     SYNSEM.LOCAL.DERIVED-HEAD -,
	     SYNSEM.LOCAL.CARD-TO-BARE-N -,
	     SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
	     SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.CAT.HEAD noun, ;card-nom & [KEYS.KEY crdfix,
					     ;  BARE bool], ; have tried '-', but there is 'han kommer s√∏ndag'...
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
					 LOCAL.CAT.VAL [COMPS <>]]>]>,
    C-CONT.RELS <! arg12-relation & [ PRED "time-sit-at_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].

np-weekday-mod-vp-time-phrase := np-mod-vp-time-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY weekday-noun]].

; 'LEX -' to ensure that "... 25 √•r" is not analyzed with "√•r" as vp-modifier. But that rules out 'jeg kommer mandag'. So something smarter must be sought ...
np-mod-vp-time-phrase := np-mod-vp-time-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LEX bool ].

; for "kommer hver dag/hvert √•r", as opposed to "kommer onsdag"
quantnp-mod-vp-time-phrase := basic-head-mod-phrase-simple & head-initial &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CAT.QVAL #4q,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
;    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #rel,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.HEAD verb-all,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL #4,
	     SYNSEM.LOCAL.CAT.QVAL #4q,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             FRONT-TO-FILL #3,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.NEED-IMP-UNARY #43 & +,
	     SYNSEM.LOCAL.REL-CL-SOM-INIT #rel,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ],
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT time-item ],
             SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY timemeas-noun],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]>,
             SYNSEM.LOCAL.HAS-PUNCT -,
	     SYNSEM.LOCAL.CONT.RELS.LIST.FIRST [PRED "_univ_q_rel"]] >,
    C-CONT.RELS <! arg12-relation & [ PRED "time-sit-at_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].

np-mod-vp-length-phrase := basic-head-mod-phrase-simple & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CAT.QVAL #4q,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CONT.HOOK.DIRARG #12dir,
             SYNSEM.LOCAL.CAT.HEAD verb-all,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
	     SYNSEM.LOCAL.CAT.QVAL #4q,
             SYNSEM.LOCAL.CONT.HOOK #2,
	     SYNSEM.LOCAL.BND-RESP.FIRST.ANAPH-TYPE.BOUND -,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             FRONT-TO-FILL #3,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.NEED-IMP-UNARY #43 & +,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ],
           [ SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY measnoun],
             SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT length-unit ],
             SYNSEM.LOCAL.CAT.VAL.SPR <>,
             SYNSEM.LOCAL.CAT.VAL.SPEC <>,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]>]>,
    C-CONT.RELS <! arg12-relation & [ PRED "measure-out-path-of_rel",
                                      LBL #40,
                                      ARG1 #5,
                                      ARG2 #12dir ] !>,
    C-CONT.HCONS <! !> ].

#|
correlative-inv-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite,
                                                E.MOOD indicative],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
             SYNSEM.NON-LOCAL.SLASH #8,
             SYNSEM.LOCAL.HAS-PUNCT -,
             FRONT-TO-FILL + ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].
|#

; comma-rightmod-for-inv-v-phrase & 
           
correlative-inv-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +,
					       MAIN-CL -,
					       IMPERATIVE -],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


; works well for 'jo snillere du er, jo snillere er jeg', corect mrs. Produces correct trees also for 'jo raskere du l√∏per, jo snillere er jeg' and 'jo mer du spiser, jo snillere er jeg' (with 'spise' transitive), but fails to represent adverb derivation in the former, and in the latter case construing the front part as a relative constr - by itself not so bad, but probably not with the right semantics.  "jo" belongs to category degreecmpar-spec-word, in both occurrences. (Same for dess, desto.)

correlative-jo-jo-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
;    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite],
;             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                               DECL -,
					       MAIN-CL -,
					       IMPERATIVE -],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.LOCAL.CAT.VAL.COMPS < >,
             SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
 ;            SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
 ;            SYNSEM.LOCAL.CAT.VAL.SUBJ < anti-synsem >,
 ;            SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.VAL.COMPS < >,
             SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
 ;            EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


           
hvis-s√•-inv-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD adjct-comp,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].

           
hvis-s√•-command-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD adjct-comp,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                               IMPERATIVE + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].

           
hvis-s√•-question-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD adjct-comp,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL -,
                                               IMPERATIVE - ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


 correlative-interjct-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <>,
    SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.LOCAL.HAS-INTERJECTION +,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < sign &
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD interjection,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
             SYNSEM.NON-LOCAL.SLASH #8,
             SYNSEM.LOCAL.HAS-PUNCT -,
             FRONT-TO-FILL + ],           
           [ SYNSEM.NON-LOCAL.SLASH #8,    
	     SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4 & [SUBJ olist,
					SPR <>,
					COMPS <>,
					ICOMPS <>,
					SPEC <>],
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PERIOD -,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].


; comma-rightmod-for-interjct-v-phrase & 
;comma-rightmod-interjct-phrase
correlative-interjct-comma-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS <   comma-rightmod-interjct-phrase &
	     [ SYNSEM.LOCAL.CAT.HEAD interjection,
;             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
;	       SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
              SYNSEM.LOCAL.HAS-PUNCT +,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
 ;            SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
 ;            SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
 ;            SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
 ;            SYNSEM.LOCAL.CAN-NP-MOD +,
 ;            SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.HAS-PERIOD -,
;             SYNSEM.LOCAL.WH-ISLAND -,  ;preventing combination with connect-v - but that is not always bad
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! !>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


correlative-adj-interjct-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < sign &
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY adj-decl-selct],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
             SYNSEM.NON-LOCAL.SLASH #8,
             SYNSEM.LOCAL.HAS-PUNCT -,
             FRONT-TO-FILL + ],           
           [ SYNSEM.LOCAL.CAT.VAL #4,
;             SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite], ; for "hei gutter"
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PERIOD -,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].



correlative-adj-interjct-comma-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
 ;   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS <   comma-rightmod-adj-interjct-phrase &
	     [ SYNSEM.LOCAL.CAT.HEAD adj,
;             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
;	       SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
              SYNSEM.LOCAL.HAS-PUNCT +,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
 ;            SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
 ;            SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
 ;            SYNSEM.LOCAL.CONT.HOOK.VARG #12,
 ;            SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
 ;            SYNSEM.LOCAL.CAN-NP-MOD +,
 ;            SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.HAS-PERIOD -,
;             SYNSEM.LOCAL.WH-ISLAND -,  ;preventing combination with connect-v - but that is not always bad
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! !>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


;SYNSEM.NON-LOCAL.SLASH #8,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
        
;SYNSEM.LOCAL.CAT.VAL #4
pp-mod-vp-or-derivadj-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comp & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomp,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    FRONT-TO-FILL #3,
;    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.COMPS-BEGUN #cb,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
;    SYNSEM.NON-LOCAL.SLASH #8,  ; gaps may come from either branch, so no sense in allowing only one possibility.  "hva fort√¶rer du for √• snorke?"
;    SYNSEM.NON-LOCAL.SLASH #8,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomp,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #cb,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.FRONT-TO-FILL #3, ;; MHS 180713 New. I don't see why this re-entrancy was previously only on the non-head-dtr. See sentences such as 'Smiler mannen med godt hum√∏r.' for why this is needed.
    NON-HEAD-DTR.FRONT-TO-FILL #3,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
;    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist, ;<>
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND bool ]. ; was '-', but too strong


pp-mod-vp-phrase := pp-mod-vp-or-derivadj-phrase &
  [ SYNSEM.LOCAL.HAS-WH-MOVED #mov,
    SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED #del & -,
    SYNSEM.VAL-CLASS #vc,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #mov,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #del,
    HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX.SORT referential-thing, ; rules out "pr. time", "pr. tonn", since "pr." is prep-word-reg.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]> ].

pp-time-mod-vp-phrase := pp-mod-vp-or-derivadj-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    SYNSEM.LOCAL.HAS-WH-MOVED #mov,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED #obdel,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #obdel,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #mov,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE temporal,; covers also 'g√• til byen p√• to timer'
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [TEL-FIXING +],
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX.SORT time-item,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]> ].

#|    
pp-mod-vp-phrase := pp-mod-vp-or-derivadj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -].
|#    
pp-mod-derivadj-phrase := pp-mod-vp-or-derivadj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [MOD <[LOCAL.CAT.HEAD adj-reg,
						     LOCAL.CAT.VAL [COMPS <>]]>] ].
    
pp-mod-front-vp-phrase := pp-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

pp-mod-front-imperative-vp-phrase := pp-mod-front-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      IMPERATIVE +,
				      MAIN-CL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    EXTRINSIC-ORD complete-imp, ; meant to reduce parses, but sits too far out to be useable in constraint on exclam-mark, so only partly successful
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    FRONT-TO-FILL -,
    HEAD-DTR.EXTRINSIC-ORD complete-imp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
					       IMPERATIVE +,
					       MAIN-CL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV -],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

; wait with these until mechanism for percol WH+ from NP up to PP
pp-interr-mod-front-vp-phrase := pp-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

atelic-front-pp-mod-vp-phrase:= pp-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-front-pp-mod-vp-nonfixptdir-phrase := atelic-front-pp-mod-vp-phrase & nonfixpt-dir-mod. 
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-front-pp-mod-vp-index-sit-phrase := atelic-front-pp-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-front-pp-mod-vp-phrase:= pp-mod-front-vp-phrase & telic-front-mod-vp-phrase.

atelic-interr-front-pp-mod-vp-phrase := pp-interr-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-interr-front-pp-mod-vp-nonfixptdir-phrase := atelic-interr-front-pp-mod-vp-phrase & nonfixpt-dir-mod.
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-interr-front-pp-mod-vp-index-sit-phrase := atelic-interr-front-pp-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-interr-front-pp-mod-vp-phrase:= pp-interr-mod-front-vp-phrase & telic-front-mod-vp-phrase.

; 'antilist' on second lowest line, so that V-proj with inverted subj
; and normal ones get treated alike - meaning that head-subject-rule
; applies before the application of this one. If using 'cons', that
; yields double parse for all non-inverted cases, and that gets
; explosive. For the MRSes it doesn't matter.
;;;;;;;; Dec05: commented this rule out, since not sure what's missed
pp-mod-vp-2-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.NON-LOCAL.SLASH #8,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10 & +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #2,
    HEAD-DTR.FRONT-TO-FILL #3,
    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ antilist,
                                                            COMPS <>]]>].

; these subtypes carry the good intention of yielding only one parse for
; "jeg sitter bak huset". But it yields an explosion in the rule
; inventory - a lot of PP-attachment rules inherit from the one above.
; Rather hope for a smart insight...
;pp-mod-vp-noninv-phrase := pp-mod-vp-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD.INV -,
;                                             LOCAL.CAT.VAL [SUBJ 1-list]>].
;pp-mod-vp-inv-phrase := pp-mod-vp-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD.INV +,
;                                             LOCAL.CAT.VAL [SUBJ antilist]>].

;cancelled the computation of telicity under for modification, to
;first get the Role constraints of predsort to work -db jan05
; but now get telfixing to work -lh feb05


telfix-pathtelicity-pp-mod-vp-phrase := pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC #1 & bool,
    SYNSEM.LOCAL.PATHTELFIXED +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC #1,
    HEAD-DTR.SYNSEM.LOCAL.PATHTELFIXED -,
    HEAD-DTR.SYNSEM.LOCAL.PATHTELACTV +,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT telmarking,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING +,
                                        SELECTED -,
                                        KEYS.KEY telfix]].

telfix-pathtelic-pp-mod-vp-phrase := telfix-pathtelicity-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time ].

telfix-path-atelic-pp-mod-vp-phrase := telfix-pathtelicity-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time ].


telfix-delimitedness-pp-mod-vp-phrase := pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED #1 & bool,
    SYNSEM.LOCAL.DELIMTELFIXED +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED #1,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELFIXED -,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV +,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT telmarking,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING +,
                                        SELECTED -,
                                        KEYS.KEY delimfix]].

telfix-delim-pp-mod-vp-phrase := telfix-delimitedness-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time ].

telfix-nondelim-pp-mod-vp-phrase := telfix-delimitedness-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time ].




; the HAS-PUNCT restriction on NON-HEAD perhaps applies only to subtypes
pp-mod-n-phrase-sup := pp-mod-phrase &
  [ SYNSEM.LOCAL.BINDING #5,
    SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.MUST-APP #7,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.NON-LOCAL.SLASH #slash,
    RULE #6,
;    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #5,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
    HEAD-DTR.SYNSEM.LOCAL.MUST-APP #7,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-verb & [SELECTED -], ; 'dagen jeg s√• deg'
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT full-thing,  ; hopefully not too restrictive
;    NON-HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

;KEYS.KEY absnoun						
pp-mod-n-phrase := pp-mod-n-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [RELATIONAL -], ; & [KEYS.KEY non-measurnoun]
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -]].

pp-timecl-mod-n-phrase := pp-mod-n-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY meastimenoun],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,; 73604140 30.07. kl 9 Hanne, 'booking'
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp & [SELECTED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time ].

pp-placecl-mod-n-phrase := pp-mod-n-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp & [SELECTED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place].

pp-mod-bare-n-phrase := pp-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE +] ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD - ]. ;somewhat uncertain


pp-mod-bare-n-index-sit-phrase := pp-mod-bare-n-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT full-thing ].
pp-mod-bare-n-nonfixpt-dir-phrase := pp-mod-bare-n-phrase & nonfixpt-dir-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].
pp-mod-bare-n-fixpt-phrase := pp-mod-bare-n-phrase & fixpt-mod.



pp-mod-defbare-n-phrase := pp-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE bool, ; +, defbare means only that no SPR is required
                                                                     DEF +,
                                                                     DEFINITE bool ] ]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX.SORT referential-thing, ; to avoid 'boka mellom klokka ni og ti'
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>]. ; list instead of <> 'bare' should mean empty SPR, but get problems with "maten til barna sover"

pp-mod-defbare-n-index-sit-phrase := pp-mod-defbare-n-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].

pp-mod-defbare-n-nonfixpt-dir-phrase := pp-mod-defbare-n-phrase & nonfixpt-dir-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].

pp-mod-defbare-n-fixpt-phrase := pp-mod-defbare-n-phrase & fixpt-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].


pp-mod-spr-n-phrase := pp-mod-n-phrase &
  [ SYNSEM.UNDERGOER-OPEN #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[UNDERGOER-OPEN #2,
                                             LOCAL.CAT.HEAD noun,
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR < [] > ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [] > ].

pp-mod-spr-n-index-sit-phrase := pp-mod-spr-n-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
pp-mod-spr-n-nonfixpt-dir-phrase := pp-mod-spr-n-phrase & nonfixpt-dir-mod.
pp-mod-spr-n-fixpt-phrase := pp-mod-spr-n-phrase & fixpt-mod.

; a lot of subtypes could be introduced here, like for pp-mod-n-phrase
  ;  SYNSEM.NON-LOCAL #nl, ;; MHS 190713 This type inherits from basic-head--mod-phrase-simple-sup, which has non-local amalgation defined. As such, these re-entrancies are inappropriate.
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl

pp-mod-rel-n-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun],
    SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.LOCAL.CAT.VAL #val & [SUBJ OLIST,
				 COMPS null,
				 ICOMPS null,
				 SPEC null,
				 SPR LIST], ; was null, preventing combination with genitive
    SYNSEM.LOCAL.DERIVED-HEAD #derh,
    RULE #6,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun,
						RELATIONAL +],
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum, ; with dirnoun as subtype of relnoun, no reason to bring this feature in conflict with all the SORT features going with directionals
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; LH18092018 must have '-' here, but loses 'ni av guttene' on current analysis LH12032019 but we need that now
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #derh,
;    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,; loses 'ni av guttene' on current analysis
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-EXTRACTION-APPLIED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [ KEYS.KEY actv-prep,
						      N-to-N-RELATIONAL-P bool ]]. ;  +  preprel ]].

pp-mod-relinf-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.NON-LOCAL #nl,
    SYNSEM.LOCAL.CAT.VAL #val & [SUBJ null,
				 COMPS null,
				 ICOMPS null,
				 SPEC null,
				 SPR null],
    RULE #6,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11 & -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [ KEYS.KEY rais ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.XARG #ind ].

;"to uker av ferien" "de dager av ferien"
pp-mod-rel-meas-n-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.LOCAL.CAT.VAL #val & [SUBJ OLIST,
				 COMPS null,
				 ICOMPS null,
				 SPEC null,
				 SPR LIST], ; was null, preventing combination with genitive
  ;  SYNSEM.NON-LOCAL #nl, ;; MHS 190713 This type inherits from basic-head--mod-phrase-simple-sup, which has non-local amalgation defined. As such, these re-entrancies are inappropriate.
    RULE #6,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY measurnoun],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT sort, ;relatum,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; LH18092018 must have '-' here, but loses 'ni av guttene' on current analysis
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,; loses 'ni av guttene' on current analysis
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [ KEYS.KEY actv-prep ]].


#| mixing in types from PREDSORTS:
;pp-mod-n-phrase-reg := pp-mod-n-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG0.ROLE xdim-to-xdim ].

;pp-mod-n-phrase-dirarg := pp-mod-n-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.IARG.CLASS line-to-xdim ].
|#
;LEG

pp-mod-x-phrase := pp-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [MOD <[LOCAL.CAT.HEAD head,
							   LOCAL.CAT.VAL [SUBJ list,
									  COMPS <>]]>],
    SYNSEM.LOCAL.CONT.HOOK.XLEG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XLEG #1].


; pp modif vp, will induce leg identity
pp-mod-vp-phrase2 := pp-mod-x-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>] ]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH - ].

pp-mod-adv-dir-phrase := pp-mod-x-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.DIRARG #3]>,
    SYNSEM.NON-LOCAL #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -, ; perhaps a bit strong, but ...
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT -,
	     SYNSEM.LOCAL.WH-ISLAND -], 
	   [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
	    SYNSEM.NON-LOCAL #nl,
;	    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
	    SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -]>].


pp-mod-pp-dir-phrase := pp-mod-x-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.DIRARG #1]>,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD prep,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -, ; perhaps a bit strong, but ...,
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT - ], 
           [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.HAS-PUNCT -,
            SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -]>]. ; SYNSEM.LOCAL.CONT.HOOK.INDEX #2

; removed 'nonfixpt-dir-mod &' from top line: nonfixpt-dir is not compatible
; with nonfixpt-dir2
pp-mod-pp-orient-phrase := pp-mod-pp-dir-phrase & 
  [ ARGS < [SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point], 
           [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY nonfixpt-dir2] >].

; removed 'fixpt-mod &' to get "inn til fjellet"
pp-mod-pp-fixpt-phrase := pp-mod-pp-dir-phrase  & 
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ],
	    SYNSEM.LOCAL.WH-ISLAND -], 
	   [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixptconsumpt-dir2] >].



; adjunction to an adv modifying a verb
pp-mod-adv-orient-phrase := pp-mod-adv-dir-phrase &
  [ ARGS < orient-adv-word, [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY nonfixpt-dir2] >].

; removed 'fixpt-mod &' to get "inn til fjellet"
pp-mod-adv-fixpt-phrase := pp-mod-adv-dir-phrase  & 
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ],
	    SYNSEM.LOCAL.WH-ISLAND -], 
	   [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixptconsumpt-dir2] >].

; pp modif adv, inducing leg identity, and hooking onto VARG of verb 
;(next step) (only type inheriting from pp-mod-adv-dir-phrase - so could
; perhaps be a single type
;pp-mod-pp-phrase1 := pp-mod-pp-dir-phrase  &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #3]>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
;    HEAD-DTR.SYNSEM.LKEYS.KEYREL prep-path-rel ].

adv-mod-x-phrase := adv-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD head,
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS <>]]>,
    SYNSEM.LOCAL.CONT.HOOK.XLEG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XLEG #1].

;adv-mod-adv-orient-phrase := adv-mod-x-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #2]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
;    ARGS < orient-adv-word & [ SYNSEM.LOCAL.CAT.HEAD adv,
;                               SYNSEM.LOCAL.CONT.HOOK.XARG #1], 
;           [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;            SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -]>].

adv-mod-adv-dir-phrase := adv-mod-x-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #3]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
	     SYNSEM.LOCAL.WH-ISLAND -], 
           [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
            SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -]>]. ;  SYNSEM.LOCAL.CONT.HOOK.INDEX #2

adv-mod-adv-orient-phrase := adv-mod-adv-dir-phrase &
  [ ARGS < orient-adv-word, [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY orient-dir] >].

; removed 'fixpt-mod &'
adv-mod-adv-fixpt-phrase := adv-mod-adv-dir-phrase  & 
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ]], [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixptconsumpt-dir2] >].

; this should in principle work
;adv-mod-adv-fixpt-comma-phrase := adv-mod-adv-dir-phrase  &  
;  [ NON-HEAD-DTR comma-mod-phrase & [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ]]].


; adv modif adv, hooking onto VARG of verb 
; both head and non-head adv are fed by orient-adv-word; yield only
; distinct ARG0s
; "gutten rusler inn vekk"
;adv-mod-adv-phrase1 := adv-mod-adv-dir-phrase  &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    ARGS < orient-adv-word, [] >].

adv-mod-vp-phrase2 := adv-mod-x-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ <synsem-min>,
                                                            COMPS <>,
                                                            ICOMPS <>,
                                                            SPR <>,
                                                            SPEC <>]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH - ].



; pp modif adv, event modif, identical ARG1
pp-mod-adv-reg-phrase := pp-mod-phrase & index-sit-mod &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.NON-LOCAL #nl, ;; MHS 190713 This type inherits from basic-head-mod-phrase-simple-sup.
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.DERIVED-HEAD -,
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT -], 
	   [SYNSEM.IDIOMOD +,  ; SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
	    SYNSEM.NON-LOCAL #nl,
            SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit2]]>].


; pp modifying adv, both as event-modif, and hooking on to INDEX of verb
;pp-mod-adv-phrase2 := pp-mod-adv-reg-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1, ].

; pp modif pp, event modif, identical ARG1
pp-mod-pp-reg-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #2]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD prep,
             SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.COMPS-BEGUN -], 
           [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit2 ]]>].

; pp modifying pp, both as event-modif, and hooking on to INDEX of verb
;pp-mod-pp-phrase2 := pp-mod-pp-reg-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; forcing any adv to join after SPR has combined
adv-mod-n-phrase := adv-mod-phrase & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    RULE #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    HEAD-DTR.RULE #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

; these specifications of what can combine with the N seem crazy; so, try without...
#|
adv-mod-defbare-n-phrase := adv-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE -,
                                                                     DEFINITE + ],
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR list ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

adv-mod-bare-n-phrase := adv-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE + ],
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR list ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
|#

; intended with ,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [] >
; but too many parses
; this for directional nouns - 
adv-mod-spr-n-phrase := adv-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    RULE #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.RULE #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK dir-hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun,
                                              LOCAL.CAT.VAL.SPR cons ]> ].


advdir-mod-n-phrase := adv-mod-n-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK dir-hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
                                             LOCAL.CAT.HEAD.KEYS.KEY dirnoun]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir].

advdir-fixpt-mod-n-phrase := advdir-mod-n-phrase & fixpt-mod.

; experiment only!
#|
;advdir-fixpt-mod-bare-n-phrase := advdir-fixpt-mod-n-phrase & adv-mod-bare-n-phrase.
advdir-fixpt-mod-spr-n-phrase := advdir-fixpt-mod-n-phrase & adv-mod-spr-n-phrase.
advdir-fixpt-mod-defbare-n-phrase := advdir-fixpt-mod-n-phrase & adv-mod-defbare-n-phrase.
|#



advdir-nonfixpt-mod-n-phrase := advdir-mod-n-phrase & nonfixpt-dir-mod.

; experiment only!
#|
advdir-nonfixpt-mod-bare-n-phrase := advdir-nonfixpt-mod-n-phrase & adv-mod-bare-n-phrase.
advdir-nonfixpt-mod-spr-n-phrase := advdir-nonfixpt-mod-n-phrase & adv-mod-spr-n-phrase.
advdir-nonfixpt-mod-defbare-n-phrase := advdir-nonfixpt-mod-n-phrase & adv-mod-defbare-n-phrase.
|#

; allows "gutten/en gutt der sover",
; but excludes "*det sover [en gutt der]" 
advreg-mod-n-phrase := adv-mod-n-phrase & index-sit-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRESENTED -,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +, ; tempting; "en kopp der" is a small clause
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.SORT full-thing]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim-spatial ].

; en kopp til
advprtcl-mod-n-phrase := adv-mod-n-phrase &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRESENTED -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.SORT full-thing]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY pcl ].

; experiment only!
#|
advreg-mod-bare-n-phrase := advreg-mod-n-phrase & adv-mod-bare-n-phrase.
advreg-mod-spr-n-phrase := advreg-mod-n-phrase & adv-mod-spr-n-phrase.
advreg-mod-defbare-n-phrase := advreg-mod-n-phrase & adv-mod-defbare-n-phrase.
|#

; adv modif adv, event modif, identical INDEX. Head adv fed by adv-word-reg,
; non-head adv fed by adv-word-2-reg
; "gutten rusler inne borte"
adv-mod-adv-reg-phrase := adv-mod-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
 ;            SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT -], 
           [SYNSEM.LOCAL.HAS-PUNCT -, ; SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
            SYNSEM.IDIOMOD +]>].

; inherits from the above
; adv modif adv, event modif, identical INDEX. Head adv fed by adv-word-reg,
; non-head adv fed by adv-word-2-reg
; "gutten rusler inne borte"
;adv-mod-adv-phrase2 := adv-mod-adv-reg-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

adv-mod-vp-phrase := adv-mod-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
    EXTRACTED-FROM #10,
    FRONT-TO-FILL #33,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.COMPS-BEGUN #cb,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED #obdelapp,
    SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.FRONT-TO-FILL #33,
    HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.INV-DECL-PRECARIOUS #prec,
    HEAD-DTR.SYNSEM.LOCAL.INV-DECL-PRECARIOUS #prec,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED #obdelapp & -,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #cb,
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ cons,
                                                            COMPS <>,
                                                            ICOMPS <>]]> ].

adv-mod-front-vp-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL bool], ; from +
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,  ; her i skogen sover jeg ikke - 6 parses
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL bool], ; from +
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING - ].

adv-interr-mod-front-vp-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3, 
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +],
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING - ].

adv-interr-mod-front-subordcl-phrase := adv-mod-front-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
				      MAIN-CL -,
				      WH-MOVED -,
				      WH-COMPLETE bool], ;+
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
;    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,  ;LH111216 Comment out, to allow 'jeg vet hvor du bor'
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED -,
    HEAD-DTR.SYNSEM.LOCAL.NEED-Q-MARK -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV -],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING - ].

;for vet hvor du bor
;adv-interr-mod-front-filler-subordcl-phrase := head-filler-adv-topic-phrase.
;;;;;;;;;;;;;
; removed on Francis' request
;SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    
    
adjective-mod-vp-phrase := head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.BND-RESP #respbind,
    SYNSEM.LOCAL.WAIT-BND-RESP #waitbind,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #respbind,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #waitbind,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb-norm,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #2,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.FRONT-TO-FILL #3,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    NON-HEAD-DTR.EXTRACTED-FROM -,
    C-CONT.HCONS <! !> ].


free-subjpred-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    SYNSEM.LOCAL.CAT.HEAD  #head,
    SYNSEM.NON-LOCAL.SLASH #sl,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD  #head,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #sl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -,
						  KEYS.KEY propt],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].

; 'HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active' blocks overgenerations
; allowed by ref to 'VARG'; but blocks free-objpred in passive ditrans
; needs more constraining: 'VARG' can be conjured up from a VP even when it has no arg12-relation head
; SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
;    
free-objpred-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    SYNSEM.LOCAL.CAT.HEAD  #head,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD  #head,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup & [DOBJECT.LOCAL.DERIVED-HEAD -,
						     DOBJECT.LOCAL.WH-ISLAND -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -,
						  KEYS.KEY propt],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].


;,
;    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
;                                      ARG1 #index2,
;                                      ARG2 #index1 ] !>

free-objpred-pp-phrase := pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup & [DOBJECT synsem],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg ].

free-subjpred-som-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,    ;verb-all,   ;
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    C-CONT.RELS <! arg12-relation & [ PRED "by-virtue-of-rel",
                                      ARG1 #index1,
                                      ARG2 #index2 ] !> ].

free-objpred-som-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND - ].


free-objpred-oblique-som-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND - ].


adjective-mod-front-vp-phrase := head-final & rule &
  [ SYNSEM.LOCAL.CAT.VAL #val,
    SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].


free-subjpred-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MAIN-CL +,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
  ;  SYNSEM.NON-LOCAL #5, ;; MHS 190713 I need to think some about this type. This identification is probably inappropriate though.
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.GENRE regular,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].

; the requirement HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval, does not prevail across the inverted structure verb-subject, and then this applies also with intrans verbs. Therefore the rule is commented out - too many parses
free-objpred-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].

free-subjpred-som-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
   ; SYNSEM.NON-LOCAL #5, ;; MHS 190713 This type needs some thinking. 
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
  ;  NON-HEAD-DTR.SYNSEM.NON-LOCAL #5, ;; MHS 190713 This might be better served by restricting all of the NON-LOCAL dlists to be 0-dlist.
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    C-CONT.RELS <! arg12-relation & [ PRED "by-virtue-of-rel",
                                      ARG1 #index1,
                                      ARG2 #index2 ] !> ].

; the requirement HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval, does not prevail across the inverted structure verb-subject, and then this applies also with intrans verbs. Therefore the rule is commented out - too many parses
free-objpred-som-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    C-CONT.RELS <! arg12-relation & [ PRED "by-virtue-of-rel",
                                      ARG1 #index1,
                                      ARG2 #index2 ] !> ].


;;;;;;;;;;;;;;;

;SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
;,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1
    
first-verb-specification := basic-binary-headed-phrase &
  [ SYNSEM.LOCAL.ADV-MODIFIED +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CAT.HEAD verb-or-comp, ;verb-all,
    SYNSEM.LOCAL.CONT.HOOK.XARG #66,
;    SYNSEM.LOCAL.CONT.HOOK.DIRARG #67,
    SYNSEM.LOCAL.BND-RESP #resp,
;    SYNSEM.NON-LOCAL #7, ; ;extra; MHS 190713 This type needs some thinking. Since the leaf-subtypes of this type are all modificational phrases, it might be best to amalgate SLASH values.
;    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    SYNSEM.LOCAL.COMPS-BEGUN #comps,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp, ;verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #66,
;    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31 & -,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.DIRARG #67,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
;    HEAD-DTR.SYNSEM.NON-LOCAL #7, ;extra
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #comps,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #7, ;extra
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].

first-verb-modification := first-verb-specification &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2 ].

;;;;;;;;;;;;;;;
s-adv-mod := first-verb-modification & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv ].

adv-p-first-verb-mod :=  first-verb-modification & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.INVERT-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY canbefirstafterverb-index-sit1,
                                                      SELECTED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-EXTRACTION-APPLIED -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!> ].

adj-first-verb-mod :=  first-verb-modification & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.INVERT-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY propt,
					      SELECTED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].

adverbialclause-first-verb-mod :=  first-verb-modification & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.INVERT-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comp & [SELECTED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].


;;;;;;;;;;;;;;;;;;;

main-cl-first-verb-spec-phrase := first-verb-specification & basic-head-spec-phrase-sup &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    SYNSEM.VAL-CLASS #vc,
    SYNSEM.LOCAL.HAS-PUNCT -,
    SYNSEM.LOCAL.HAS-PERIOD -,
;    SYNSEM.LOCAL.CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #1,
    HEAD-DTR.SYNSEM.VAL-CLASS #vc,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       ICOMPS <>,
                                       SUBJ <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -].

main-cl-first-verb-mod := first-verb-modification & head-adj-phrase & 
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.WAIT-BND-RESP #1,
    FRONT-TO-FILL #12,
    HEAD-DTR.FRONT-TO-FILL #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       SPEC <>,
                                       SPR <>,
                                       ICOMPS <>,
                                       SUBJ <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -].

subord-cl-first-verb-mod := first-verb-modification & adj-head-phrase &
  [ SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.NON-LOCAL.SLASH #sl,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL -],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -, ;embedded quest are introduced by wh, not adverbs LH131021
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT - ,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #sl,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -  ].

maincl-stnd-first-verb-mod := main-cl-first-verb-mod &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC #9,
    SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SPEC <>,
                                       SUBJ <>]  ].

maincl-invert-first-verb-mod := main-cl-first-verb-mod &
  [ SYNSEM.NON-LOCAL.SLASH #sl,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +,
                                     IMPERATIVE - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #sl ].

;;;;;

qualifadv-phrase := basic-head-spec-phrase & head-final &
  [ SYNSEM.LOCAL.ADV-MODIFIED +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40, ; this excluded selv du smiler
    SYNSEM.LOCAL.COMPS-BEGUN #comps,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    EXTRACTED-FROM #10,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31 & -,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40 & +,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #comps,
    NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG1 #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].
    
qualifadv-quant-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    NON-HEAD-DTR qualifadv-quant-word ].
qualifadv-allquant-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant,
    NON-HEAD-DTR qualifadv-allquant-word ].
;very close to measure-quantword-a-phrase 
qualifadv-card-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    NON-HEAD-DTR cardspec-word ].
;qualifadv-phrase := qualifadv-phrase &
; [ NON-HEAD-DTR focqualifadv-word ].
qualifadv-n-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom, ;nominal-or-connect-n, to avoid adjunction to Art
    NON-HEAD-DTR focqualifadv-word ]. ; focqualifadv-n-word
qualifadv-padv-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR focqualifadv-word ]. ;focqualifadv-padv-word


#|
focqualifadv-phrase := qualifadv-phrase &
 [ NON-HEAD-DTR focqualifadv-word ].
focqualifadv-n-phrase := focqualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom, ;nominal-or-connect-n, to avoid adjunction to Art
    NON-HEAD-DTR focqualifadv-word ]. ; focqualifadv-n-word
focqualifadv-padv-phrase := focqualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR focqualifadv-word ]. ;focqualifadv-padv-word
|#
;;;;;;;;;;;;;;

s-adv-spec-v-phrase-sup := main-cl-first-verb-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL #main ],
    SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    SYNSEM.LOCAL.CONT.HOOK #sh & super-hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #sh & super-hook,
    HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ #proj,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -,
				     MAIN-CL #main & + ] ].	

; for position after first verb
s-adv-spec-v-phrase := s-adv-spec-v-phrase-sup &
  [  SYNSEM.LOCAL.ADJ-SITE-OPEN #open,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #open,
;    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN -, ; clitic pronouns are begun comps
    HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ + ].

; adverb before imperative, as in "ikke kom!"
s-adv-spec-v-imperative-phrase := s-adv-spec-v-phrase-sup &
  [  SYNSEM.LOCAL.ADJ-SITE-OPEN #open,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE +,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #open ].

; for position after imperative verb, as in "kom ofte!"
s-adv-spec-post-v-imperative-phrase := main-cl-first-verb-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -] ].


; for position after first verb, in subj-verb inverted structure
s-adv-spec-invert-v-phrase := main-cl-first-verb-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD noun, ;to avoid "sover gutten ikke", but gets complicated, with the two rrules below
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +] ].

; for position after first verb, in subj-verb inverted structure, after 'clitic' pronoun
s-adv-spec-invert-v-clit-subj-phrase := main-cl-first-verb-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +] ].

;"sover ikke han?"
s-adv-spec-invert-v-pron-nonclit-subj-phrase := main-cl-first-verb-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +] ].


; for position after VP
;s-adv-final-spec-v-phrase := s-adv-spec-v-phrase-sup &
s-adv-final-spec-v-phrase :=  main-cl-first-verb-spec-phrase & head-initial &
  [  SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     SYNSEM.LOCAL.CONNECT-PENDING #connpend,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
     HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connpend,
     NON-HEAD-DTR.CAN-OCCUR-FINAL + ].

s-adv-final-spec-invert-v-phrase :=  main-cl-first-verb-spec-phrase & head-initial &
  [  SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +],
     NON-HEAD-DTR s-operadv-final-word,
     NON-HEAD-DTR.CAN-OCCUR-FINAL + ].

; for clause-initial position ...
s-adv-front-spec-v-phrase-sup := main-cl-first-verb-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    FRONT-TO-FILL -,
    HEAD-DTR.FRONT-TO-FILL +,
    NON-HEAD-DTR.CAN-OCCUR-INITIAL +  ].

; ... initial with inversion (normal)
s-adv-front-spec-v-phrase := s-adv-front-spec-v-phrase-sup &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     SYNSEM.LOCAL.CAT.QVAL #qval,
     HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +] ].

; ... initial without inversion (only with "kanskje")
s-adv-front-noninver-kanskje-spec-v-phrase := s-adv-front-spec-v-phrase-sup &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY kanskje-k ].
s-adv-front-noninver-s√•-spec-v-phrase := s-adv-front-spec-v-phrase-sup &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY s√•-k ].
s-adv-front-noninver-mon-spec-v-phrase := s-adv-front-spec-v-phrase-sup &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mon-k ].


s-adv-fragmfinal-spec-phrase-sup :=  head-initial &
  [ SYNSEM.LOCAL.ADV-MODIFIED +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.NON-LOCAL #7, 
    SYNSEM.LOCAL.COMPS-BEGUN #comps,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #1,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CONT.HOOK #hook,
;    EXTRACTED-FROM #10,
;    HEAD-DTR.EXTRACTED-FROM #10,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #66,
;    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31 & -,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.NON-LOCAL #7,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #comps,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    ;    FRONT-TO-FILL #12,
;    HEAD-DTR.FRONT-TO-FILL #12,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       ICOMPS <>,
                                       SUBJ <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
	SYNSEM.LOCAL.HAS-PUNCT -,
	SYNSEM.LOCAL.HAS-PERIOD -,
        NON-HEAD-DTR.SYNSEM.NON-LOCAL #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.CAN-OCCUR-FINAL +,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].

s-adv-fragmfinal-spec-phrase := s-adv-fragmfinal-spec-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adj-or-adv ].
s-adv-fragmfinal-n-spec-phrase := s-adv-fragmfinal-spec-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal ].

s-adv-final-spec-v-subord-phrase :=  first-verb-specification & basic-head-spec-tweak-phrase & head-initial &
  [  SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
     HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL -],
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
     NON-HEAD-DTR.CAN-OCCUR-FINAL +,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CONT.HOOK.LTOP #5] >,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.RELS <! [LBL semarg,
					     ARG1 #5] !>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv  ].


;;  ALTERED for malgram

; semarg <- #lbl
; the only daughter of first-verb-specification which leaves HEAD as verb-or-comp, to accommodate "... √• ikke V".
s-adv-spec-v-subord-phrase := first-verb-specification & basic-head-spec-tweak-phrase & head-final &
  [ SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    SYNSEM.LOCAL.HAS-PUNCT #hpu,
    SYNSEM.LOCAL.ADJ-SITE-OPEN #open,; a feature induced by aux-bare-inf, which has a common form in main and subord clause
     SYNSEM.LOCAL.HIGHEST-V-PROJ +,
    SYNSEM.LOCAL.HAS-PERIOD #hp,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #5,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL -],
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #open,
     HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT #hpu,
    HEAD-DTR.SYNSEM.LOCAL.HIGHEST-V-PROJ +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD #hp,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #hook,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [SYNSEM.LOCAL.HIGHEST-V-PROJ +,
					      LOCAL.CONT.HOOK.LTOP #5] >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.RELS <! [LBL semarg,
					    ARG1 #5] !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv  ].

s-adv-mod-v-phrase := s-adv-mod & maincl-stnd-first-verb-mod &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN + ].
s-adv-mod-invert-v-phrase := s-adv-mod & maincl-invert-first-verb-mod &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN + ].

s-adv-mod-v-subord-phrase := s-adv-mod & subord-cl-first-verb-mod.

; HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT +
adverbial-stnd-first-verb-mod-phrase := adv-p-first-verb-mod & maincl-stnd-first-verb-mod & index-sit-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [],... > ].

adjectival-stnd-first-verb-mod-phrase := adj-first-verb-mod & maincl-stnd-first-verb-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [],... > ].

adverbialclause-stnd-first-verb-mod-phrase := adverbialclause-first-verb-mod & maincl-stnd-first-verb-mod & index-sit-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [],... > ].

;  & index-sit-mod
adverbial-invert-first-verb-mod-phrase := adv-p-first-verb-mod & maincl-invert-first-verb-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,				; has-punct and -period required for NorMal, but
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -  ].			; probably useful also for NorSource. EAA.

adverbial-subordcl-first-verb-mod-phrase := adv-p-first-verb-mod & index-sit-mod & head-mod-phrase-simple-extra & subord-cl-first-verb-mod. 
;;;;;;;;;;;;;;;;;;;;;;


telic-pp-mod-vp-phrase := pp-mod-vp-phrase & telic-mod-vp-phrase & fixpt-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE spatial-temporal-class].

telic-pp-mod-vp-comma-phrase := pp-mod-vp-phrase & telic-mod-vp-phrase & 
  [ NON-HEAD-DTR connector-mod-phrase & [SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ]].

telic-pp-mod-vp-2-phrase := pp-mod-vp-2-phrase & telic-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ].

;telic-pp-mod-vp-phrase2 := pp-mod-vp-phrase2 & telic-mod-vp-phrase.

telic-adv-mod-vp-phrase := adv-mod-vp-phrase & telic-mod-vp-phrase & fixpt-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].
telic-adv-mod-vp-comma-phrase := adv-mod-vp-phrase & telic-mod-vp-phrase & 
  [ NON-HEAD-DTR comma-leftmod-phrase ].

;telic-adv-mod-vp-phrase2 := adv-mod-vp-phrase2 & telic-mod-vp-phrase.

atelic-pp-mod-vp-phrase := pp-mod-vp-phrase & atelic-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ].


atelic-pp-mod-vp-nonfixptdir-phrase := atelic-pp-mod-vp-phrase & nonfixpt-dir-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].

atelic-pp-mod-vp-comma-phrase := atelic-pp-mod-vp-phrase & 
  [ NON-HEAD-DTR comma-leftmod-phrase & [SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ]]. ;comma-leftmod-phrase &

atelic-pp-mod-vp-index-sit-phrase := atelic-pp-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit, ;index-sit1, to get 'snakke ang√•ende hva som skjer'
    NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ] ].

atelic-pp-mod-vp-2-phrase := pp-mod-vp-2-phrase & atelic-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ].

;atelic-pp-mod-vp-phrase2 := pp-mod-vp-phrase2 & atelic-mod-vp-phrase.

atelic-adv-mod-vp-phrase := adv-mod-vp-phrase & atelic-mod-vp-phrase.
atelic-adv-mod-vp-nonfixptdir-phrase := atelic-adv-mod-vp-phrase & nonfixpt-dir-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].
atelic-adv-mod-vp-comma-phrase := atelic-adv-mod-vp-phrase & nonfixpt-dir-mod & 
  [ NON-HEAD-DTR connector-mod-phrase ].
atelic-adv-mod-vp-index-sit-phrase := atelic-adv-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].


atelic-front-adv-mod-vp-phrase := adv-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-front-adv-mod-vp-nonfixptdir-phrase := atelic-front-adv-mod-vp-phrase & nonfixpt-dir-mod.
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-front-adv-mod-vp-index-sit-phrase := atelic-front-adv-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-front-adv-mod-vp-phrase := adv-mod-front-vp-phrase & telic-front-mod-vp-phrase.

; for "kanskje kongen kommer" (?/.)
front-adv-mod-vp-noninvert-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY kanskje-k,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV -],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]> ].

atelic-interr-front-adv-mod-vp-phrase := adv-interr-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-interr-front-adv-mod-vp-nonfixptdir-phrase := atelic-interr-front-adv-mod-vp-phrase & nonfixpt-dir-mod.
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-interr-front-adv-mod-vp-index-sit-phrase := atelic-interr-front-adv-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-interr-front-adv-mod-vp-phrase := adv-interr-mod-front-vp-phrase & telic-front-mod-vp-phrase.

;atelic-adv-mod-vp-phrase2 := adv-mod-vp-phrase2 & atelic-mod-vp-phrase.

nonaspect-pp-mod-vp-phrase := pp-mod-vp-phrase & non-aspect-mod-vp-phrase.

nonaspect-adv-mod-vp-phrase := adv-mod-vp-phrase & non-aspect-mod-vp-phrase.

;TODO: to get "hvor flink er han?", both extraction and topic-filler have to apply to adjective phrases.
extracted-comp-phrase := basic-extracted-comp-phrase &
  [ SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.VAL [ICOMPS #1,
			  COMPS #comps],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CAT.HEAD #head,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    SYNSEM.LOCAL.WH-EXTRACTION-APPLIED +,
    SYNSEM.VAL-CLASS #valclass,
    HEAD-DTR.SYNSEM.VAL-CLASS #valclass,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list,
                                   ICOMPS #1,
				   COMPS < gap &
                                           [ NON-LOCAL.SLASH #slash ]
                                           . #comps > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    EXTRACTED-FROM +  ].

#|
extracted-subj-phrase := basic-extracted-subj-phrase &
  [ EXTRACTED-FROM +,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.VAL [SUBJ list,
			   ICOMPS #1,
			   COMPS #comps],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    SYNSEM.VAL-CLASS #valclass,
    HEAD-DTR.SYNSEM.VAL-CLASS #valclass,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ < gap &
                                           [ NON-LOCAL.SLASH #slash ]
                                           >,
                                   ICOMPS #1,
				   COMPS #comps ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash  ].
|#

; LH160412  - reduce from 8 to 2 parses for "sang mann synger smiler"
extracted-icomp-phrase := basic-extracted-icomp-phrase &
  [ SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.HEAD #head,
    SYNSEM.LOCAL.CAT.VAL [COMPS #1],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.WH-EXTRACTION-APPLIED +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list,
                                   ICOMPS < [LOCAL.CAT.HEAD prep-or-adv],... >,
                                   COMPS #1],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    EXTRACTED-FROM + ].

extracted-verbcomp-phrase-sup := extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +] ].


;;; 16.12.10 MHS Added COMPS-BEGUN - in an attempt to reduce spurious ambiguity. Might be a problem, though I don't know specifically how or why. 
; LH290613  It was - one could extract only the first object in a ditransitive clause
; COMPS-BEGUN -
;INV +
mcl-extracted-verbcomp-phrase := extracted-verbcomp-phrase-sup &
 [ SYNSEM.LOCAL.COMPS-BEGUN #cbeg,
   HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #cbeg,
   HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ MAIN-CL +, ;+
					INV bool ]]]].


;				 VAL.SUBJ < anti-synsem >]]]. ; LH290613 activated again, to avoid multiple parses in 'gamle mennesker i denne gruppa har ikke noe problem'. LH100713 deactivated - lost 'hva har ola fort√¶rt'
;				 QVAL.SUBJECT.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE -],  ; this cannot be activated, then one gets a clash between lex-synsem and phr-synsem for QVAL.SUBJECT, very strange.
;			   COMPS-BEGUN bool]].



mcl-non-comp-extracted-verbcomp-phrase := mcl-extracted-verbcomp-phrase &
[ SYNSEM.LOCAL.IS-A-COMPLEMENT #bool,  
  HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED -,
  HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED -,
  HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ INV bool ],;+
				VAL [ SUBJ < anti-synsem > ]],
			  IS-A-COMPLEMENT #bool & - ]].

mcl-comp-extracted-verbcomp-phrase := mcl-extracted-verbcomp-phrase &
[ SYNSEM.LOCAL.IS-A-COMPLEMENT #bool,  
  HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ INV bool ],;-
				VAL [ SUBJ < synsem > ]],
			  IS-A-COMPLEMENT #bool & + ]].



non-mcl-extracted-verbcomp-phrase := extracted-verbcomp-phrase-sup &
[ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MAIN-CL - ]]].

extracted-verbicomp-phrase-sup := extracted-icomp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +] ].


;;; 16.12.10 MHS Added COMPS-BEGUN - in an attempt to reduce spurious ambiguity. Might be a problem, though I don't know specifically how or why.
; LH011012 works fine, it seems 

mcl-extracted-verbicomp-phrase := extracted-verbicomp-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ MAIN-CL +,
					INV + ],
				 VAL.SUBJ < anti-synsem >,
				 QVAL.SUBJECT.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE -],
			   COMPS-BEGUN -]].

non-mcl-extracted-verbicomp-phrase := extracted-verbicomp-phrase-sup &
[ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MAIN-CL - ]]].





extracted-prepcomp-phrase := extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head ]> ].
extracted-verbcomp-phrase := extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].

; COMPS < [LOCAL.CAT.HEAD fin-comp ] >
extracted-event-comp-phrase := basic-extracted-comp-phrase &
  [ SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.VAL [ICOMPS #1],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.WH-EXTRACTION-APPLIED +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list,
                                   COMPS < [LOCAL.CONT.HOOK.INDEX event-verb ] >,
                                   ICOMPS #1],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LEX +,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    FRONT-TO-FILL +,
    EXTRACTED-FROM + ].

extracted-event-prepcomp-phrase := extracted-event-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp ] > ].
extracted-event-verbcomp-phrase := extracted-event-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].



;,
;    HEAD-DTR.EXTRACTED-FROM -
extracted-prep-comp-phrase := basic-extracted-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD prep-ultra & [ MOD < [ LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.DERIVED-HEAD #bool] >],
    SYNSEM.LOCAL.WH-EXTRACTION-APPLIED +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [ MOD < [ LOCAL.CAT.VAL.COMPS <>,
						    LOCAL.DERIVED-HEAD #bool] >],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS < [LOCAL.CAT.HEAD np-head ] >],
    EXTRACTED-FROM +,
    FRONT-TO-FILL + ].


extracted-subj-phrase := basic-extracted-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list ],
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    HEAD-DTR.EXTRACTED-FROM -,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].


;; ALTERED for MAL rules

#|
head-filler-topic-phrase-sup := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR.FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].




head-filler-topic-phrase := head-filler-topic-phrase-sup &
[ SYNSEM.LOCAL.CAT.HEAD.INV + ].

var-non_inv-head-filler-topic-phrase := head-filler-topic-phrase-sup &
[ SYNSEM.LOCAL.CAT.HEAD.INV - ].
|#

;; 14.12.10 MHS
;; Changed RIGHT-ADJ-SITE-OPEN + to -.

head-filler-topic-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
				      MAIN-CL +, ;; MHS 090813 Adding this block fronting in subordinate clauses, which, as far I know, doesn't occur in Norwegian. See sentences such as 'vi muliggjorde det at han fikk innreisetillatelse'.
                                      DECL bool], ; from +
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR.FRONT-TO-FILL +, ; LH290613: activated, to prevent both pp-fronting and topic-filling to happen in the same sentence.
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED -,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED -,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.EXPLETIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING.LEX-TAME -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #ind, LTOP #lbl ], ;; MHS 180511 Add re-entrancy of LTOP and LBL to fix leaf/hole mismatch.
    FRONT-TO-FILL -,
    C-CONT [ RELS <!fpos_prom_rel & [ ARG1 #ind, LBL #lbl ] !>,
	     HCONS <! !> ] ].

head-filler-n-topic-phrase := head-filler-topic-phrase &
  [ SYNSEM.LOCAL.BINDING.BOUND #bd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],
    NON-HEAD-DTR.SYNSEM.LOCAL  [DERIVED-HEAD -,
			       DERIVED-BARE-N-FROM-ADJ -,
			       SPEC-TO-BARE-N -,
			       CARD-TO-BARE-N -,
			       POSSPRON-TO-BARE-N -,
				BINDING.BOUND #bd],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH -]].
head-filler-adj-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
head-filler-adv-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
head-filler-p-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
head-filler-event-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event-verb ].

; TODO: should really omit ref-ind in NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH +], to get "hvor bor han?", "hvor er han?" etc, without a fake ref-ind-hvor
head-filler-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL -,
				      MAIN-CL +,
				      WH-COMPLETE +,
				      WH-MOVED +], ; since there are two others dealing with subord clauses
    SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; to ensure the wh c-commands everything
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.EXTRACTED-FROM +,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +, ; LH wonder why this was
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED -,
    NON-HEAD-DTR.SYNSEM.LOCAL  [DERIVED-HEAD -,
			       DERIVED-BARE-N-FROM-ADJ -,
			       SPEC-TO-BARE-N -,
			       CARD-TO-BARE-N -,
			       POSSPRON-TO-BARE-N - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ]  ].


#|
head-filler-topic-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR.FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].
|#



; this rule induces a question taking scope over the proposition created 
; by the head-subject rule of the embedded clause. Better than
; depriving the latter of its usual force, it seems.

; ,
;				      WH-COMPLETE +
head-filler-subord-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      DECL -,
                                      MAIN-CL -],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                               DECL -,
                                               MAIN-CL - ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR head-subject-phrase-super, ; LH240214 added -super, having made head-subject-phrase go only with 'SF prop-or-comm'
; deleting ref-ind as value of INDEX below, to get '...hvor snill han er':
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH + ],
; nominal rather than np-head, to avoid that connect-n is used as head - but (LH041015) to get 'hvor snill han er', comment the line away fully
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]   ].


;;; MHS 2002 020411 Removed SYNSEM.LOCAL.CAT.VAL.SUBJ <>, from head-subjfiller-subord-wh-phrase

head-subjfiller-subord-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      DECL -,
                                      MAIN-CL -,
				      WH-MOVED -,
				      WH-COMPLETE +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E #6,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
;    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    SYNSEM.NON-LOCAL #nonloc,
    SYNSEM.LOCAL.CAN-RELATIVE-ADJOIN -,
;    HEAD-DTR head-resumptsubject-interr-phrase,
    SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
    HEAD-DTR.SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
    HEAD-DTR.SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #15,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.EXTRACTED-FROM -,
;    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal & [ACCUSATIVE - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-SOM +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #15,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.MODIFICATION-PERFORMED +, ; maybe HEAD constraint also
    C-CONT [ RELS <! !>,
             HCONS <! !> ]   ].



#|
nom-of-head-subjfiller-subord-wh-phrase := unary-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD poss-subj-head,
    SYNSEM.LOCAL.CAT.VAL #val,
    SYNSEM.LOCAL.CONT #cont,
    ARGS < head-subjfiller-subord-wh-phrase &
           [ SYNSEM.LOCAL.CAT.VAL #val,
             SYNSEM.LOCAL.CONT #cont ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].
|#

#| a non-message version of the indirect quest filler rule. abandoned.
head-filler-subord-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      DECL -,
                                      MAIN-CL - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>   ].
|#


;;; DPF

; LH 'DECL +' to avoid indirquests as non-head-dtr
relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xrg,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xrg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +,
						   INV -,
						   DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>].


relative-wh-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1, ; "hvis" in "hvis hund du liker"
    NON-HEAD-DTR rel-wh-head-filler-phrase,    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[ LOCAL.CAT.HEAD nom,
                                              LOCAL.CONT.HOOK.INDEX #1 ]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +,
						   INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>].


comma-rightmod-relcomp-som-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-rightmod-relcomp-som-phrase ,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>].

#|
bare-relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [SORT referential-thing],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.BOUND -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR unary-rel-head-filler-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    C-CONT.HCONS <! !>]. 
|#

bare-relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom & [RELATIVPRON -],
    HEAD-DTR.SYNSEM.LOCAL.BINDING.BOUND -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <!!>,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -, ; 'en' first in a clause gets interpreted as relative head
;    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR unary-rel-head-filler-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD poss-subj-head,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    C-CONT.HCONS <! !>]. 

comma-rightmod-relsubj-√∏-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-rightmod-relsubj-√∏-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 




relative-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -], ; to avoid 'hvem som ...' as rel constr
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR head-relative-subject-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -,
						   INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-RELATIVE-ADJOIN +,
    C-CONT.HCONS <! !>]. 

coord-relative-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -], ; to avoid 'hvem som ...' as rel constr
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR s-rel-connect-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -,
						   INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-RELATIVE-ADJOIN +,
    C-CONT.HCONS <! !>]. 

; [[gutten] [hvis katt sover]] ...:
relative-wh-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -], 
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1, ; "hvis" in "hvis hund sover"
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR head-wh-relative-subject-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -,
						   INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-RELATIVE-ADJOIN +,
    C-CONT.HCONS <! !>]. 



relative-truncated-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD comm-noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR atelic-pp-mod-vp-index-sit-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    ;NON-HEAD-DTR.SYNSEM.LOCAL.CAT trans-qval-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -,
						   VOICE ptc-pass],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash & <!!>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN +,; corect, but loses en mann fort√¶rt av Ola
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>]. 



comma-rightmod-relsubj-som-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-rightmod-relsubj-som-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 

comma-rightmod-nonrestr-relsubj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-leftmod-nonrestr-relsubj-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 

comma-rightmod-nonrestr-relcomp-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-leftmod-nonrestr-relcomp-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 



relative-comma-relsubj-som-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM #1,
    HEAD-DTR.SYNSEM #1,
    NON-HEAD-DTR comma-rightmod-relsubj-som-phrase ].



; 'MUST-APP' only to avoid coordination bare
rel-comp := word & const-ltow-rule &
  [SYNSEM [LOCAL.CAT.HEAD [ RELATIVPRON + ],
           LOCAL.CAT.VAL.SUBJ <>,
           LOCAL.CAT.VAL.SPR <>,
           LOCAL.CAT.VAL.SPEC <>,
           LOCAL.CAT.VAL.COMPS <>,
           LOCAL.MUST-APP +,
;           LOCAL.CONT.HOOK.LTOP #1,
;           LOCAL.CONT.HOOK.INDEX #2,
           LOCAL.CONT.HOOK.INDEX.WH -,
           LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_relpartcl_rel"
;						    ARG0 #2, ; LBL #1
						     ] !>,
           LOCAL.CONT.HCONS <! !>]].

som_filler-relpron := rel-comp & 
  [ SYNSEM.LOCAL.CAT.HEAD rel-filler,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [SORT referential-thing]]. ; to keep out of time-mod-phrase, for instance - can also be done via KEY, perhaps

hvilket_filler-relpron := rel-comp & 
  [ SYNSEM.LOCAL.CAT.HEAD comp,
    SYNSEM.LOCAL.CONT.HOOK.INDEX event-verb ].

#|
extracted-subj-phrase := basic-extracted-subj-phrase & head-compositional &
  [C-CONT [ RELS <! !>,
	   HCONS <! !> ]].

extracted-comp-phrase := basic-extracted-comp-phrase &
  [C-CONT [ RELS <! !>,
	   HCONS <! !> ]].
|#
; the rule that combines "som" with S:


; without message  - also 'head-final'?
; gutten hvis katt jeg holder ...
rel-wh-head-filler-phrase := basic-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX semarg, ;#1,
					       LOCAL.CONT.HOOK.LTOP #2,
					       LOCAL.CAT.HEAD np-head ] >,
				       WH-COMPLETE +,
				       WH-MOVED +,
				       MAIN-CL #main],
     SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
     SYNSEM.LOCAL.CAT.VAL.SPEC < >,
     SYNSEM.LOCAL.CONT.HOOK.XARG #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.CAN-CMB-V -,
     SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
     SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
     SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
     ARGS <  poss-genitive-posspron-phrase & 
	     [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
;	      SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
	      SYNSEM.LOCAL.CONT.HOOK.XARG #4], ; "hvis" in "hvis hund du liker"],
	     head-subject-phrase &
	     [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
              SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                                 IMPERATIVE -,
						 MAIN-CL #main & -],
              SYNSEM.LOCAL.CAT.VAL.COMPS < >,
              SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
              SYNSEM.LOCAL.CAT.VAL.SPR < >,
              SYNSEM.LOCAL.CAT.VAL.SPEC < >,
              SYNSEM.LOCAL.CAT.HEAD.MOD < >,
              SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
	      SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
	      SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
	      EXTRACTED-FROM +] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].


rel-head-filler-phrase := basic-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX #1,
					       LOCAL.CONT.HOOK.LTOP #2,
					       LOCAL.CAT.HEAD np-head ] >,
				       WH-COMPLETE +,
				       WH-MOVED +,
				       MAIN-CL #main],
     SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
     SYNSEM.LOCAL.CAT.VAL.SPEC < >,
     SYNSEM.LOCAL.CONT.HOOK.XARG #1, ; LH120219
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.CAN-CMB-V -,
     SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
     SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
     SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
     ARGS <  rel-comp & 
	     [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ],
	     head-subject-phrase &
	     [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
              SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                                 IMPERATIVE -,
						 MAIN-CL #main & -],
              SYNSEM.LOCAL.CAT.VAL.COMPS < >,
              SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
              SYNSEM.LOCAL.CAT.VAL.SPR < >,
              SYNSEM.LOCAL.CAT.VAL.SPEC < >,
              SYNSEM.LOCAL.CAT.HEAD.MOD < >,
              SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
	      SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
	      SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
	      EXTRACTED-FROM +] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

unary-rel-head-filler-phrase := basic-unary-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX #1,
                                               LOCAL.CONT.HOOK.LTOP #2,
                                               LOCAL.CAT.HEAD nom & [EXPLETIVE #head & -,
								     KEYS.KEY #kk] ] >,
				       WH-COMPLETE +,
				       WH-MOVED -],
     SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
     SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.VARG #1,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.IS-A-COMPLEMENT -,
     SYNSEM.LOCAL.REL-CL-SOM-INIT +,
     SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
     SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
     SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
;    SYNSEM.LOCAL.REL-CL-SOM-INIT #5,
     ARGS <  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
               SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ MOOD indicative],
               SYNSEM.LOCAL.CAT.HEAD [ INV -,
                                       IMPERATIVE - ],
               SYNSEM.LOCAL.CAT.VAL.COMPS < >,
               SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
               SYNSEM.LOCAL.CAT.VAL.SUBJ list,
               SYNSEM.LOCAL.CAT.VAL.SPR < >,
               SYNSEM.LOCAL.CAT.VAL.SPEC < >,
               SYNSEM.LOCAL.CAT.HEAD.MOD < >,
               SYNSEM.LOCAL.CONNECT-PENDING #connectpend,
	       SYNSEM.LOCAL.DIRECTIONAL-SHIFT-APPLIED #dir,
	       SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED #par,
	       SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CONT.HOOK.INDEX #1,
               SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CAT.HEAD nom & [EXPLETIVE #head,
								 KEYS.KEY #kk],
               EXTRACTED-FROM +,
;               SYNSEM.LOCAL.REL-CL-SOM-INIT #5,
               SYNSEM.LOCAL.REL-CL-SOM-INIT bool ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

;;;;;;;;;;;

unary-fin-rel-head-filler-phrase := unary-rel-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CAT.HEAD nom ] >,
				       MAIN-CL #main & - ],
     SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #fin & finite ],
     ARGS <  head-subject-phrase & 
             [ SYNSEM.LOCAL.CAT.HEAD verb-all & [MAIN-CL #main ],
	       SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #fin ],
	       SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON #2]> ].

unary-infin-rel-head-filler-phrase := unary-rel-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD [MOD < [ LOCAL.CAT.HEAD.DEF bool ] >], ; '-' blocks "den beste m√•ten √• gj√∏re det p√•"
     SYNSEM.LOCAL.HAS-WH-MOVED +,
     SYNSEM.LOCAL.UNARY-INFIN-REL +,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #infin & infin ],
     ARGS <  head-complementizer-comp-absinf-phrase & 
             [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #infin ],
               SYNSEM.LOCAL.CAT.HEAD glob-comp & [TRANSPAR -] ] >].

;without message
;; "hvilket || jeg vet"
rel-vp-head-filler-phrase := basic-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX #1,
					       LOCAL.CONT.HOOK.LTOP #2,
					       LOCAL.CAT.HEAD verb-all ] >,
				       WH-COMPLETE +,
				       WH-MOVED +],
     SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
     SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.CAN-CMB-V -,
     ARGS <  rel-comp & [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
			 SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ],
            head-subject-phrase &
	     [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
              SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                                 IMPERATIVE - ],
              SYNSEM.LOCAL.CAT.VAL.COMPS <>,
              SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
              SYNSEM.LOCAL.CAT.VAL.SPR <>,
              SYNSEM.LOCAL.CAT.VAL.SPEC <>,
              SYNSEM.LOCAL.CAT.HEAD.MOD <>,
              EXTRACTED-FROM +] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

;;;;;;;;;

; "han kommer || hvilket skremmer meg"
; the requirement NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELPRON + had to be dropped, to let through the event-subject - - otherwise the 'rel-pron' which goes with normal rel clause has this requirement, cf. relative-subj-mod-phrase 
; this rule should rather be a kind of apposition
vp-relative-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR head-relative-subject-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD comp,
    ;NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY hvilket-fillerrelprn,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>]. 

; "han kommer || hvilket jeg har sett"
vp-relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[ LOCAL.CAT.HEAD verb-all,
                                              LOCAL.CONT.HOOK.INDEX #1 ]>,
    NON-HEAD-DTR rel-vp-head-filler-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-MOVED +,
						    INV - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>].

; 'dagen du kom' - reflecting 'dagen da du kom', pumping clause to head prep-or-verb and the mrs to contain an EP corresponding to 'da'. Required because adverbial clause initiators are not gap-fillers.

unary-rel-dagen-du-kom-phrase := basic-unary-phrase &
  [  SYNSEM [LOCAL [CAT [HEAD #3 & adjct-comp ],
		    XCAT [HEAD #3 ]]],
     EXTRACTED-FROM -,
     SYNSEM.LEX -,
     SYNSEM.BIND unbnd,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event,
     SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY der-n√•r,
     SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
     SYNSEM.LOCAL.CAT.HEAD [MOD < [ LOCAL.CAT.HEAD nom & [EXPLETIVE -,
							  KEYS.KEY meastimenoun],
				    LOCAL.CONT.HOOK.INDEX #a1 ] >,
			    WH-COMPLETE +,
			    WH-MOVED -],
     ARGS < [ SYNSEM   [ LOCAL.CAT.VAL.SPEC <>,
			 LOCAL.CAT.VAL.SUBJ <>,
			 LOCAL.CONT.HOOK.INDEX #a2,
			 LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
			 LOCAL.IS-A-COMPLEMENT -,
			 LOCAL.RIGHT-ADJ-SITE-OPEN -,
			 LOCAL.CONT.HOOK.INDEX.E [ MOOD indicative],
			 LOCAL.CAT.HEAD verb-all & [ INV -,
						     IMPERATIVE -,
						     WH-COMPLETE -,
						     MAIN-CL -],
			 LOCAL.CAT.VAL.COMPS < >,
			 LOCAL.CAT.VAL.ICOMPS < >,
			 LOCAL.CAT.VAL.SPR < >,
			 LOCAL.CAT.VAL.SPEC < >,
			 LOCAL.CAT.HEAD.MOD < >,
			 NON-LOCAL.SLASH 0-dlist,; to prevent the rule from applying to real rel-clauses
			 LOCAL.HAS-PERIOD - ], 
               EXTRACTED-FROM - ] >,
    C-CONT [ RELS <! arg12-relation & [PRED "_same_time_c_rel",
				       ARG1 #a1,
				       ARG2 #a2] !>,
             HCONS <! !> ]].




;; Coordination
;; EAA070212: Have changed coordination to remove unwanted EP, and fixed left handle. Watch out for consequences!

coordinating-phrase := binary-phrase &
 [ SYNSEM.LOCAL.COORD-POL #1,
   SYNSEM.LOCAL.CAN-COORD-COMP -,
    ARGS < [SYNSEM.LOCAL.CORRCOORD-CLOSED -], [ SYNSEM.LOCAL.COORD-POL #1 ] >].

; for coord of nps...
; EAA020811: Removed sort-constraint. Seemed to block normal coordinations.
; EAA170811: Added unified constraints for ACCUSATIVE, to avoid "han og henne spiser."
; EAA070212: Added two constraints to connect left handle
coordination-numsensitive-phrase := coordinating-phrase & non-headed-phrase & rule &
  [  SYNSEM.LOCAL.CAT.HEAD #32 & np-head & [COORDINABLE + ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX #1, ; & [SORT #7],
     SYNSEM.LOCAL.CAT.VAL #4,
     SYNSEM.LOCAL.BINDING #12,
     SYNSEM.NON-LOCAL #5,
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.LOCAL.BND-RESP #3,
     RULE #6,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD #32 & [ACCUSATIVE #acc],
              SYNSEM.LOCAL.CAT.VAL #4,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #2, ;& [SORT #7],
			  SYNSEM.LOCAL.CONT.HOOK.LTOP #lhandle,
              SYNSEM.LOCAL.MUST-APP -,
              SYNSEM.NON-LOCAL #5,
              SYNSEM.LOCAL.DERIVED-HEAD #11,
              SYNSEM.LOCAL.BINDING #12,
              SYNSEM.LOCAL.BND-RESP #3,
              RULE #6], 
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
             SYNSEM.LOCAL.CAT.HEAD coord,
			 SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #lhandle ] >,
             SYNSEM.LOCAL.XCAT.HEAD nominal & [COORDINABLE +, ACCUSATIVE #acc],
;             SYNSEM.LOCAL.XSORT #7,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.DERIVED-HEAD #11,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HAS-PUNCT bool,
             SYNSEM.LOCAL.BND-RESP #3,
             SYNSEM.NON-LOCAL #5 ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

; is intended to help through "Ola, Kari, og Per kommer" (second comma)
; but that didn't work anyway. So back to basic: allow "Per, Kari.."
; and disallow "Per, fra skogen..."
; removed ,
;             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE bool
coordination-np-comma-np-phrase := coordinating-phrase & non-headed-phrase & rule &
  [  SYNSEM.LOCAL.CAT [ HEAD #32 & [COORDINABLE + ] ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [SORT #7],
     SYNSEM.LOCAL.BND-RESP #3,
     SYNSEM.LOCAL.CAT.VAL #4,
     SYNSEM.LOCAL.BINDING #12,
     SYNSEM.NON-LOCAL #5,
     RULE #6,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD #32,
              SYNSEM.LOCAL.CAT.VAL #4,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7],
              SYNSEM.LOCAL.MUST-APP -,
              SYNSEM.NON-LOCAL #5,
              SYNSEM.LOCAL.DERIVED-HEAD #11,
              SYNSEM.LOCAL.BINDING #12,
              SYNSEM.LOCAL.BND-RESP #3,
              RULE #6], 
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
             SYNSEM.LOCAL.CAT.HEAD comma-coord,
             SYNSEM.LOCAL.XCAT.HEAD np-head,
             SYNSEM.LOCAL.XSORT #7,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.DERIVED-HEAD #11,
             SYNSEM.LOCAL.BND-RESP #3,
             SYNSEM.NON-LOCAL #5 ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

; for coord of pps, advps,...
coordination-adjct-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY #3 & prim-mod,
                                          MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
              SYNSEM.LOCAL.HAS-PUNCT -,
              SYNSEM.NON-LOCAL #5 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.XCAT.HEAD prep-or-adv & [KEYS.KEY #3,
                                                   MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5  ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

#|
; for coord of selected prep's,...
coordination-adjct-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD prep & [KEYS.KEY #3 & prim-mod,
                                   MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
              SYNSEM.LOCAL.HAS-PUNCT -,
              SYNSEM.NON-LOCAL #5 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.XCAT.HEAD prep & [KEYS.KEY #3,
                                            MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5  ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].
|#
; for coord of vps...
#|
coordination-v-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY #3,
                                       MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all & [KEYS.KEY #3,
                                                MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].
|#

; TODO: applies also to "Ola l√∏per og l√∏per" allowing distinct subjects - should be avoided. Has to do with 'antilist' vs 'null' as SUBJ-value...
; EAA: Added constraint that the HEAD|INV be identical for both daughters
; LH020711: "jeg har bil, og ig√•r fikk jeg hus". So that requirement shouldn't be, unless we want extra rules. Thus taken away:  & [INV #inv]
;SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj & antilist,
; outcommented in ARGS 1: SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & 1-list,
;so as to manage "Seinere brant den mange ganger, men de bygde den opp igjen." (NoW)
; TODO LOOKOUT: there was an outcomment for non-head-dtr '             SYNSEM.LOCAL.XCAT.HEAD verb-all,', meaning that the second clause would not be required to be verbal. Strange.
; Reason found: in 'Da l√¶rte han meg norsk, og jeg l√¶rte ham tysk.', the comma is head, and XCAT.HEAD is 'og'. So, outcommented the line goes, again.


coordination-finite-clause := basic-head-mod-phrase-simple & head-initial & phrasal & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,		; Re-added EAA010811
     SYNSEM.LOCAL.CAT.VAL.COMPS #6,
     SYNSEM.LOCAL.CAT.VAL.ICOMPS #7,
     SYNSEM.NON-LOCAL #5,
	 FRONT-TO-FILL -,			  ; Added in, EAA010811
     ARGS < [ SYNSEM.LOCAL.XCAT.HEAD verb-all,
	      SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE #compl,
	      SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
;              SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & 1-list,
	      SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & < anti-synsem >,  ; Added in, EAA010811
	      SYNSEM.LOCAL.CAT.VAL.COMPS #6,
              SYNSEM.LOCAL.CAT.VAL.ICOMPS #7,
	      FRONT-TO-FILL -,  	; Added in, EAA010811
              SYNSEM.NON-LOCAL #5 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
	     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
;             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE +,
             SYNSEM.LOCAL.XCAT.HEAD.WH-COMPLETE #compl,
			 SYNSEM.LOCAL.XCAT.VAL [ SUBJ antilist ], ; Added in, EAA020811 
             SYNSEM.LOCAL.CAT.VAL [ SUBJ <>, 
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.XCAT.VAL [ SUBJ olist ,
				    COMPS #6,
                                    ICOMPS #7 ],
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [SORT verb-act-specification],
             SYNSEM.LOCAL.HEAD-SUBJ-APPLIED +,
	     FRONT-TO-FILL -,	; Added in, EAA010811
	     SYNSEM.NON-LOCAL #5  ] >,
     C-CONT.RELS <! !>,
     C-CONT.HCONS <!!>].

;mainly used for gapping LH111021
coordination-finite-1stsubjinv-clause := coordination-finite-clause &
  [ ARGS < [ SYNSEM.LOCAL.CAT.VAL.SUBJ ocons,
	     SYNSEM.LOCAL.CAT.HEAD.WH-MOVED -,
	     SYNSEM.LOCAL.OBJ-DEL-APPLIED -], [] > ].

coordination-finite-1stsubjnoninv-clause := coordination-finite-clause &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & 1-list,
	     SYNSEM.BY-DELETION - ], [] > ].


; the following two from GaGr
#|
verb-serial-mod-tr-tr-phrase := verb-serial-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CONT.HOOK.VARG #4,
   SYNSEM.LOCAL.CAT.QVAL trans-qval,
;    SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #4,
   HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX semarg ].
|#

object-deletion := const-ltol-rule &
 [ SYNSEM.LOCAL.CAT.VAL.SUBJ #3 & <[ LOCAL.CONT.HOOK.INDEX #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.XARG #4,
   SYNSEM.LOCAL.CONT.HOOK.VARG #index,
   SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   SYNSEM.LOCAL.CAT.QVAL #1 & trans-qval,
   SYNSEM.LOCAL.CAT.HEAD #2 & non-copula,
   SYNSEM.LOCAL.CAT.QVAL.DOBJECT #obj & [LOCAL.CONT.HOOK.INDEX #index],
   SYNSEM.VAL-CLASS #valclass,
;   SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.QVAL.DOBJECT #obj & [LOCAL.CONT.HOOK.INDEX #index],
;			       LOCAL.CAT.HEAD verb-all,
;			       LOCAL.CONT.HOOK.VARG #index]>,
;   BY-DELETION +,
   SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
   SYNSEM.LOCAL.CONNECT-PENDING +, ; use of this feature enforces the type of coordination for which this rule is intended, namely 'right node raising'
   DTR [ SYNSEM trans-arg1-2-synsem,
	SYNSEM.LOCAL.CAT.VAL.SUBJ #3,
   	SYNSEM.LOCAL.CONT.HOOK.VARG #index,
	 SYNSEM.LOCAL.CAT.VAL.COMPS < #obj >,
   	SYNSEM.LOCAL.CAT.QVAL #1 & trans-qval,
   	SYNSEM.LOCAL.CAT.QVAL.DOBJECT #obj & [LOCAL.CAT.HEAD.EXPLETIVE -,
					      LOCAL.CONT.HOOK.INDEX #index,
					      LOCAL.CAT.HEAD.KEYS.KEY anonym-k],; to avoid inher-comp nouns undergoing the rule, like smil, d√∏d etc
   	SYNSEM.LOCAL.CAT.HEAD #2,
   	SYNSEM.LOCAL.OBJ-DEL-APPLIED -,
	 SYNSEM.VAL-CLASS #valclass ], ; BY-DELETION -
   C-CONT [RELS <! !>,
           HCONS <! !>]].



; We need to distinguish between VP-coord and S-coord. In VP-coord, the subjects are identical, in S-coord they need not be. Either type may cooccur with inversion in first clause, and with comma after first clause.
; Specifics:
; to get "g√•r fra... og blir leder": combine verb and cop
; "idag sover jeg og jeg hviler" reguire that INV bool value not be necessarly identical, hence removed: 'INV #14' from 'HEAD verb-all & [INV #14]' and
; SYNSEM.LOCAL.XCAT [HEAD [INV #14] ],
; from second daughter ('XCAT' copies from lower node).
#|
coordination-v-phrase-sup := basic-head-mod-phrase-simple & head-initial & phrasal & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.XCAT.HEAD verb-all,
	      SYNSEM.LOCAL.CAT.VAL [ SUBJ cons],
	      SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE +,
             SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj & 1-list,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.XCAT.VAL [ SUBJ #subj,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #22,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS.LIST.FIRST arg12-relation & [LBL #lbl,
					      PRED "coreferential_rel",
					      ARG1 #2 & [PNG #p],
					      ARG2 #22 & [PNG #p]],
     C-CONT.RELS.LIST.REST.FIRST indef-q-rel & [PRED "_udef_q_rel",
						ARG0 #22,
						RSTR #rstr],
     C-CONT.HCONS <! [HARG #rstr,
		      LARG #lbl] !>].
|#

coordination-v-phrase-sup := basic-head-mod-phrase-simple & head-initial & phrasal & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb-all,					; Changed from XCAT to CAT.
	      	  SYNSEM.LOCAL.CAT.VAL [ SUBJ cons,
					 COMPS #6,
					 ICOMPS #7 ],
	      	  SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
			  SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE +,
             SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj & 1-list,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.XCAT.VAL [ SUBJ #subj,
				     COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #22,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
	     	 SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
             SYNSEM.LEX -,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <! arg12-relation & [LBL #lbl,
				      PRED "coreferential_rel",
				      ARG1 #2 & [PNG #p],
				      ARG2 #22 & [PNG #p]],
		       indef-q-rel & [PRED "_udef_q_rel",
						ARG0 #22,
						RSTR #rstr] !>,
     C-CONT.HCONS <! [HARG #rstr,
		      LARG #lbl] !>].

;C-CONT.RELS <! arg12-relation & [PRED "coreferential_rel",
;				      ARG1 #2 & [PNG #p],
;				      ARG2 #22 & [PNG #p]],... !>,
     
; removed this - gave clash when first verb had been inverted:
; [ SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>] 
coordination-v-phrase := coordination-v-phrase-sup &
  [  SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem > ],						; EAA020811 changed from cons
     ARGS < [SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem > ]],				; EAA020811 changed from cons
	    [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE -]] >,
     C-CONT.RELS <! [], [] !> ].

; Added this rule to accommodate inverted first verb, EAA.
coordination-v_inv-phrase := coordination-v-phrase-sup &
  [  SYNSEM.LOCAL.CAT.VAL.SUBJ cons,						
     ARGS < [SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
			 SYNSEM.LOCAL.CAT.HEAD.INV + ],	
	    [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE -]] >,
     C-CONT.RELS <! [], [] !> ].

coordination-with-corefobj-v-phrase := coordination-v-phrase-sup &
  [  ARGS < [ SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>,
	      SYNSEM.LOCAL.CONT.HOOK.VARG #3 & ref-ind], 
           [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE -],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD pers-pron,
						  CTXT pron-discbnd ],
	      SYNSEM.LOCAL.CONT.HOOK.VARG #4 & ref-ind] >,
     C-CONT.RELS <! arg12-relation & [PRED "coreferential_rel",
					  ARG1 #3 & [PNG #p],
					  ARG2 #4 & [PNG #p]], [] !> ].

coordination-relclause-phrase := coordination-v-phrase-sup &
  [  SYNSEM.LOCAL.CAT.HEAD [DECL +,
			    IMPERATIVE -],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
     ARGS < [  SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
	       SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +],
	       SYNSEM.LOCAL.REL-CL-SOM-INIT +], 
           [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE +]] >,
     C-CONT.RELS <! [],[] !> ].

coordination-modal-dir-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD #adv & adv-reg & [KEYS.KEY dir],
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD #adv & adv-reg & [KEYS.KEY dir],
              SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
            head-wordcoord-nonequal-comp-phrase &
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].


coordination-adjective-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD adj-reg & [KEYS.KEY #3,
                                  MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD adj-reg & [KEYS.KEY #3,
                                                MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

; not so clear what this should do - rule commented out
coordination-to-v-by-coord-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
              SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

coordination-number-coord-phrase :=  rule & coordinating-phrase &
  [ SYNSEM [LOCAL.CAT.HEAD cardnum,
            LOCAL.CONT.HOOK.INDEX.SORT card-unit],
    ARGS < [SYNSEM [LOCAL.CAT.HEAD comm-noun,
                     LOCAL.CONT.HOOK.INDEX.SORT number-unit,
                     LOCAL.CAT.HEAD.KEYS.KEY measnoun]],
           head-numbercoord-comp-phrase >].





; SYNSEM types

arg1-subj-synsem := lex-synsem &
 [ LOCAL.CONT mrs,
   LOCAL [CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE -,
			 LOCAL.CONT.HOOK.INDEX #1 & ref-ind]>],
   LKEYS.KEYREL.ARG1 #1 ].

eventarg1-subj-synsem := lex-synsem &
 [ LOCAL.CONT mrs,
   LOCAL.CAT.HEAD.INV -,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE -,
			 LOCAL.AGR.PNG.NG.NUM sing,
			 LOCAL.AGR.PNG.PERS thirdpers,
			 LOCAL.CONT.HOOK.INDEX super-event & [PNG.PERS thirdpers],
                         LOCAL.CONT.HOOK.LTOP #1] >,
   LKEYS.KEYREL.ARG1 #1 ].

intrans-synsem := lex-synsem &
 [ LOCAL.CONT mrs,
   LOCAL.CAT intrans-cat,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE -] >,
   LOCAL.DELIMTELACTV -,
   LOCAL.HAS-A-V-COMPLEMENT - ].

; removed ,
;   NON-LOCAL.SLASH <! !>
; in order to enable "jeg vet hvem som kommer"
intrans-arg1-synsem-super := intrans-synsem & arg1-subj-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>,
	       QVAL intrans-qval ]].

intrans-eventarg1-synsem := intrans-synsem & eventarg1-subj-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>]].

;intrans-eventarg1-obl-synsem := intrans-eventarg1-obl-synsem-sup & eventarg1-subj-synsem.


arg2-comps-synsem := lex-synsem &
  [ LOCAL [ CAT.VAL.COMPS.FIRST [LOCAL.CONT.HOOK.INDEX #1 & semarg,
				 LOCAL.CAT.HEAD.EXPLETIVE -]],
    LOCAL [ CAT.QVAL.DOBJECT [LOCAL.CONT.HOOK.INDEX #1 & semarg ]],
    LKEYS.KEYREL.ARG2 #1 ].


arg2-qvalcomps-synsem := lex-synsem &
  [ LOCAL [ CAT.QVAL.DOBJECT [LOCAL.CONT.HOOK.INDEX #1 & semarg ]],
    LKEYS.KEYREL.ARG2 #1 ].
  
arg1-comps-synsem := lex-synsem &
  [ LOCAL [ CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 & semarg ] >],
    LKEYS.KEYREL.ARG1 #1 ].

; only for NP NP - for clauses, see ditrans-subord
arg23-comps-synsem := lex-synsem &
  [ LOCAL [ CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 & ref-ind ],
                            [LOCAL.CONT.HOOK.INDEX #2 & ref-ind ]>],
    LKEYS.KEYREL.ARG3 #1,
    LKEYS.KEYREL.ARG2 #2 ]. 

trans-synsem := lex-synsem &
  [ LOCAL.CAT trans-1ncomps-empty-icomps-cat & [ QVAL trans-qval ]].
 

ditrans-synsem := lex-synsem &
  [ LOCAL.CAT ditrans-cat & [ VAL.COMPS <  [LOCAL.ADJ-SITE-OPEN +, ; avoid "ga et land til penger"
					    LOCAL.CAT.HEAD np-head],
					   [LOCAL.CAT.HEAD np-head] >,
                              VAL.ICOMPS <> ]].

arg1-predicative-synsem := lex-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #1,
    LKEYS.KEYREL.ARG1 #1 ].

arg2-predicative-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #1,
    LKEYS.KEYREL.ARG2 #1 ].

argx-predicative-synsem := lex-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #2,
    LKEYS.KEYREL.ARGX #2 ].

argcsx-predicative-synsem := lex-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #2,
    LKEYS.KEYREL.LBL #1,
    LOCAL.CONT.RELS <! [], arg12-relation & [ PRED "cause-rel",
					      ARG1 #1,
					      ARG2 #2 ] !> ].


;;; SYNSEMs DIRECTLY SUPPORTING VERB-LEXEMEs

intrans-arg1-synsem := intrans-arg1-synsem-super &
  [ LOCAL.CONT.HOOK hook ].

; synsems for verbs with subjects undergoing path-movement
intrans-arg1dir-synsem := intrans-arg1-synsem-super &
    [ LOCAL.CONT.HOOK dir-hook & [DIRARG #1,
				  XARG #1],
      LKEYS.KEYREL arg1-relation & [ARG1 #1],
      LOCAL.CAT.VAL.ICOMPS <>].

intrans-arg1dir-temp-synsem := intrans-arg1-synsem-super &
    [ LOCAL.CONT.HOOK dir-hook & [DIRARG #1,
				  XARG #1,
				  INDEX.ROLE timespan],
      LKEYS.KEYREL arg1-relation & [ARG1 #1],
      LOCAL.CAT.VAL.ICOMPS <>].

; for "drive" in "driver og g√•r": it enforces atelicity for the whole constr.
intrans-arg1-atelic-synsem := intrans-arg1-synsem-super &
    [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
      LOCAL.CAT.VAL.ICOMPS <>].

#|
intrans-locobl-synsem := arg1-subj-synsem & lbl-ltop-lex-item &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #2 & handle,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ]].
|#

;almost same def as intrans-obl-synsem-sup
;    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
; because otherwise all locative preps would need a special 'seleced' variant

#|
intrans-locobl-synsem :=  arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #vrg ],
    LOCAL.KEY-SPEC #1,
;    LOCAL.CAT.VAL.COMPS onull,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #4 & handle,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.VARG #vrg,
    LOCALLOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
							       KEYS.KEY #1 & index-sit],
				LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
						      ROLE xdim-to-xdim-spatial]]>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #4 ] ].
|#

intrans-locobl-synsem :=  arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #3],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <#obl & [LOCAL.CAT.HEAD [KEYS.KEY #1,
						  SELECTED -],
				  LOCAL.CONT.HOOK.INDEX.ROLE xdim-to-xdim-spatial ]>,
    LOCAL.CAT.QVAL.OBL1 #obl & [LOCAL.CONT.HOOK.LTOP #2 & handle,
				LOCAL.CONT.HOOK.VARG #3],
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ] ].


#|
    LOCAL.CAT.VAL.ICOMPS < #4, ...>,
    LOCAL.CAT.QVAL with-obl-pp-qval & [ OBL1 #4 & [ LOCAL.CAT [ HEAD prep-or-adv,
								VAL.COMPS null ] ] ],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 & index-sit ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #2 & handle,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel,
;    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
|#
;    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ] ].


intrans-eventarg1-decl-synsem := intrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [ DECL + ]] > ].

intrans-eventarg1-interr-synsem := intrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

intrans-eventarg1-absinf-synsem := intrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -] ] > ].
#|
; defined elsewhere
intrans-eventarg1-obl-n-synsem := intrans-eventarg1-obl-synsem & intrans-eventarg1-obl-n-synsem.
|#

intrans-eventarg1-decl-obl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [ DECL + ] ] > ].
intrans-eventarg1-interr-obl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].
intrans-eventarg1-absinf-obl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
							 DECL + ]] > ].


intrans-eventarg1-decl-obl-n-synsem := intrans-eventarg1-obl-n-synsem & intrans-eventarg1-decl-obl-synsem.
intrans-eventarg1-interr-obl-n-synsem := intrans-eventarg1-obl-n-synsem & intrans-eventarg1-interr-obl-synsem.
intrans-eventarg1-absinf-obl-n-synsem := intrans-eventarg1-obl-n-synsem & intrans-eventarg1-absinf-obl-synsem.
 

intrans-eventarg1-eventobl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]> ].

#|
intrans-eventarg1-eventobl-decl-synsem := intrans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL + ]].
intrans-eventarg1-eventobl-interr-synsem := intrans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL - ]].
|#

intrans-eventarg1decl-eventobldecl-synsem := intrans-eventarg1-decl-obl-synsem & intrans-eventarg1-eventobl-decl-synsem.
intrans-eventarg1decl-eventoblinterr-synsem := intrans-eventarg1-decl-obl-synsem & intrans-eventarg1-eventobl-interr-synsem.
intrans-eventarg1interr-eventobldecl-synsem := intrans-eventarg1-interr-obl-synsem & intrans-eventarg1-eventobl-decl-synsem.
intrans-eventarg1interr-eventoblinterr-synsem := intrans-eventarg1-interr-obl-synsem & intrans-eventarg1-eventobl-interr-synsem.




; "fungere godt", "dufte godt"
intrans-obladv-synsem := arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD adv & [ SELECTED +,
                                                 KEYS.KEY #1],
			  LOCAL.CONT.HOOK.XARG #2 ]>].

; "se alvorlig p√•"
intrans-adv-obl-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.HEAD.KEYS.KEY advoblvb,
    LOCAL.CONT.HOOK hook & [INDEX #1],
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adv & [KEYS.KEY adv-m],
                            LOCAL.CONT.HOOK.XARG #1 ]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED + ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -]].

#|
zero-obl-synsem-sup := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ LTOP #3,
			     VARG #2 ],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #3,
			   LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LKEYS.KEYREL.ARGOBLQ #2 ].
|#


zero-obl-synsem-sup := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #2 ],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LKEYS.KEYREL.ARGOBLQ #2,
    LOCAL.CAT.VAL.ICOMPS < #7 >,
    LOCAL.CAT.QVAL.OBL1 #7 ].

;LH100513: cut the identity betweeb ARGOBL's handle and top VARG, to get tough-mov for 'Jon er hyggelig √• snakke med'; not sure if that affects any for introbl
intrans-obl-synsem-sup := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #3],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE -]>,
    LOCAL.CAT.VAL.ICOMPS <#obl & [LOCAL.CAT.HEAD [KEYS.KEY #1,
						  SELECTED +] ]>,
    LOCAL.CAT.QVAL.OBL1 #obl & [LOCAL.CONT.HOOK.LTOP #2 & handle,
				LOCAL.CONT.HOOK.VARG #3],
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ] ].

intrans-eventarg1-obl-synsem-sup := eventarg1-subj-synsem & intrans-obl-synsem-sup &
[LOCAL.CAT.VAL.COMPS <>].

; "stole p√• Ola", "snakke om meg"
#|
intrans-obl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK hook & [ LTOP #3 ],
    LOCAL.CAT.VAL.COMPS < >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #3]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]> ].
|#

intrans-eventarg1-obl-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.COMPS < >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]> ].

; BINDING nontamed & [REFL-I -],

#|
intrans-obl-n-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT [QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #1 & ref-ind],
                                   HEAD [SELECTED +,
                                         KEYS.KEY fct-spec ]],
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]].
|#

intrans-obl-n-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.HEAD.KEYS.KEY fct-spec,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD np-head,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX ref-ind,
						      BINDING nontamed]].

; at.. beror p√• Ola 
intrans-eventarg1-obl-n-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX ref-ind,
						      BINDING nontamed & [REFL-I -]]].

#|
; at.. beror p√• Ola 
intrans-eventarg1-obl-n-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT [QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #1 & ref-ind],
                                   HEAD [SELECTED +,
                                         KEYS.KEY fct-spec ]],
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]].
|#
 
; "stole p√• at...", "snakke om at..."
#|
intrans-obl-decl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite,
						       CONT.HOOK.LTOP #1 & handle],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].
|#

intrans-obl-decl-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD fin-comp & [DECL +],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

; "bero p√• at...", "avhenge av at..."
intrans-eventarg1-eventobl-decl-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD fin-comp & [DECL +],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

;TODO ensure that the prep governs an interr-clause LH04102021
; "snakke om hvorvidt/hvem..."
intrans-obl-interr-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX event & [SF ques],
						      BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD verb-or-comp & [ DECL - ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
   LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]  ].

; "at.. beror p√• hvorvidt/hvem..."
intrans-eventarg1-eventobl-interr-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD verb-or-comp & [ DECL - ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
;    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED + ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]  ].

intrans-obl-arbinf-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

intrans-eventarg1-eventobl-arbinf-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

;LH 300411: changed to TRANSPAR bool because "jeg ber om √• komme" otherwise parsed not. have forgotten what TRANSPAR really is for...  NOW remember - + when equi
; ,
;				ARGOBLQ #1
intrans-obl-equinf-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
;    LOCAL.CONT.HOOK.LTOP handle  ;#1 & handle,
    LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
							KEYS.KEY #3 & rais],
			    LOCAL.CONT.HOOK.XARG #4 ] >,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.KEY-SPEC #3,
    LKEYS.KEYREL arg1obl-rel & [ ARG1 #4 ] ].

#|
;defining is in lex-v-types instead
intrans-obl2-equinf-synsem := arg1-subj-synsem & intrans-2obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL2.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD nominal],
			   [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
							KEYS.KEY #3 & rais],
			    LOCAL.CONT.HOOK.XARG #4 ] >,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.KEY-SPEC #3,
    LKEYS.KEYREL arg1obl-rel & [ ARG1 #4 ] ].
|#




intrans-obl-adv-equinf-synsem := arg1-subj-synsem &
  [ LOCAL.CONT.HOOK.LTOP #5,
    LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE -]>,
;    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
;                                                      CAT.HEAD infin-comp & [ TRANSPAR +,
;									      DECL +,
;									      KEYS.KEY infinit-comp ],
 ;                                                     CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [LOCAL.CONT.HOOK.LTOP #5,
			    LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl,
                                                       SELECTED +] ]>,
    LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
							KEYS.KEY #3 & rais],
			    LOCAL.CONT.HOOK.LTOP #1 & handle,
			    LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
							  CAT.HEAD infin-comp & [ TRANSPAR +,
										  DECL +,
										  KEYS.KEY infinit-comp ],
							  CONT.HOOK.INDEX.E.TENSE infin],
			    LOCAL.CONT.HOOK.XARG #4 ] >,
    LOCAL.KEY-SPEC #6,
    LOCAL.ALT-SPEC #3,
    LKEYS.KEYREL arg1obl-rel & [ ARG1 #4,
				 ARGOBLQ #1 ] ].



;;; DPF 020411

intrans-atel-obl-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY atelic-operation ]]> ].



#|
intrans-atel-obl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY atelic-operation ]]> ].
|#


;;; DPF 020411


intrans-obl-refl-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #xarg,
    LOCAL.CONT.HOOK.INDEX.SIT-TYPE semelfactive,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS < [LOCAL [CAT.QVAL.DOBJECT.LOCAL #loc & [CONT.HOOK.INDEX #index,
								  BINDING[ BOUND +,
									   REFL-I +,
									   REFL-II -,
									   LEX-TAME + ]]]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.HEAD.KEYS.KEY atelic-operation,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #ltop,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL #loc,
    LKEYS.KEYREL.ARGOBLQ #ltop,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.RELS <! [], [], [ARG1 #index,
									   ARG2 #xarg] !>,
    LOCAL.CAN-PASSIVIZE -].



; "lee p√• seg"
#|
intrans-obl-refl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #xarg,
    LOCAL.CONT.HOOK.INDEX.SIT-TYPE semelfactive,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.HEAD.KEYS.KEY atelic-operation,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #index,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING[ BOUND +,
                                                              REFL-I +,
                                                              REFL-II -,
                                                              LEX-TAME + ],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.RELS <! [], [], [ARG1 #index,
									   ARG2 #xarg] !>].
|#


intrans-2obl-synsem-sup := arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-with-2icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY index-sita]],
                          [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY index-sita]]>].
;,
;    NON-LOCAL.SLASH <! !>].

; "snakke med Ola om meg"
intrans-2obl-synsem := intrans-2obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]],
                          [LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


; for "han later/kommer til √• sove"
; the lexical entries will identify what follows them, down to KEYS.KEY value
intrans-rais-from-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.VARG #42,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < #obl1 & [ LOCAL.CONT.HOOK.LTOP #42,
				      LOCAL.CONT.HOOK.XARG #5,
				      LOCAL.CAT.HEAD prep-comp & [KEYS.KEY #4 & rais],
				      LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp] >,
                   COMPS <> ],
    LOCAL.CAT icomps-cat,
    LOCAL.CAT.QVAL.OBL1 #obl1,
    LKEYS.KEYREL.ARGOBLQ #42].

#|
intrans-decl-in-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.VARG #42,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < #obl1 & [ LOCAL.CONT.HOOK.LTOP #42,
				      LOCAL.CONT.HOOK.XARG #5,
				      LOCAL.CAT.HEAD prep-comp & [KEYS.KEY #4],
				      LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD fin-comp & [DECL +] ] >,
                   COMPS <> ],
    LOCAL.CAT icomps-cat,
    LOCAL.CAT.QVAL.OBL1 #obl1,
    LKEYS.KEYREL.ARGOBLQ #42].
|#

intrans-interr-in-pp-arg1-synsem := intrans-event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL [ICOMPS < [ LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD [DECL -] ] > ]].

intrans-decl-in-pp-arg1-synsem := intrans-event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL [ICOMPS < [ LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD fin-comp & [DECL +] ] > ]].

intrans-absinf-in-pp-arg1-synsem := intrans-event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL [ICOMPS < [ LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [DECL +,
										 TRANSPAR -] ] > ]].

trans-decl-in-pp-arg1-synsem := trans-event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL [ICOMPS < [ LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD fin-comp & [DECL +] ] > ]].

trans-absinf-in-pp-arg1-synsem := trans-event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL [ICOMPS < [ LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [DECL +,
										 TRANSPAR -] ] > ]].

trans-interr-in-pp-arg1-synsem := trans-event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL [ICOMPS < [ LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD [DECL -] ] > ]].

event-in-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.VARG #42,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX semarg,
			   LOCAL.CAT.HEAD expl-pron]>,
                   ICOMPS < #obl1 & [ LOCAL.CONT.HOOK.LTOP #42,
				      LOCAL.CAT.HEAD prep-comp & [KEYS.KEY #4]] > ],
    LOCAL.CAT icomps-cat,
    LOCAL.CAT.QVAL.OBL1 #obl1,
    LKEYS.KEYREL.ARGOBLQ #42].

intrans-event-in-pp-arg1-synsem := event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL.COMPS <> ].

trans-event-in-pp-arg1-synsem := event-in-pp-arg1-synsem &
 [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nominal ] > ].

trans-rais-from-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.VARG #42,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [COMPS < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < #obl1 & [ LOCAL.CONT.HOOK.LTOP #42,
				      LOCAL.CONT.HOOK.XARG #5,
				      LOCAL.CAT.HEAD prep-comp & [KEYS.KEY #4 & rais],
				      LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp] >],
    LOCAL.CAT icomps-cat,
    LOCAL.CAT.QVAL.OBL1 #obl1,
    LKEYS.KEYREL.ARGOBLQ #42].

; for "han ser ut til √• sove"
intrans-adv-rais-from-pp-arg1-synsem := zero-obl-synsem-sup & lex-item-1rel &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #6,
    LOCAL.ALT-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl]>, 
                   ICOMPS < [ LOCAL.CONT.HOOK.LTOP #42,
			      LOCAL.CONT.HOOK.XARG #5,
			      LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ],
			      LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
                   COMPS <lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #3,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl,
                                                       SELECTED +] ]> ],
    LOCAL.CAT.QVAL.OBL1 [ LOCAL.CONT.HOOK.LTOP #42,
			  LOCAL.CONT.HOOK.XARG #5,
			  LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ],
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl],
    LKEYS.KEYREL.ARGX #3,
    LKEYS.KEYREL.ARGOBLQ #42].


; for "det later til at han sover"
; the lexical entries will identify what follows them, down to KEYS.KEY value
intrans-epon-with-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < [ LOCAL.CONT.HOOK.XARG #5,
			      LOCAL.CONT.HOOK.LTOP #lbl,
			      LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ]] >,
                   COMPS <> ],
    LKEYS.KEYREL.ARGOBLQ #lbl ].

; for "det ser ut til at han sover"
intrans-adv-epon-with-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.ALT-SPEC #6,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < [ LOCAL.CONT.HOOK.XARG #5,
			      LOCAL.CONT.HOOK.LTOP #lbl,
			      LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ]] >,
                   COMPS <lex-synsem &
                           [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl,
                                                       SELECTED +] ]> ],
    LKEYS.KEYREL.ARGOBLQ #lbl ].


; for "han virker frisk", "han later/kommer til √• sove"
; the lexical entries will identify what follows them, down to KEYS.KEY value

intrans-secpred-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #4 ],
                             LOCAL.CONT.HOOK.LTOP #7] >,
                   ICOMPS <> ],
    LKEYS.KEYREL.ARG1 #7].

intrans-secpred-rais-from-som-clause-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < #subj & [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < #pred & [ LOCAL.CONT.HOOK.XARG #6,
                             LOCAL.CAT.HEAD [KEYS.KEY #4 ],
                             LOCAL.CONT.HOOK.LTOP #7] >,
                   ICOMPS <> ],
    LOCAL.CAT.QVAL.SUBJECT #subj,
    LOCAL.CAT.QVAL.PREDIC #pred,
    LOCAL.CONT.RELS <!  [],
                               arg12-relation & [PRED "coreferential_rel",
                                                 ARG1 #5 & [PNG #p],
                                                 ARG2 #6 & [PNG #p]] !>,
    LKEYS.KEYREL.ARG1 #7].

; for "han synes en venn"
intrans-secpred-rais-from-n-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1] >,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
;			    LOCAL.DERIVED-HEAD -,
;			    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
                            LOCAL.CAT.HEAD np-head & [ DEFINITE - ]] >,
    LOCAL.CAT.VAL.ICOMPS <>,  
    LOCAL.CONT.RELS <! [ARG1 #3], [ LBL #3,
				    PRED "_instantiate_c_rel",
				    ARG1 #1,
				    ARG2 #5 ] !>,
    NON-LOCAL.SLASH <!!> ].




epon-intrans-secpred-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.LTOP #2,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #4 & absadj0-epon ]] >,
                   ICOMPS <> ],
    LOCAL.CONT.RELS <! [ARG1 #2], [] !>].

presentational-synsem-3 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				  PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #2], [] !>,
    LOCAL.CONT.HCONS <! !> ].


; TODO - LH300712 not yet working
epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-synsem := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD expl-pron,
			   LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY #4],
			   []>,
                   ICOMPS <> ],
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				   PRED "intro-sit-rel",
				   ARG1 #5,
				   ARG2 #2], [] !>,
    LOCAL.CONT.HCONS <! !> ].


;    LOCAL.CONT.RELS <! [ARG1 #6], [], [LBL #6,
;				       ARG1 #8] !>].


#|
presentational-synsem-3 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				  PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #2], [] !>,
    LOCAL.CONT.HCONS <! !> ].


epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-synsem := presentational-synsem-3 &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY #4,
			     LOCAL.CONT.HOOK.LTOP #6],
;			     LOCAL.CONT.HOOK.INDEX #3],
			   [LOCAL.CONT.HOOK.INDEX #8]>,
                   ICOMPS <> ],
    LOCAL.CONT.RELS <! [ARG1 #6], [], [LBL #6,
				       ARG1 #8] !>].
|#

;     LOCAL.CONT.RELS <! [ARG1 #2 ], [], [LBL #2,
;					 ARG1 #1] !>].

; & argx-predicative-synsem
; for "han stiller som reserve"
intrans-secpred-som-arg1-x-synsem := arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-som ],
			     LOCAL.CONT.HOOK.LTOP #ltop,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #1]] >],
    LKEYS.KEYREL.ARGX #ltop ].

#|
;not used, since v-copPredprtcl seems to cover same ground
intrans-secpred-som-eventarg1-x-synsem := eventarg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-som ],
			     LOCAL.CONT.HOOK.LTOP #ltop,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #1]] >],
    LKEYS.KEYREL.ARGX #ltop ].
|#

intrans-eventarg1-secpred-som-arg1-x-synsem := eventarg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #1]] >]].


;  "han ser syk ut". 
; dir inst of adv-selct
intrans-secpred-prtcl1-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.LTOP #ltop,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #6,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred1-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5],
                           [ LOCAL.CONT.HOOK.LTOP #ltop,
			     LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY #6 & pcl ]] >]].

; han ser ut som en venn
intrans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #6,
    LOCAL.CONT.HOOK.INDEX #5,
    LOCAL.CAT intrans-ncomps-doublesecpred1-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #2]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD adv-reg],
                           [ LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD [KEYS.KEY #6 & som-pred-n ],
                             LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nom] >]].

trans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #6,
    LOCAL.CONT.HOOK.INDEX #5,
;    LOCAL.CAT trans-ncomps-doublesecpred1-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #2]>, 
                   COMPS < [],
			   [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD adv-reg],
                           [ LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD [KEYS.KEY #6 & predcomp-som ]] >]].

trans-secpred-prtcl1a-rais-from-nonverbal-arg1-som-pred-n-synsem := trans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem &
 [ LOCAL.CAT.VAL.COMPS <[],[],[LOCAL.CAT.HEAD [KEYS.KEY som-pred-n ],
                             LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nom]> ].

trans-secpred-prtcl1a-rais-from-nonverbal-arg1-som-pred-adj-synsem := trans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem &
 [ LOCAL.CAT.VAL.COMPS <[],[],[LOCAL.CAT.HEAD [KEYS.KEY som-pred-adj ],
                             LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD adj]> ].



; ; "se ut til √• komme"; 
; "han ser ut til √• komme", "det ser ut til √• komme en gutt"
; now KEYS.KEY pcl rather than adv-selct
intrans-secpred-prtcl2-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred2-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY pcl ]],
                           [ LOCAL.CONT.HOOK.XARG #6,
                             LOCAL.CAT.HEAD prep-comp,
                             LOCAL.CAT.HEAD [KEYS.KEY rais ] ] >],
    LOCAL.CONT.RELS <!  [],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #5 & [PNG #p],
                                                 ARG2 #6 & [PNG #p]] !>,
    LKEYS.KEYREL.ARG1 #3 ].

#|
v-intrPrtclObl-oblN-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred2-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX index]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY pcl ]],
                           [ LOCAL.CONT.HOOK.XARG #6,
                             LOCAL.CAT.HEAD prep-comp ] >],
    LOCAL.CONT.RELS <!  [],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 index,
                                                 ARG2 #6] !>,
    LKEYS.KEYREL.ARG1 #3 ].



v-intrPrtclObl-oblN := lexeme &
 [SYNSEM v-intrPrtclObl-oblN-synsem].
|#

; ,
;                             LOCAL.CAT.HEAD [KEYS.KEY predcomp-om ]
intrans-secpred-prtcl3-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK.LTOP #1,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred2-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.LTOP #1,
			     LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY pcl ]],
                           [ LOCAL.CONT.HOOK.LTOP #3,
			     LOCAL.CONT.HOOK.XARG #6,
                             LOCAL.CAT.HEAD som-or-for ] >],
    LOCAL.CONT.RELS <!  [],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #5 & [PNG #p],
                                                 ARG2 #6 & [PNG #p]] !>,
    LKEYS.KEYREL.ARG1 #3 ].


; for "kjelen koker tom"
intrans-secpred-argx-synsem := argx-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < #subj & [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing]]>, 
                   COMPS < #pred & [ LOCAL.CONT.HOOK.XARG #5,
				     LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #1]] >,
                   ICOMPS <>],
    LOCAL.CAT.QVAL.SUBJECT #subj,
    LOCAL.CAT.QVAL.PREDIC #pred ].

; for "kjelen koker tom"
intrans-secpred-argcsx-synsem := argcsx-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #1]] >,
                   ICOMPS <>]].

; for "skinken henger m√∏r"
intrans-secpred-arg1-csx-synsem := argcsx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #1]] >,
                   ICOMPS <>]].

intrans-secpred-adj-argcsx-synsem := intrans-secpred-argcsx-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj-reg] > ].
intrans-secpred-pp-argcsx-synsem := intrans-secpred-argcsx-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep] > ].

; doubtful whether this is the right one: we might want the subject
; to have a role, as in "varme opp" ('he is warming up before the race');
; here we only get the counterpart of "vannet koker opp";
; but the semantics of the ca. 250 cases is quite heterogeneous. So
; the type mainly serves to identify a group of cases
intrans-telicity-particle-arg1-synsem := argx-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < lex-synsem &
                           [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #1 & pcl,
                                                       SELECTED +] ] >, 
                   ICOMPS <>],
    LKEYS.KEYREL.ARG1 #5,
    NON-LOCAL.SLASH <! !>].

intrans-telicparticle-arg1-synsem := intrans-telicity-particle-arg1-synsem & 
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE telic,
    LOCAL.CAT.VAL [COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ] >]].

; for "drive/holde" in "driver/holder p√• og g√•r": it enforces atelicity for the whole constr.
intrans-atelicparticle-arg1-synsem := intrans-telicity-particle-arg1-synsem & 
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE activity,
    LOCAL.CAT.VAL [COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ] >]].

; for "han synes komme"
intrans-secpred-rais-from-verbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [ LOCAL.CAT.HEAD verb-all & [IMPERATIVE -],
                             LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #5] >,    
                            LOCAL.CONT.HOOK.INDEX.E.TENSE infin ]>]].


; "han synes √• komme"
intrans-secpred-rais-from-infinmarked-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl]>, 
                   COMPS < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +,
							  KEYS.KEY infinit-comp-eq],
                             LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                             LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #5] > ]>],
    NON-LOCAL.SLASH <!!> ].

;han viser seg √• komme
trans-secpred-rais-refl-tosubj-from-infinmarked-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.AGR.PNG #2 ]>, 
                   COMPS < [LOCAL.CAT.HEAD pers-pron, ;; MHS 090813 Adding this constraint due to problems this synsem type gives rise to in relation to the head-verb-bareinfin-comp-rule, as seen in sentences such as 'ola viser seg √• v√¶re syk'. 
	                    LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #5 ] >,
                            LOCAL.CONT.HOOK.VARG #5,
                             LOCAL.AGR.PNG #2  ],
                           [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                             LOCAL.CONT.HOOK.LTOP #7,
                             LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] > ]>],
    LKEYS.KEYREL.ARG1 #7].

la-seg-se-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.AGR.PNG #2 ]>, 
                   COMPS < [ LOCAL.CAT.HEAD pers-pron,
			     LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #5 ] >,
                            LOCAL.CONT.HOOK.VARG #5,
                             LOCAL.AGR.PNG #2,
			     LOCAL.BINDING [ REFL-I +,
                                        REFL-II - ]  ],
                           [ LOCAL.CAT.HEAD verb-all,
                             LOCAL.CONT.HOOK.LTOP #7,
 ;                            LKEYS.KEYREL.ARG1 #8,
                             LKEYS.KEYREL.ARG2 #5 ] >],
    LKEYS.KEYREL.ARG1 #7].

#|
,
    LOCAL.CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				 ARG0 #8,
				 RSTR #15 ], pron_rel & [ PRED "_understood-agent_rel",
							 LBL #16,
							 ARG0 #8 ] !>,
    LOCAL.CONT.HCONS <! [ HARG #15,
			     LARG #16] !>].
|#

; LH160818 to make this go through, had to outcomment line 'NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>' in head-verb-verbal-comp-phrase , inherited down to the special rule '... sangen-synge ...', while all other subtypes of the rule have the restriction.
la-sangen-synge-synsem := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD.KEYS.KEY la-sangen-synge-vb,
    LOCAL.CAT.VAL [SUBJ < [ ]>, 
                   COMPS < [ LOCAL.CAT.HEAD nom,
			     LOCAL.CONT.HOOK.INDEX #9,
			     LOCAL.BINDING [ REFL-I -,
					     REFL-II -,
					     LEX-TAME - ] ],
                           [ LOCAL.CAT.HEAD verb-all & [VOICE active ],
			     LOCAL.CONT.HOOK.LTOP #7,
			     LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                             LKEYS.KEYREL arg12-relation,
 ;                            LKEYS.KEYREL.ARG1 #8,
                             LKEYS.KEYREL.ARG2 #9 ] >],
    LKEYS.KEYREL.ARG2 #7].

trans-secpred-refl-argx-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.AGR.PNG #2 ]>, 
                   COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #5 ] >,
                            LOCAL.CONT.HOOK.VARG #5,
                            LOCAL.AGR.PNG #2  ],
                           [ LOCAL.CAT.HEAD adj,
                             LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CONT.HOOK.LTOP #7 ]>],
    LOCAL.CAN-PASSIVIZE -,
    LKEYS.KEYREL.ARG1 #7].



; for "han har kommet/blir skutt"
intrans-secpred-rais-from-perfect-verbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [ LOCAL.CAT.HEAD verb-all,
                             LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] >,    
                            LOCAL.CONT.HOOK.INDEX.E.TENSE perf ]>]].


; for "jeg lader opp"




; "pr√∏ve √• komme"
subj-equi-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1,
			 LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.COMPS < phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

; "ville komme"
subj-equi-bare-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.HEAD.MODALITY non-deontic,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < synsem &
                         [LOCAL.CAT.HEAD verb-all,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

subj-equi-pp-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                      KEYS.KEY #3 & rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.COMPS list,
   LOCAL.KEY-SPEC #3,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].

; "be om √• komme"; "snakke om √• komme"
subj-equi-pp-synsem := subj-equi-pp-synsem-sup &
 [ LOCAL.CAT.VAL.COMPS <>].

; "drive med √• komme"
subj-equi-pp-atelic-synsem := subj-equi-pp-synsem-sup &
    [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
      LOCAL.CAT.VAL.COMPS <> ].


subj-prtcl-equi-pp-atelic-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK.LTOP #5,
   LOCAL.CONT.HOOK hook,
   LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
   LOCAL.KEY-SPEC #3,
   LOCAL.ALT-SPEC #4,
   LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #1]>],
   LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #5,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                      KEYS.KEY #3 & med-rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
                          LOCAL.CONT.HOOK.INDEX.SORT non-fix-point]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].

subj-prtcl-pp-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK.LTOP #5,
   LOCAL.CONT.HOOK hook,
   LOCAL.KEY-SPEC #4,
   LOCAL.ALT-SPEC #3,
   LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #1]>],
   LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #5,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                      KEYS.KEY #3],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].

eventsubj-prtcl-pp-synsem := eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK.LTOP #5,
   LOCAL.CONT.HOOK hook,
   LOCAL.KEY-SPEC #4,
   LOCAL.ALT-SPEC #3,
   LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.LTOP #1]>],
   LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #5,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                      KEYS.KEY #3],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].

subj-obj-prtcl-pp-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK.LTOP #5,
   LOCAL.CONT.HOOK hook,
   LOCAL.KEY-SPEC #4,
   LOCAL.ALT-SPEC #3,
   LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #0]>],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1],
			 lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #5,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                      KEYS.KEY #3],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #0,
   LKEYS.KEYREL.ARG2 #1].

subj-prtcl-pp-loc-synsem := subj-prtcl-pp-synsem &
 [ LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel ].

subj-equi-particle-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.ALT-SPEC #4,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1,
			 LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ],
			 phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].



; having suspended prep-indirwhquest-word, this type is non-operative
; "lure p√• hva som skjer"
intrans-indirwhquest-pp-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                      KEYS.KEY clse],
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.DECL -,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX event,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2].


; for "vaske seg" + "vaske koppen"  <...
trans-arg1-2-synsem-sup := trans-synsem & arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX ref-ind,
			   LOCAL.CAT.HEAD.PRESENTED -,
			   LOCAL.CAT.HEAD.EXPLETIVE -] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.CAT trans-nosecpred-empty-icomps-cat,
    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #3,
    LOCAL.HAS-A-V-COMPLEMENT -,
    LOCAL.CONT.HOOK.VARG #3,
    LKEYS.KEYREL.ARG2 #3 ].

;;;REFL in long run, but not now
;trans-arg1-2-synsem := trans-arg1-2-synsem-sup &
;  [ LOCAL.CONT.HOOK hook,
;    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].
; removed LOCAL.CONT.HOOK.INDEX.ROLE non-initiator, not because that is false, but because it needs cross-classification with all other sorts of NP specifcations coming from the object
; also removed LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun as COMPS specification, as it excludes too much, like "det er fredag"                            
trans-arg1-2-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.LEX-TAME -,
			    LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			    LOCAL.BINDING.BOUND bool] >]. ; '-' blocks non-tame reflexives, perhaps ("fort√¶re seg selv"). yes, so back to bool.

;LH020216  Emergency solution: since the 'seg' comes with an independent binder, the mrs gets illformed - two quantifiers binding the same variable. Bu currently, other parts of the binding apparatus blocks 'jeg skammer meg' from coming through at all. See roots.tdl and head-verb-tame-comp-phrase.
trans-arg1-2refl-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
;                           LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.CAN-MAL-DROP +, ; for reflexive object - for mal-gram uses!
			   LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2,
			   LEX +,
                           LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun ] >,
    LOCAL.CAN-PASSIVIZE -,
    NON-LOCAL.SLASH <! !>].

#|
trans-arg1-2refl-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.XARG #xarg,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
			   LOCAL.CONT.RELS <! [], [], [ARG1 #index,
						       ARG2 #xarg] !>,
                           LOCAL.CONT.HOOK.INDEX #index,
			   LOCAL.AGR.PNG #2,
                           LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun ] >,
    NON-LOCAL.SLASH <! !>].
;; ...>
|#


; synsems for verbs with objects undergoing path-movement

;,
;                              LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun

trans-arg1-2dir-synsem := trans-arg1-2-synsem-sup &
    [ LOCAL.CAT.HEAD non-copula,
      LOCAL.CONT.HOOK dir-hook,
      LOCAL.CONT.HOOK.DIRARG #1,
      LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.ROLE non-initiator,
			      LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			      LOCAL.BINDING.LEX-TAME - ] >,
      LKEYS.KEYREL.ARG2 #1 ].

; synsems for trans verbs with subjects undergoing path-movement, like
; in "ta tog til...". "ta stien mot..."

; "se" is classified as this, and it obviously doesn't go with 'dirnoun' subjects, hence the outcomment.
trans-arg1dir-2-synsem := trans-arg1-2-synsem-sup &
    [ LOCAL.CAT.HEAD non-copula,
      LOCAL.CONT.HOOK dir-hook,
      LOCAL.CONT.HOOK.DIRARG #1,
;      LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
      LKEYS.KEYREL.ARG1 #1,
 ;     LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
 ;                           LOCAL.CAT.HEAD.KEYS.KEY dirnoun] >,
      LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.ROLE non-initiator,
			     LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			     LOCAL.BINDING [ BOUND bool ]] >].

    
trans-arg1dir-2refl-synsem := trans-arg1-2-synsem-sup &
    [ LOCAL.CAT.HEAD non-copula,
      LOCAL.CONT.HOOK dir-hook,
      LOCAL.CONT.HOOK.DIRARG #1,
      LOCAL.CONT.HOOK.XARG #xarg,
      LKEYS.KEYREL.ARG1 #1,
      LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #2 ]>,
      LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.ROLE non-initiator,
			     LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
			     LEX +,
			     LOCAL.CAN-MAL-DROP +, ; for reflexive object - for mal-gram uses!
			     LOCAL.CONT.RELS <! [], [], [ARG1 #index,
						       ARG2 #xarg] !>,
			     LOCAL.CONT.HOOK.INDEX #index,
			     LOCAL.AGR.PNG #2,
			     LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun] >,
      LOCAL.CAN-PASSIVIZE -].

; "basere rapporten p√• Ola", "fortelle tull om meg"
trans-obl-synsem-sup := arg1-subj-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook & [ VARG #vrg],
    LOCAL.CAT trans-with-1icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head ]>, ;nominal
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [SELECTED +,
                                                        KEYS.KEY #1]]>, ; & index-sita]]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #4 & handle,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.VARG #vrg,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #4 ]].

trans-obl-eventarg1-eventobl-synsem-sup := eventarg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook & [ VARG #vrg],
    LOCAL.CAT trans-with-1icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head ]>, ;nominal
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [SELECTED +,
                                                        KEYS.KEY #1]]>, ; & index-sita]]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #4 & handle,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.VARG #vrg,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #4 ]].

; to exclude 'non-tamed' reflexive in 'alliere seg med'
trans-nonrefl-obl-synsem := trans-obl-synsem-sup & 
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			    LOCAL.BINDING nontamed ] >].

trans-obl-n-synsem := trans-nonrefl-obl-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD nom,
                                                      CONT.HOOK.INDEX ref-ind & [ROLE non-initiator]] ].

trans-obl-decl-synsem := trans-nonrefl-obl-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]   ].

trans-obl-interr-synsem := trans-nonrefl-obl-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]  ].


trans-obl-absinf-synsem := trans-nonrefl-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL + ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
					   KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]   ].

;TODO incoherent semantics ("foresl√• at vi g√•r icomps for Ola"
; ekvivalere N med N goes fine
;trans-obl-n-synsem & 
v-trObl-obDECL_oblN-synsem := trans-obl-synsem-sup & 
  [LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD fin-comp,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    LOCAL.CAT.VAL.ICOMPS <  #obl & [LOCAL.CAT.HEAD [KEYS.KEY #1 ,
						    SELECTED +]]>,
    LOCAL.CAT.QVAL.OBL1 #obl & [LOCAL.CONT.HOOK.LTOP #4 & handle],
   LOCAL.KEY-SPEC #1,
    LKEYS.KEYREL arg12obl-rel & [ ARG2 #2,
				 ARGOBLQ #4 ],
   LOCAL.CONT.HCONS <!  !> ].

;trans-obl-synsem-sup &
v-trObl-obAbsinf_oblN-synsem := lex-synsem & 
  [LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD nominal,
						     CONT.HOOK.INDEX #1],
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARGOBLQ #1 ].

v-trObl-obINTERR_oblN-synsem := trans-obl-synsem-sup & 
  [LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL -,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD  [TRANSPAR -,
					   MAIN-CL -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
			  LOCAL.CONT.HOOK.INDEX.SF ques] >,
   LKEYS.KEYREL.ARG2 #2 ].

v-trObl-obAbsinf_oblAbsinf-synsem := lex-synsem & 
  [LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
							     CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL + ]]],
    LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CONT.HOOK.LTOP #1 & handle],
    LKEYS.KEYREL arg12obl-rel & [ ARG2 #2,
				  ARGOBLQ #1] ].

v-trObl-obEqSuInf_oblEqSuInf-synsem := lex-synsem & 
  [LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #10 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.XARG #10,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
							     CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL + ]]],
   LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CONT.HOOK.LTOP #1 & handle,
			       LOCAL.CONT.HOOK.XARG #10],
   LKEYS.KEYREL arg12obl-rel & [ ARG2 #2,
				 ARGOBLQ #1] ].

v-trObl-oblEqSuInf-synsem := lex-synsem & 
  [LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #10 ] >,
   LOCAL.CAT.VAL.COMPS < [] >,
   LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
							     CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL + ]]],
   LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CONT.HOOK.LTOP #1 & handle,
			       LOCAL.CONT.HOOK.XARG #10],
   LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1] ].

trans-refl-obl-synsem-sup := trans-obl-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.CAN-MAL-DROP +, ; for reflexive object - for mal-gram uses!
			   LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2] >].
;                           NON-LOCAL.SLASH <! !> ] >].

trans-refl-obl-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD nom,
                                                      CONT.HOOK.INDEX ref-ind] ].

trans-refl-obl-decl-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse,
                                           KEYS.KEY #2 ]]>,
    LOCAL.KEY-SPEC #2,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]  ].

trans-refl-obl-interr-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]  ].

trans-refl-obl-absinf-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL + ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]   ].




trans-obladv-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.INDEX #1,
    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX #2,
			  LOCAL.CAT.HEAD nominal], ;; MHS 090813 Added to block certain unwanted bare infinite structures from arising in sentences such as 'han oppf√∏rer seg pent'. 
			 [LOCAL.CAT.HEAD a,
                          LOCAL.CONT.HOOK.XARG #1]>].

trans-obladv-synsem := trans-obladv-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			    LOCAL.BINDING nontamed ], [] >].

trans-refl-obladv-synsem := trans-obladv-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CAN-MAL-DROP +, ; for reflexive object - for mal-gram uses!
			   LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2 ], [] >]. 
 
trans-2obl-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook & [ VARG #vrg],
    LOCAL.CAT trans-with-2icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD nominal ]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY #1 & index-sita],
			   LOCAL.CONT.HOOK.LTOP #4 & handle,
			   LOCAL.CONT.HOOK.VARG #vrg],
                          [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY #2],
			   LOCAL.CONT.HOOK.LTOP #5 & handle]>,
    LOCAL.KEY-SPEC #1,
    LOCAL.ALT-SPEC #2,
    LKEYS.KEYREL arg12obl2-rel & [ ARGOBLQ #4,
				   ARGOBLQ2 #5 ]].

trans-2obl-synsem := trans-2obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

trans-2obl-refl-synsem := trans-2obl-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
			   LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
					   REFL-I +,
					   REFL-II -,
					   LEX-TAME + ],
			   LOCAL.CAN-MAL-DROP +, 
			   LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
			   LOCAL.AGR.PNG #2] > ].

trans-2obl-decl-synsem := trans-2obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >,
    LOCAL.CAT.QVAL.OBL2.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL2.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LKEYS.KEYREL arg12obl2-rel & [ ARGOBLQ2 #1 ] ].

trans-2obl-absinf-synsem := trans-2obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >,
    LOCAL.CAT.QVAL.OBL2.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL + ]],
    LOCAL.CAT.QVAL.OBL2.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LKEYS.KEYREL arg12obl2-rel & [ ARGOBLQ2 #1 ] ].

trans-2obl-interr-synsem := trans-2obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >,
    LOCAL.CAT.QVAL.OBL2.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL2.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LKEYS.KEYREL arg12obl2-rel & [ ARGOBLQ2 #1 ] ].

trans-2obl-equi-synsem := trans-2obl-synsem-sup &
   [LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [EXPLETIVE bool],
                          LOCAL.CONT.HOOK.INDEX #4 ] >,
   LOCAL.CAT.VAL.ICOMPS <[],
			 [LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CONT.RELS.LIST.REST.REST.FIRST.ARG1 #4,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]]>,
   LKEYS.KEYREL.ARGOBLQ2 #2,
   LKEYS.KEYREL.ARG2 #4].


trans-locobl-synsem := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT trans-with-icomps-pp-cat,
    LOCAL.CONT.HOOK hook & [VARG #3],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD nom,
			   LOCAL.BINDING nontamed,
			   LOCAL.CONT.HOOK.INDEX #indx] >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1& index-sit],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial],
			   LOCAL.CONT.HOOK.LTOP #2 & handle,
			   LOCAL.CONT.HOOK.VARG #3,
			   LOCAL.CONT.HOOK.XARG #indx]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #2 ] ].
    
#|
LOCAL.CAT.VAL.ICOMPS < #4, ...>,
    LOCAL.CAT.QVAL [ OBL1 #4 & [ LOCAL.CAT [ HEAD prep-or-adv,
					     VAL.COMPS null ] ] ],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel,
    LOCAL.CAT.VAL.COMPS <[]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>].
|#

trans-refl-locobl-synsem := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS < #4, ...>,
    LOCAL.CAT trans-with-icomps-pp-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.QVAL with-obl-pp-qval & [ OBL1 #4 & [ LOCAL.CAT [ HEAD prep-or-adv,
								VAL.COMPS null ] ] ],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #3,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD nom,
			   LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.CAN-MAL-DROP +, ; for reflexive object - for mal-gram uses!
			   LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #3 ] >,
                           LOCAL.AGR.PNG #2,
			   LOCAL.CONT.HOOK.INDEX #indx,
                           NON-LOCAL.SLASH <! !> ] >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
			   LOCAL.CONT.HOOK.LTOP #20 & handle,
			   LOCAL.CONT.HOOK.XARG #indx,
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #20 ]].

; this type needs a way of selecting directional adv and prep: they
; have a SORT specification in common
; these verbs have hook, not dir-hook...
trans-dir-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4 ] >,
    LOCAL.CAT.VAL.COMPS <[],
			 [LOCAL.CONT.HOOK.LTOP #ltop,
			  LOCAL.CONT.HOOK.XARG #4,
			  LOCAL.CAT.HEAD prep-or-adv,
			  LOCAL.CAT.HEAD.KEYS.KEY dir,
                          LOCAL.CONT.HOOK.INDEX.SORT path-related-motion] >,
    LKEYS.KEYREL.ARGX #ltop].

trans-dir-synsem := trans-dir-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], 
			  [] >].

trans-refl-dir-synsem := trans-dir-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
			    LOCAL.CAT.HEAD pers-pron, 
			    LOCAL.AGR.PNG #2,
			    LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >  ], 
			  [] >].




; "love meg √• komme"
subj-equi-doublobj-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #3,
                          LOCAL.BINDING.LEX-TAME -],
                         phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp,
                          LOCAL.CAT.HEAD.TRANSPAR +,
			  LOCAL.CAT.HEAD.MODALITY non-deontic,
                          LOCAL.CONT.HOOK.XARG #1,
;			  LOCAL.CONT.RELS.LIST.REST.FIRST.ARG2 #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #3].

; "love meg √• f√• komme"
subj-equi-switch-doublobj-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #3,
                          LOCAL.BINDING.LEX-TAME -],
                         phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp,
                          LOCAL.CAT.HEAD.TRANSPAR +,
			  LOCAL.CAT.HEAD.MODALITY faa-deontic,
                          LOCAL.CONT.HOOK.XARG #3,
			  LOCAL.CONT.RELS.LIST.REST.FIRST.ARG1 #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS < >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #3].


obj-equi-synsem-sup := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 ],
                         [LOCAL.CAT.HEAD.TRANSPAR +,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].

; "unne ham √• komme", "nekte ham √• komme"
obj-equi-synsem := obj-equi-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [LOCAL.CAT.HEAD infin-comp] >].

obj-equi-refl-synsem := obj-equi-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #xarg,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.AGR.PNG #2,
                            LOCAL.CONT.HOOK.INDEX #index,
			    LEX +,
			    LOCAL.CONT.RELS <! [], [], [ARG1 #index,
							ARG2 #xarg] !> ], 
			  [LOCAL.CAT.HEAD infin-comp] >,
    LOCAL.CAN-PASSIVIZE -].


; "be ham komme"
obj-equi-bare-synsem := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING nontamed,
			  LOCAL.CAT.HEAD.EXPLETIVE #expl,
			  LOCAL.CONT.HOOK.INDEX #1],
                         [LOCAL.CAT.HEAD verb-all,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                          LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].


; "f√• komme"
may-come-synsem := lex-synsem &
  [LOCAL.CAT.HEAD verb-aux & [KEYS.KEY auxvb],
   LOCAL.CAT.HEAD.MODALITY faa-deontic,
   LOCAL.CAT.VAL.SUBJ  < [LOCAL.CONT.HOOK.INDEX #1,
                          LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                          LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                          LOCAL.CONT.HOOK.XARG #1,
;			  LOCAL.CONT.RELS.LIST.FIRST.ARG2 #1,
                          LOCAL.CONT.HOOK.LTOP #2] >,
   LOCAL.CAT.VAL.ICOMPS <>,
;   LKEYS.KEYREL.PRED "_PERMIT-f√•_rel",
   LKEYS.KEYREL.ARG1 semarg,
   LKEYS.KEYREL.ARG2 #2,
   NON-LOCAL.SLASH <!!> ].


v-aux-faa := verb-general-lexeme &
  [ SYNSEM may-come-synsem ].


#|
; "be ham om √• komme"
obj-equi-pp-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head,
                          LOCAL.CONT.HOOK.INDEX #1 ],
                         [LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].
|#
; "be ham om √• komme"
; 
;			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE bool

obj-equi-pp-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [EXPLETIVE bool],
                          LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp, ; & [KEYS.KEY rais], ;to allow passive with head-pass-verb-icomp-phrase
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG2 #1].

obj-equi-pp-synsem := obj-equi-pp-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

#|
subj-equi-pp-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD np-head & [EXPLETIVE bool],
                          LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp, ; & [KEYS.KEY rais], ;to allow passive with head-pass-verb-icomp-phrase
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].
|#

subj-equi-obj-pp-synsem := subj-equi-pp-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].



obj-equi-pp-synsem-switch := arg1-subj-synsem & arg2-comps-synsem &
  [LOCAL.CAT.HEAD non-copula,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [EXPLETIVE bool],
                          LOCAL.CONT.HOOK.INDEX #4 ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
;                          LOCAL.CAT.HEAD.MODALITY faa-deontic, ; after deleting verb-or-comp-or-prep
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CONT.RELS.LIST.REST.REST.FIRST.ARG1 #4,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG2 #4].


obj-equi-pp-refl-synsem := obj-equi-pp-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2,
			    LEX +  ] >,
    LOCAL.CAN-PASSIVIZE -].


; "overlate til ham √• komme"
obl-equi-synsem := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                          LOCAL.CONT.HOOK.XARG #3 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
			  LOCAL.CONT.HOOK [XARG #1,
                                           LTOP #2,
                                           INDEX #3]] >,
   LKEYS.KEYREL.ARG2 #2].



; for "jeg ser ham komme", "jeg ser det sitte en gutt"
trans-secpred-rais-from-verbal-arg2-synsem-sup := arg2-predicative-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL [ CAT trans-ncomps-secpred-cat],
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl,
			   LOCAL.APPOSITION-COMPLEX -,
			   LOCAL.MUST-APP bool], ; was '+', lost acc-cum-inf 
                          [ LOCAL.CAT.HEAD verb-all & [IMPERATIVE -],
                            LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5,
							   LOCAL.CAT.HEAD.EXPLETIVE #expl] >,    
                            LOCAL.CONT.HOOK.INDEX.E.TENSE infin ]>,
   LOCAL.CAT.VAL.ICOMPS <>].



trans-secpred-rais-from-verbal-arg2-synsem := trans-secpred-rais-from-verbal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].


trans-secpred-rais-refl-from-verbal-arg2-synsem := trans-secpred-rais-from-verbal-arg2-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].


; for "jeg forutsetter ham √• komme", with pass: "han forutsettes √• komme"
trans-secpred-rais-from-infinmarked-arg2-synsem := arg2-predicative-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL [ CAT trans-ncomps-secpred-cat],
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #6 & semarg]>, 
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING nontamed,
                           LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl], 
                          [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
			    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #3,
                            LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] >]>,
    LKEYS.KEYREL [ARG1 #6,
                  ARG2 #3 ],
   LOCAL.CAT.VAL.ICOMPS <>].

; for "jeg forutsetter ham skutt", with pass: "han forutsettes skutt" -- Complex Passive
; "Ola blir fryktet fors√∏kt √• drepes" parses with this. One needs a common marker for passives and active verbs with 'resultative' semantics. TODO
trans-secpred-rais-from-perfmarked-arg2-synsem := arg2-predicative-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL [ CAT trans-ncomps-secpred-cat],
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #6 & semarg]>, 
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING nontamed,
                           LOCAL.CONT.HOOK.INDEX #5 & [ROLE non-initiator]], 
                          [ LOCAL.CAT.HEAD verb & [KEYS.KEY mainvb,
						   IMPERATIVE -],
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #3,
                            LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
                            LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] >]>,
    LKEYS.KEYREL [ARG1 #6,
                  ARG2 #3 ],
   LOCAL.CAT.VAL.ICOMPS <>].



;LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,

; "han synes meg √• komme", "han forekommer meg √• komme"
trans-secpred-rais-from-infinmarked-arg1-synsem := arg1-predicative-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg,
			    LOCAL.CAT.HEAD.EXPLETIVE #expl]>, 
                   COMPS < [LOCAL.CAT.HEAD nominal,
			    LOCAL.CONT.HOOK.INDEX #6 ],
                           [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +,
							  KEYS.KEY infinit-comp-eq],
                             LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                             LOCAL.CONT.HOOK.LTOP #3,
                             LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] > ]>],
    LKEYS.KEYREL [ARG1 #3,
                  ARG2 #6 ],
   LOCAL.CAT.VAL.ICOMPS <>].

;LOCAL.CAT.HEAD prep-or-adj,
                             ; "han synes meg syk", "han synes meg som gal"
trans-secpred-rais-from-adj-or-som-arg1-synsem := arg1-predicative-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [LOCAL.CONT.HOOK.INDEX #6,
                            LOCAL.BINDING.LEX-TAME -,
                            LOCAL.BINDING.REFL-I -],
                           [ LOCAL.CAT.HEAD prep-or-adj,
			     LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.DERIVED-HEAD -,
			     SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
                             LOCAL.CONT.HOOK.LTOP #3 ]>],
    LKEYS.KEYREL [ARG1 #3,
                  ARG2 #6 ],
   LOCAL.CAT.VAL.ICOMPS <>,
    NON-LOCAL.SLASH <!!> ].

; han synes meg en idiot
trans-secpred-rais-from-n-arg1-synsem := arg1-predicative-synsem & arg2-comps-synsem & lex-item-2rel &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [LOCAL.CONT.HOOK.INDEX #6,
                            LOCAL.BINDING.LEX-TAME -,
                            LOCAL.BINDING.REFL-I -],
                           [ LOCAL.CONT.HOOK.INDEX #7,
                             LOCAL.CONT.HOOK.LTOP #3 ]>],
     LOCAL.CONT.RELS <! [ARG1 #3,
			ARG2 #6 ], [LBL #3,
				    PRED "instantiate-rel",
				    ARG1 #5,
				    ARG2 #7 ] !>,
    LOCAL.CAT.VAL.ICOMPS <>,
    NON-LOCAL.SLASH <!!>].


trans-secpred-lexcause-pp-synsem-sup := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5], 
                          [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1]] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

trans-secpred-lexcause-pp-synsem := trans-secpred-lexcause-pp-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].
trans-secpred-refl-lexcause-pp-synsem := trans-secpred-lexcause-pp-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].

; for "jeg anser ham frisk", "...som frisk"
trans-secpred-rais-from-nonverbal-arg2-synsem-super := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD nominal], 
                          [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adj-or-adv] >, ;prep-or-adj; for-comp
    LOCAL.CAT.VAL.ICOMPS <> ].

; '-sup': a version designed for prep governing an infinitive, as in 'anse np for √•...'
#|
trans-secpred-rais-from-nonverbal-arg2-synsem-sup := trans-secpred-rais-from-nonverbal-arg2-synsem-super & 
  [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.EXPLETIVE #expl], 
			  [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.TRANSPAR +, 
			   LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
    LOCAL.CAT.QVAL.DOBJECT [LOCAL.CAT.HEAD.EXPLETIVE #expl], 
    LOCAL.CAT.QVAL.PREDIC [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.TRANSPAR +, 
			   LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] ].
|#
; trying to make the object be identical to the understood subject of the infi nitive, not just in index, but also in expletive +/- status
trans-secpred-rais-from-nonverbal-arg2-synsem-sup := trans-secpred-rais-from-nonverbal-arg2-synsem-super & 
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.QVAL.DOBJECT [LOCAL.CAT.HEAD.EXPLETIVE #expl], 
    LOCAL.CAT.QVAL.PREDIC [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.TRANSPAR +, 
			   LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] ].

; '-sap': a version designed for prep governing an np, as in 'anse np for/som np...', or som governing adj
trans-secpred-rais-from-nonverbal-arg2-synsem-sap := trans-secpred-rais-from-nonverbal-arg2-synsem-super.

; REFL
;trans-secpred-rais-from-nonverbal-arg2-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sup &
;  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

trans-secpred-rais-from-nonverbal-arg2-inf-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].

;; "f√∏le seg frisk", anse seg ferdig,... som ferdig
trans-secpred-rais-refl-from-nonverbal-arg2-inf-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD pers-pron, ;; MHS 090813 Added to prevent unwanted bare finite structures form arising in certain kinds of sentences.
	                    LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2], [] >]. ; LOCAL.CAT.HEAD infin-comp - conflict with parents

trans-secpred-rais-from-nonverbal-arg2-plain-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sap &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].

;; "f√∏le seg frisk", anse seg ferdig,... som ferdig
trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sap &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD pers-pron, ;; MHS 090813 Added to prevent unwanted bare finite structures from arising in sentences such as 'han anser seg (som/til/for) syk' og 'hun viser seg som olas venn'.
	                    LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].



; for "jeg kaller ham en venn"
trans-secpred-rais-from-nominal-arg2-synsem-sup := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1, 
			   LOCAL.CAT.HEAD nominal], ;; MHS 090813 Added to block certain unwanted bare infinite structures from arising in sentences such as 'hun kaller seg en venn, 
                          [ LOCAL.CONT.HOOK.INDEX #5,
                            LOCAL.CAT.HEAD np-head] >,
    LOCAL.CAT.VAL.ICOMPS <>,  
    LOCAL.CONT.RELS <! [ARG2 #3], [ LBL #3,
				    PRED "_instantiate_c_rel",
				    ARG1 #1,
				    ARG2 #5 ] !> ].

trans-secpred-rais-from-nominal-arg2-synsem := trans-secpred-rais-from-nominal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.REFL-I - ], [] >].

;; "kalle seg en venn"
trans-secpred-rais-refl-from-nominal-arg2-synsem := trans-secpred-rais-from-nominal-arg2-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].


; for "jeg synger ham frisk", "jeg synger det fint" (expl "det")
; the restriction 'DEF +' is to prevent this entry from being a licenser of
; "det l√∏per en gutt mot skogen" (yields multiple parses)
trans-secpred-arg1-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE -] >,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing],
                           LOCAL.CAT.HEAD.DEF bool ], ;+
                          [ LOCAL.CAT.HEAD [ KEYS.KEY #1],
			    LOCAL.CONT.HOOK.XARG #5 ] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #5 ].

; Blind alley 27202020
#|
trans-particle-arg1-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT trans-ncomps-secpred-invert-cat,
    LOCAL.CAT.VAL.COMPS < #pred, #obj >,
    LOCAL.CAT.QVAL.DOBJECT #obj & [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing],
                           LOCAL.CAT.HEAD.DEF + ], 
    LOCAL.CAT.QVAL.PREDIC #pred & [ LOCAL.CAT.HEAD [ KEYS.KEY #1],
			    LOCAL.CONT.HOOK.XARG #5 ] ,
    LOCAL.CAT.VAL.ICOMPS <> ].
|#

;LH may7-11
trans-secpred-shift-arg1-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
;    LOCAL.CAT trans-ncomps-secpred-invert-cat, ; LH27102020
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep-or-adv,
			    LOCAL.CONT.HOOK.LTOP #2,
			    LOCAL.DERIVED-HEAD - ],
			  [ ] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARGX #2 ].

#|
trans-secpred-shift-arg1-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
;    LOCAL.CAT.QVAL.PREDIC #pred,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
			    LOCAL.CONT.HOOK.LTOP #2 ],
			  [ LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARGX #2 ].
|#

; REFL
;trans-secpred-arg1-x-synsem := trans-secpred-arg1-x-synsem-sup &
;  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].


trans-secpred-arg1-x-synsem := trans-secpred-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE -] >,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.REFL-I - ], [] >].

;LH may7-11
trans-secpred-shift-arg1-x-synsem := trans-secpred-shift-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.BINDING.REFL-I - ] >].

trans-secpred-arg1-x-refl-synsem := trans-secpred-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2,
			    LEX +  ], 
			  [] >,
    LOCAL.CAN-PASSIVIZE -,
    NON-LOCAL.SLASH <! !> ].

#|
trans-secpred-arg1-x-refl-synsem := trans-secpred-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.CONT.HOOK.INDEX #4,
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >,
    NON-LOCAL.SLASH <! !> ].
|#

; for "jeg sparker ballen flat", "jeg sparker det fint" (expl "det")
; to subtype, a very general one: LOCAL.CAT.HEAD prep-or-adj-or-adv & [SELECTED -],
;                            
trans-secpred-arg1-2-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.CAT.HEAD nominal], 
                          [ LOCAL.CONT.HOOK.XARG #5,
 ;                          LOCAL.CAT.HEAD adj, ;see lex-types-v how the verb-lexeme stage of this type is used further
			    LOCAL.CAT.HEAD.KEYS.KEY #1,
                            LOCAL.CONT.HOOK.INDEX ad-event ] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.KEY-SPEC #1 ].

;particle-shift-rule gives opposite order
trans-secpred-arg1-2decl-x-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
			    LOCAL.CAT.HEAD.DECL +,
			    LOCAL.CAT.HEAD.INV -,
			    LOCAL.CAT.HEAD fin-comp,
			    LOCAL.CAT.HEAD.IMPERATIVE -,
			    LOCAL.CONT.HOOK.LTOP #2 & semarg,
			    LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
			    LOCAL.BINDING.REFL-I - ], 
			  [ LOCAL.CONT.HOOK.XARG #5,
			    LOCAL.CAT.HEAD.KEYS.KEY #1,
                            LOCAL.CONT.HOOK.INDEX ad-event ] >,
    LKEYS.KEYREL.ARG2 #2,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.KEY-SPEC #1 ].

;particle-shift-rule gives opposite order
trans-secpred-arg1-2interr-x-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
			    LOCAL.CAT.HEAD.DECL -,
			    LOCAL.CAT.HEAD.INV -,
			    LOCAL.CAT.HEAD verb-or-comp,
			    LOCAL.CAT.HEAD.IMPERATIVE -,
			    LOCAL.CONT.HOOK.LTOP #2 & semarg,
			    LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
			    LOCAL.BINDING.REFL-I - ], 
			  [ LOCAL.CONT.HOOK.XARG #5,
			    LOCAL.CAT.HEAD.KEYS.KEY #1,
                            LOCAL.CONT.HOOK.INDEX ad-event ] >,
    LKEYS.KEYREL.ARG2 #2,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.KEY-SPEC #1 ].

;REFL
;trans-secpred-arg1-2-x-synsem := trans-secpred-arg1-2-x-synsem-sup &
;  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].
trans-secpred-arg1-2-x-synsem := trans-secpred-arg1-2-x-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.REFL-I - ], 
			  [] >].

trans-secpred-arg1-2-x-refl-synsem := trans-secpred-arg1-2-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2,
			    LEX + ], 
			  [] >,
    LOCAL.CAN-PASSIVIZE -].

; for the moment feeds into two rules: head-verb-adverb-comp-phrase and head-verb-particleshift-comp-phrase. The former is a bit too inclusive, but cannot be restricted, or we lose "f√• Ola tilbake" (Aug19-06)
; for "jeg sparker ut ballen"
trans-particleshift-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adv-reg & [KEYS.KEY dir]], 
                          [LOCAL.CONT.HOOK.INDEX #5,
                            LOCAL.CAT.HEAD np-head] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    NON-LOCAL.SLASH <!!> ]. ;extraction not distinguishable from extr from non-shifted - and has curious consequences

; LH 280411
trans-particleshift-non-dir-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl]], 
                          [LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.KEY-SPEC #6,
    LOCAL.CAT.VAL.ICOMPS <> ].


; LH 060511
; regne ut at/om/hvem
trans-particleshift-eventobj-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl]], 
                          [ LOCAL.CONT.HOOK.LTOP #5,
                            LOCAL.CAT.HEAD heady,
			    LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    LOCAL.KEY-SPEC #6,
    LOCAL.CAT.VAL.ICOMPS <> ].

;;;;
; for "overlate til Ola √• ..."


; for "overlate til Ola √• ..." - the narrative with 'obl' in the title here conceals treatment as ditransitive
trans-obl-inf-synsem := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
   LOCAL.CONT.HOOK hook,
    LOCAL.CAT ditrans-empty-icomps-pp-cat,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD prep & [SELECTED +,
						 KEYS.KEY #3 & selct],
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1],
                         [LOCAL.CAT.HEAD.TRANSPAR +,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.HEAD infin-comp] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.KEY-SPEC #3,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].


;                          LOCAL.CONT.HOOK.XARG #1,
;                          LOCAL.CONT.HOOK.LTOP #2,
;			  LOCAL.CONT.HOOK.INDEX #1 ],

;;;;

; for "han tar p√• seg skoene"
trans-ppshift-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY #key & index-sit],
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BND-MOUNTABLE  < [ ANAPH-INDX #1,
                                                                            ANAPH-TYPE #20] >,
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING #20 & [ BOUND +,
                                                                         REFL-I +,
                                                                         REFL-II -,
                                                                         LEX-TAME + ]], 
                          [ LOCAL.CAT.HEAD np-head,
                            LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.ICOMPS <> ].

; LOCAL.CAT.HEAD [KEYS.KEY #key & index-sit]]
trans-ppshift-nonrefl-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adv,
                            LOCAL.CAT.HEAD [KEYS.KEY #key]],
                            [ LOCAL.CAT.HEAD nominal-or-connect-n,
                            LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

trans-ppshift-decl-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #4,
    LKEYS.KEYREL.ARGX #ltop,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAN-CMB-FIXPT -,
    LOCAL.CAN-CMB-NONFIXPT-DIR -,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
			    LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adv,
                            LOCAL.CAT.HEAD [KEYS.KEY #key]],
                            [ LOCAL.CAT.HEAD.INV -,
			      LOCAL.CAT.HEAD verb-or-comp & [DECL +],
			      LOCAL.CAT.HEAD verb-or-comp, ;fin-comp,
			      LOCAL.CONT.HOOK.LTOP #4,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

;spandere p√• seg at det blir fest
trans-ppshift-with-refl-decl-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #4,
    LKEYS.KEYREL.ARGX #ltop,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAN-CMB-FIXPT -,
    LOCAL.CAN-CMB-NONFIXPT-DIR -,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind & #1,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
			    LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adv,
                            LOCAL.CAT.HEAD [KEYS.KEY #key],
			    LOCAL.CAT.QVAL.DOBJECT.LOCAL.BND-RESP < [ ANAPH-INDX #1 ] >,
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING[ BOUND +,
                                                                  REFL-I +,
                                                                  REFL-II -,
                                                                  LEX-TAME +]],
                            [ LOCAL.CAT.HEAD.INV -,
			      LOCAL.CAT.HEAD verb-or-comp & [DECL +],
			      LOCAL.CAT.HEAD verb-or-comp, ;fin-comp,
			      LOCAL.CONT.HOOK.LTOP #4,
			      LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.ICOMPS <> ].

;spandere p√• seg √• kj√∏pe kaffe
trans-ppshift-with-refl-equi-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #4,
    LKEYS.KEYREL.ARGX #ltop,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAN-CMB-FIXPT -,
    LOCAL.CAN-CMB-NONFIXPT-DIR -,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind & #1,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
			    LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adv,
                            LOCAL.CAT.HEAD [KEYS.KEY #key],
			    LOCAL.CAT.QVAL.DOBJECT.LOCAL.BND-RESP < [ ANAPH-INDX #1 ] >,
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING[ BOUND +,
                                                                  REFL-I +,
                                                                  REFL-II -,
                                                                  LEX-TAME +]],
                            [ LOCAL.CAT.HEAD.INV -,
			      LOCAL.CAT.HEAD verb-or-comp & [DECL +,
							     TRANSPAR +],
			      LOCAL.CONT.HOOK.XARG #1,
			      LOCAL.CONT.HOOK.LTOP #4,
			      LOCAL.CONT.HOOK.INDEX.E.TENSE non-finite] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

trans-ppshift-interr-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #4,
    LKEYS.KEYREL.ARGX #ltop,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAN-CMB-FIXPT -,
    LOCAL.CAN-CMB-NONFIXPT-DIR -,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
			    LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adv,
                            LOCAL.CAT.HEAD [KEYS.KEY #key]],
                            [ LOCAL.CAT.HEAD.INV -,
			      LOCAL.CAT.HEAD verb-or-comp & [DECL -], 
			      LOCAL.CONT.HOOK.LTOP #4,
			      LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

; for "han kler p√• gutten"
trans-ppshift-implicit-synsem := argx-predicative-synsem & arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LKEYS.KEYREL.ARG2 #5,
    LKEYS.KEYREL.ARGX #6,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #6,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY index-sit] ]>,
    LOCAL.CAT.VAL.ICOMPS <> ].

; for "han kler p√• seg"
trans-ppshift-refl-implicit-synsem := argx-predicative-synsem & arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
    LKEYS.KEYREL.ARG2 #5,
    LKEYS.KEYREL.ARGX #6,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #6,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY index-sit,
                                            SELECTED +],
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BND-RESP < [ ANAPH-INDX #1 ] >,
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING[ BOUND +,
                                                                  REFL-I +,
                                                                  REFL-II -,
                                                                  LEX-TAME + ]] >,
    LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.ICOMPS <> ].


trans-adjshift-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adj & [KEYS.KEY propt]], 
                          [LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].


; "se/tro at han kommer"
trans-subord-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD fin-comp,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT trans-cat,
   LKEYS.KEYREL.ARG2 #2 ].

trans-barefinite-subord-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.VAL [SUBJ olist,
					 SPR <>,
					 COMPS <>,
					 ICOMPS <>,
					 SPR <>],
                          LOCAL.CAT.HEAD verb-all,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.INDEX.SF prop,
			  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT trans-cat,
   LKEYS.KEYREL.ARG2 #2 ].

trans-absinfsubord-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
			  LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
;			  LKEYS.KEYREL.ARG2 #8,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT trans-cat,
   LKEYS.KEYREL.ARG2 #2].

trans-arg1absinf-absinfsubord-synsem := eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.HEAD.INV -,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.DECL +,
;			  LKEYS.KEYREL.ARG2 #8,
                          LOCAL.CONT.HOOK.LTOP #1 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
;			  LKEYS.KEYREL.ARG2 #8,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT trans-cat,
   LKEYS.KEYREL.ARG2 #1,
   LKEYS.KEYREL.ARG2 #2].



#|
,
    LOCAL.CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				 ARG0 #8,
				 RSTR #15 ], pron_rel & [ PRED "_understood-agent_rel",
							 LBL #16,
							 ARG0 #8 ] !>,
    LOCAL.CONT.HCONS <! [ HARG #15,
			     LARG #16] !>].
|#

; muliggj√∏re det √• komme
;LH may8-11
;				 CONT.HOOK.INDEX expl-ind ]]
trans-subord-expn-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL[ CAT.HEAD expl-pron,
				 CONT.HOOK.INDEX ref-ind ]],
			 [LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
			  LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LOCAL.CAT.VAL.ICOMPS <>,
  LKEYS.KEYREL.ARG2 #2 ].

trans-particle-subord-expn-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CONT.HOOK.VARG #5,
   LOCAL.CAT.VAL.COMPS < [LOCAL[ CAT.HEAD expl-pron,
				 CONT.HOOK.INDEX ref-ind ]],
			 [LOCAL.CONT.HOOK.XARG #5,
			  LOCAL.CONT.HOOK.INDEX ad-event,
			  LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl]], 
			 [LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
			  LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LOCAL.KEY-SPEC #6,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

trans-secpred-subord-expn-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL[ CAT.HEAD expl-pron,
				 CONT.HOOK.INDEX ref-ind ]],
			 [LOCAL.CONT.HOOK.XARG #5], 
			 [LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
			  LOCAL.CONT.HOOK.INDEX #5,
			  LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].


; overlate det til Ola √• komme
trans-obl-subord-expn-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL[ CAT.HEAD expl-pron,
				 CONT.HOOK.INDEX ref-ind ]],
			 [LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
			  LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LOCAL.CAT.VAL.ICOMPS <[]>,
   LKEYS.KEYREL.ARG2 #2 ].


;if subclassification needed, the these, pls the conditional
#|
trans-subord-expn-decl-synsem := trans-subord-expn-synsem &
 [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.DECL +,
			     LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >].
trans-subord-expn-inf-synsem := trans-subord-expn-synsem &
 [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD infin-comp] >].
|#

;muliggjorde (for ham) √• komme

; these combine not only with comp-headed clauses, but also with
; V-headed, as in "vite hva han spiser" - therefore not subtype
; of trans-subord-synsem
; "vite/se hva/hvorvidt han spiser"

trans-indirwhquest-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -,
						     IMPERATIVE -,
						     MAIN-CL -,
						     INV -],
			  LOCAL.CONT.HOOK.LTOP #2,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
;                          LOCAL.CONT.HOOK.INDEX.WH +,
			  LOCAL.CONT.HOOK.INDEX.SF ques] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].


trans-indir-y-n-quest-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp & [DECL -,
						     IMPERATIVE -,
						     INV -,
						     MAIN-CL -,
					  WH-COMPLETE +],
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
			  LOCAL.CONT.HOOK.INDEX.SF ques,
                          LOCAL.CONT.HOOK.INDEX event-verb & [E.TENSE finite]] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

; a neutral version of the above, since lots of verbs are defined for a neutral version:
trans-indir-interr-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD [DECL -,
					  IMPERATIVE -,
					  INV -,
					  MAIN-CL -,
					  WH-COMPLETE bool],;from '+' - lost 'vet hva han liker'
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX [E.TENSE finite]] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].


trans-indir-sudecl-obinterr-synsem := trans-eventarg1-eventarg2-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [DECL +,
						     IMPERATIVE - ]] >,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD [DECL -,
					  IMPERATIVE -,
					  INV -,
					  MAIN-CL -,
					  WH-COMPLETE bool],
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX [E.TENSE finite]] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].



trans-eventarg1-synsem := trans-synsem & eventarg1-subj-synsem & arg2-comps-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>]].

trans-eventarg1-decl-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [DECL +,
						     IMPERATIVE - ]] >,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD np-head ] > ].

trans-eventarg1-interr-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] >,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD np-head,
			    LOCAL.CONT.HOOK.INDEX ref-ind ] > ].

trans-eventarg1-absinf-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
							 DECL + ]] > ].

trans-eventarg1-equi-contr-by-obj-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
							 DECL + ],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LKEYS.KEYREL.ARG1 #2 ].

trans-obl-eventarg1-equi-contr-by-obj-obl-contr-by-obj-synsem := trans-obl-eventarg1-eventobl-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
							 DECL + ],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp, 
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #4,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]]>,
    LKEYS.KEYREL.ARGOBLQ #4,  
    LKEYS.KEYREL.ARG1 #2 ].

trans-eventarg1-obl-synsem := eventarg1-subj-synsem & arg2-comps-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]>]].
trans-eventarg1-decl-obl-synsem := trans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1-interr-obl-synsem := trans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

;at p ansporer ham til √• ...
trans-eventarg1-decl-obl-equi-synsem := trans-eventarg1-decl-obl-synsem &
  [LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [EXPLETIVE bool],
                          LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp, 
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG2 #1].






trans-eventarg1-eventobl-synsem := trans-eventarg1-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]> ].

trans-eventarg1-eventobl-decl-synsem := trans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL + ]].
trans-eventarg1-eventobl-interr-synsem := trans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL - ]].

trans-eventarg1decl-eventobldecl-synsem := trans-eventarg1-decl-obl-synsem & trans-eventarg1-eventobl-decl-synsem.
trans-eventarg1decl-eventoblinterr-synsem := trans-eventarg1-decl-obl-synsem & trans-eventarg1-eventobl-interr-synsem.
trans-eventarg1interr-eventobldecl-synsem := trans-eventarg1-interr-obl-synsem & trans-eventarg1-eventobl-decl-synsem.
trans-eventarg1interr-eventoblinterr-synsem := trans-eventarg1-interr-obl-synsem & trans-eventarg1-eventobl-interr-synsem.




trans-eventarg1-eventarg2-synsem := trans-synsem & eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT trans-cat,
   LKEYS.KEYREL.ARG2 #2 ].

trans-eventarg1-eventarg2nonfin-synsem := trans-synsem & eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE tense] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT trans-cat,
   LKEYS.KEYREL.ARG2 #2 ].
 
trans-eventarg1decl-eventarg2-synsem := trans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1interr-eventarg2-synsem := trans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].
trans-eventarg1decl-eventarg2decl-synsem := trans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1decl-eventarg2interr-synsem := trans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL - ] > ].
trans-eventarg1interr-eventarg2decl-synsem := trans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1interr-eventarg2interr-synsem := trans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL - ] > ].

trans-eventarg1absinf-eventarg2absinf-synsem := trans-eventarg1-eventarg2nonfin-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -]] >,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -]] > ].

ditrans-eventarg1-synsem := ditrans-synsem & eventarg1-subj-synsem & arg23-comps-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>]].

ditrans-eventarg1-declar-synsem := ditrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD [DECL +]] > ].

;ditrans-eventarg1-declar-synsem := ditrans-eventarg1-synsem &
;  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].

ditrans-eventarg1-decl-synsem := ditrans-eventarg1-declar-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp ] > ].

ditrans-eventarg1-absinf-synsem := ditrans-eventarg1-declar-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -]] > ].

ditrans-eventarg1-interr-synsem := ditrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

;ditrans-eventarg1-absinf-synsem := ditrans-eventarg1-synsem &
;  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp ] > ].

ditrans-eventarg1-eventarg2-synsem := eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL [ CONT.HOOK.VARG #2],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1,
			  LOCAL.CONT.HOOK.INDEX.SORT anim-thing ],
			  [LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT ditrans-cat,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1 ].

ditrans-eventarg1decl-eventarg2-synsem := ditrans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].
ditrans-eventarg1interr-eventarg2-synsem := ditrans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].
ditrans-eventarg1decl-eventarg2decl-synsem := ditrans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL + ] > ].
ditrans-eventarg1decl-eventarg2interr-synsem := ditrans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL - ] > ].
ditrans-eventarg1interr-eventarg2decl-synsem := ditrans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL + ] > ].
ditrans-eventarg1interr-eventarg2interr-synsem := ditrans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL - ] > ].



ditrans-arg1-2-3-synsem-sup := ditrans-synsem & arg1-subj-synsem & arg23-comps-synsem &
  [ LOCAL [ CONT.HOOK.VARG #2],
    LKEYS.KEYREL.ARG2 #2,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.SPEC-TO-BARE-N -,
			   LOCAL.CARD-TO-BARE-N - ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.SPEC-TO-BARE-N -, ; LOCAL.CONT.HOOK.INDEX.SORT anim-thing, - naive, this can be done only once all 60,000 nouns are classified appropriately			   
			   LOCAL.CARD-TO-BARE-N -,
			   LOCAL.MUST-APP bool,; both were '+', for forgotten reason
			   LOCAL.APPOSITION-COMPLEX - ], 
			  [LOCAL.MUST-APP bool,
			   LOCAL.APPOSITION-COMPLEX -] >  ].

ditrans-arg1-2-3-synsem := ditrans-arg1-2-3-synsem-sup & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING.LEX-TAME - ], [] > ].

ditrans-arg1-2-3refl-synsem := ditrans-arg1-2-3-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-RESP < bindee & [ ANAPH-INDX #1 ] >,
			   LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2,
			   LEX + ], 
			  [] >,
    LOCAL.CAN-PASSIVIZE -].


; "vise meg at han kommer"
;,
;                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite
; removed in order to also allow infinitives. TODO: it misses the equi-effect, which is probably there, so this is a temporary hack
ditrans-subord-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nom,
                           LOCAL.CONT.HOOK.INDEX #1],
                         phr-synsem &
                         [LOCAL.CAT.HEAD glob-comp,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1 ].

ditrans-nonrefl-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

; forestille seg at
ditrans-refl-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], 
			  [LOCAL.CAT.HEAD.DECL +] >].

ditrans-decl-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD fin-comp,
			       LOCAL.CAT.HEAD.DECL +] >].

ditrans-equiinf-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4 ] >,
    LOCAL.CAT.VAL.COMPS < [], [LOCAL.CONT.HOOK.XARG #4,
			       LOCAL.CAT.HEAD.DECL +,
			       LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]] >].

ditrans-decl-synsem := ditrans-nonrefl-subord-synsem & ditrans-decl-subord-synsem  & no-icomps-synsem. ;; MHS 090713 no-icomps-synsem added.

ditrans-equiinf-synsem := ditrans-nonrefl-subord-synsem & ditrans-equiinf-subord-synsem. 

ditrans-refl-decl-synsem := ditrans-refl-subord-synsem & ditrans-decl-subord-synsem. 

ditrans-refl-equiinf-synsem := ditrans-refl-subord-synsem & ditrans-equiinf-subord-synsem. 
 

no-icomps-synsem := synsem & 
[ LOCAL.CAT.VAL.ICOMPS < > ].

; these combine not only with comp-headed clauses, but also with
; V-headed, as in "vite hva han spiser" - therefore not subtype
; of trans-subord-synsem
; "sp√∏rre meg hva/hvorvidt han spiser"

;; MHS 090713 no-icomps-synsem added.
;no-icomps-synsem &
ditrans-indirwhquest-synsem-sup := arg1-subj-synsem & no-icomps-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nom,
                           LOCAL.CONT.HOOK.INDEX #1],
                         [LOCAL.CAT.HEAD.DECL -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
			  LOCAL.CONT.HOOK.INDEX.SF ques] >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1 ].

ditrans-y-n-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD fin-comp] >].

ditrans-wh-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD verb-all] >].

ditrans-nonrefl-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

;LH may8-11
; undre seg hvorvidt
;ditrans-refl-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup.
#|
LH180718
 &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].
|#

ditrans-refl-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].

ditrans-y-n-refl-indirwhquest-synsem := ditrans-y-n-indirwhquest-synsem & ditrans-refl-indirwhquest-synsem.
ditrans-y-n-nonrefl-indirwhquest-synsem := ditrans-y-n-indirwhquest-synsem & ditrans-nonrefl-indirwhquest-synsem.
ditrans-wh-refl-indirwhquest-synsem := ditrans-wh-indirwhquest-synsem & ditrans-refl-indirwhquest-synsem.
ditrans-wh-nonrefl-indirwhquest-synsem := ditrans-wh-indirwhquest-synsem & ditrans-nonrefl-indirwhquest-synsem. 

v-ditr-obINTERR-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.DECL -,
			       LOCAL.CONT.HOOK.INDEX.SF ques] >].

v-ditr-iobRefl_obINTERR-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING seg-bare & [ LEX-TAME + ],
			   LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
			   LOCAL.AGR.PNG #2], 
			  [LOCAL.CAT.HEAD.DECL -,
			   LOCAL.CONT.HOOK.INDEX.SF ques] >].


;;;;;;;;;; PRESENTATIONAL CONSTRUCTIONS
; for inheritance
; the NON-LOCAL restr is a bit too sharp - ,
;    NON-LOCAL.SLASH <! !>
; working area
#|
presentational-synsem-2 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				  PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #2] !>,
    LOCAL.CONT.HCONS <! !>].
|#
#|
presentational-synsem-2 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #3], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #4 ] !>,
    LOCAL.CONT.HCONS <![HARG #4,
			LARG #3]!> ].

|#

presentational-synsem-2 := lex-synsem &
  [ LOCAL.CAT lex-cat & [VAL.SUBJ < #subj>,  
			 QVAL.SUBJECT #subj & [ LOCAL [ CAT.HEAD expl-pron & [EXPLETIVE +],
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #3], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #3 ] !>,
    LOCAL.CONT.HCONS <! !> ].

;LH271111: being replaced by presentational-synsem-2
presentational-synsem := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & expl-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1 ].

#|
presentational-synsem := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & expl-ind,
						       HOOK.LTOP #2 ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #2 ].
|#
; suse, klarne; "klarne opp"
#|
impersonal-presentational-synsem := presentational-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1 ],
    LOCAL.CAT.VAL.COMPS <> ].
|#

;presentational-synsem-2
impersonal-presentational-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <> ].

;presentational-synsem-2
impersonal-trans-presentational-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS <[]> ].

#|
; kvekke, ise, kile, kime
impersonal-presentational-obl-synsem := presentational-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1 ],
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY index-sit1]]>,
    LKEYS.KEYREL.ARGOBLQ #2 ].
|#

impersonal-presentational-obl-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1 ],
    LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CAT.HEAD nominal & [SELECTED bool,
						     KEYS.KEY #3 ]]>, ; & index-sit1
    LKEYS.KEYREL.ARGOBLQ #2,
    LOCAL.KEY-SPEC #3 ].

impersonal-presentational-obl-event-synsem := impersonal-presentational-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
							     CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL + ]]],
   LOCAL.CAT.QVAL.OBL1 #loc & [LOCAL.CONT.HOOK.LTOP #1 & handle],
   LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1] ].

impersonal-presentational-obl-loc-synsem := impersonal-presentational-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.RELS.LIST.FIRST positioning-spatial-rel ].


;  "klarne opp", tykne til
;presentational-synsem-2
;                          LKEYS.KEYREL.ARG1 #1
;
;                          LOCAL.CONT.HOOK.XARG #1
					  
impersonal-presentational-telicparticle-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1],
    LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.COMPS <[ LOCAL.CAT.HEAD adv-reg,
                           LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion]>,
    LKEYS.KEYREL.ARGX #2 ].


; sitte, v√¶re - "det sitter en gutt her"
;  LOCAL.CONT.HOOK.XARG #1  is a bit tentative - - for the TROLL presentationals
subject-presentational-synsem-sup := presentational-synsem-2 &
   [ LOCAL.CAT trans-cat & [QVAL.DOBJECT #pres & [LOCAL [CAT.HEAD noun & [DEF -],
							 CONT.HOOK.INDEX #1,
							 CAT.HEAD.PRESENTED +,
							 DERIVED-HEAD -]],
                            VAL.COMPS < #pres & [] >],
     LKEYS.KEYREL.ARG1 #1,
     LOCAL.CONT.HOOK.VARG #1 ].

subject-presentational-synsem := subject-presentational-synsem-sup &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [QVAL.DOBJECT.LOCAL [CAT.HEAD.DEF -,
                                                CONT.HOOK.INDEX #1 ],
                            VAL.COMPS < [] >,
                            VAL.ICOMPS < >],
     LKEYS.KEYREL.ARG1 #1 ].

;;; experiment 021012
;; to enable scoping of expletive sentences, this is one roundabout way, exemplified for "det rusler en gutt". It will require a 3-rel verb lexeme type, and the following as the new presentational-synsem-2:
#|
; this is where the outcomment should start! down to line 16718
presentational-synsem-2 := lex-synsem &
[ LOCAL.CAT lex-cat & [QVAL.SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                              CONT.HOOK.INDEX #1 & ref-ind ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #4,
    LOCAL.CONT.RELS <! [LBL #4], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #3 ], [PRED "coreferential-rel",
					      ARG1 #3,
					      ARG2 #4 ] !>,
    LOCAL.CONT.HCONS <! !> ].
|#
#|
;Using the defined type verb-3rel-lexeme.
;illustrated with, in one lump:
subject-dir-presentational-verb-lexeme := lbl-ltop-lex-item-3rel &
[ SYNSEM lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                              CONT.HOOK.INDEX #1 & ref-ind ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #4,
    LOCAL.CONT.RELS <! [LBL #4], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #3 ], [PRED "coreferential-rel",
					      ARG1 #3,
					      ARG2 #4 ] !>,
    LOCAL.CONT.HCONS <! !> ]].
|#
#|
; and for the general pattern, such:
subject-dir-presentational-verb-lexeme := verb-3rel-lexeme &
  [ SYNSEM subject-dir-presentational-synsem ].

; where subject-dir-presentational-synsem inherits down from presentational-synsem-2 in the way generally defined. The new action is to adjust in verb-3rel-lexeme in all the lexeme types. 
|#

; rusle_4 "det rusler en gutt ut"
subject-dir-presentational-synsem := subject-presentational-synsem-sup &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CONT.HOOK.DIRARG #1,
    LKEYS.KEYREL.ARG1 #1,
    LOCAL.CAT.VAL.ICOMPS < > ]. 

;det sitter en mann i stolen
subject-locobl-presentational-synsem := subject-presentational-synsem-sup &
  [ LOCAL.CONT.HOOK hook & [VARG #3],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1 & index-sit],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial],
			   LOCAL.CONT.HOOK.VARG #3,
			   LOCAL.CONT.HOOK.LTOP #2 & handle]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #2 ] ].

;det verserer rykter om deg
; it's impossible to use this as a selected oblique, TODO, find out why.
subject-obl-presentational-synsem := subject-presentational-synsem-sup &
  [ LOCAL.CONT.HOOK hook & [VARG #3],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED +,
                                                          KEYS.KEY #1 ], ;& om-act-topic-of
                           LOCAL.CONT.HOOK.VARG #3,
			   LOCAL.CONT.HOOK.LTOP #2 & handle]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #2 ] ].

; "det hopper opp en katt"
;presentational-synsem-2
subject-presentational-telicparticle-synsem := presentational-synsem-2 &
  [  LOCAL.CAT.VAL.COMPS <[ LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY dir ],
			    LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
			    LOCAL.CONT.HOOK.XARG #1,
			    LKEYS.KEYREL.ARG1 #1,
			    LOCAL.CONT.HOOK.LTOP #2 & handle],
			  [ LOCAL [CAT.HEAD.DEF -,
                                  CONT.HOOK.INDEX #1,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -] ]>, 
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL arg1x-relation & [ ARG1 #1,
				    ARGX #2 ] ].

#|
subject-presentational-telicparticle-synsem := presentational-synsem-2 &
  [  LOCAL.CAT.VAL.COMPS <[ LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY dir ],
			    LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
			    LOCAL.CONT.HOOK.XARG #1,
			    LKEYS.KEYREL.ARG1 #1,
			    LOCAL.CONT.HOOK.LTOP #2 & handle],
			  [ LOCAL [CAT.HEAD.DEF -,
                                  CONT.HOOK.INDEX #1,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -]]>, 
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL arg1x-relation & [ LBL #2 ]].
|#

;presentational-synsem-2
subject-presentational-telicparticle-prtcllast-synsem := presentational-synsem-2 &
  [  LOCAL.CAT.VAL.COMPS <[ LOCAL [CAT.HEAD.DEF -,
                                  CONT.HOOK.INDEX #1,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -]],
			    [ LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY dir ],
			   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
			    LOCAL.CONT.HOOK.XARG #1,
			    LKEYS.KEYREL.ARG1 #1] >, 
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARG1 #1 ].


;presentational-synsem-2
double-np-presentational-synsem-sup := presentational-synsem-2 &
   [  LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT [VAL.COMPS [FIRST [ LOCAL.CONT.HOOK.INDEX #2 ], 
			  REST.FIRST [LOCAL [CAT.HEAD.DEF -,
					      CAT.HEAD.PRESENTED +,
					      CONT.HOOK.INDEX #1 ]]]],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

; in this case, the reflexive and the non-reflexive version
; reflect very different patterns:
; "det tilkommer meg penger"
io-presentational-synsem := double-np-presentational-synsem-sup &
  [ LOCAL.CAT ditrans-cat,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].



subject-presentational-refl-synsem-sup := double-np-presentational-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS [FIRST [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
				 LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
				 LOCAL.AGR.PNG #2,
				 LEX +  ], 
                         REST.FIRST [LOCAL.CONT.HOOK.INDEX #4,
				     LOCAL.AGR.PNG #2]],
    LOCAL.CAN-PASSIVIZE - ].

; "det setter seg en gutt"
subject-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
  [LOCAL.CAT ditrans-cat,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS <[], []>,
   LOCAL.CAT.VAL.ICOMPS <>].


; "det oppholder seg en gutt under trappen/her"
#|
subject-locobl-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <[], [LOCAL.CONT.HOOK.INDEX #3], 
			 [LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CONT.HOOK.XARG #3,
                           LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX [SORT non-fix-point,
						  ROLE xdim-to-xdim-spatial]]>,
    LKEYS.KEYREL.ARGX #2 ].
;revise, make obl a comp
|#

subject-locobl-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <[], [LOCAL.CONT.HOOK.INDEX #3]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CONT.HOOK.XARG #3,
                           LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX [SORT non-fix-point,
						  ROLE xdim-to-xdim-spatial]]>,
    LKEYS.KEYREL.ARGX #2 ].


; LH 260411 For 'det smyger seg en mann' (for 'det smyger seg en mann ut')
; TODO: define the directionality of the presented item: we cannot simply add 'subject-dir-presentational-synsem' (see above) as a further subtype.
subject-dir-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
 [ LOCAL.CONT.HOOK dir-hook,
   LOCAL.CONT.HOOK.DIRARG #1,
   LKEYS.KEYREL.ARG1 #1,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.VAL.COMPS <[], []>,
   LOCAL.CAN-PASSIVIZE - ].


;presentational-synsem-2
subject-presentational-secpred-refl-dir-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.LTOP #ltop,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD pers-pron, 
			    LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
			    LOCAL.CONT.HOOK.INDEX #3,
                            LOCAL.AGR.PNG #2  ], 
                          [ LOCAL.CONT.HOOK.LTOP #ltop,
			    LOCAL.CONT.HOOK.XARG #4,
                           LOCAL.CAT.HEAD prep-or-adv & [ KEYS.KEY dir ]], 
                          [LOCAL [CAT.HEAD.DEF -,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -],
                           LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARG1 #4,
    LKEYS.KEYREL.ARG2 #3,
    LOCAL.CONT.HOOK.VARG #4,
    LOCAL.CAN-PASSIVIZE -  ].



;;;; "EXTRAPOSITION"- but no displacement
; forekomme, foresveve - "det forekommer meg at han kommer"
;presentational-synsem-2
io-epon-synsem-sup := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT ditrans-cat & [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2,
					    LOCAL.DERIVED-HEAD - ], 
                                          [LOCAL.CAT.HEAD glob-comp,
                                           LOCAL.CONT.HOOK.LTOP #1] >,
                              VAL.ICOMPS <> ],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

;presentational-synsem-2
io-epon-wh-synsem-sup := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT ditrans-cat & [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2,
					    LOCAL.DERIVED-HEAD - ], 
                                          [LOCAL.CAT.HEAD verb-all & [DECL -],
                                           LOCAL.CONT.HOOK.LTOP #1] >,
                              VAL.ICOMPS <> ],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

io-epon-synsem := io-epon-synsem-sup &
  [  LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

io-refl-epon-synsem := io-epon-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
			    LKEYS.KEYREL.ARG0.PNG 3sg  ], [] >].

io-epon-wh-synsem := io-epon-wh-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed], [] >].

io-refl-epon-wh-synsem := io-epon-wh-synsem-sup &
  [ LOCAL.CAN-PASSIVIZE -,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
			    LKEYS.KEYREL.ARG0.PNG 3sg  ], [] >].

; det tar tre timer √• g√•
;presentational-synsem-2
meas-epon-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT ditrans-cat & [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2 ], ;  & [ SORT measure-unit ]], 
                                          [LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
                                                                         DECL +  ],
                                           LOCAL.CONT.HOOK.LTOP #1] >,
                              VAL.ICOMPS <>],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

; det tar oss tre timer √• g√•
;presentational-synsem-2
meas-io-epon-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3,
			      LOCAL.BINDING non-bound ], 
                            [ LOCAL.CONT.HOOK.INDEX #2 ], ;  & [ SORT measure-unit ]], 
                            [LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
                                                           DECL +  ],
                             LOCAL.CONT.HOOK.LTOP #1,
                             LOCAL.CONT.HOOK.XARG #3] >,
                VAL.ICOMPS <>],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2,
                   ARG3 #3]].


; forekomme, hende - "det hender at han kommer"
;presentational-synsem-2
epon-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CAT.HEAD fin-comp & [DECL +],
                                           LOCAL.CONT.HOOK.LTOP #1] >,
			    VAL.ICOMPS <> ],
;     LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !> ].

; LH 010511 for "det hjelper √• ..."
;presentational-synsem-2
epon-inf-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
                                           LOCAL.CONT.HOOK.LTOP #1] >,
			    VAL.ICOMPS <> ],
;     LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !> ].

;presentational-synsem-2
epon-particle-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CONT.HOOK.LTOP #ltop,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #ltop,
					 LOCAL.CAT[HEAD adv-reg &
						   [SELECTED +,
						   KEYS.KEY pcl ]]],
					 [LOCAL.CAT.HEAD glob-comp,
                                           LOCAL.CONT.HOOK.LTOP #1] >,
			    VAL.ICOMPS <> ],
 ;    LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !>].

epon-particle-DECL-synsem := epon-particle-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD fin-comp] >].
epon-particle-inf-synsem := epon-particle-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -]] >].
epon-particle-interr-synsem := epon-particle-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.DECL -] >].

;,
;			       LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #2

;presentational-synsem-2
epon-pp-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT  [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #1] >,
		 VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
			       LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nominal,
			       LOCAL.CAT.HEAD prep &  [SELECTED +,
						       KEYS.KEY fct-spec ],
			       LEX -] >],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].

epon-np-pp-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT  [VAL.COMPS < [], [LOCAL.CONT.HOOK.LTOP #1] >,
		 VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
;			       LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nominal,
;			       LOCAL.CAT.HEAD prep &  [SELECTED +,
;						       KEYS.KEY fct-spec ],
			       LEX -] >],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].

epon-particle-pp-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CONT.HOOK.LTOP #ltop,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #ltop,
					 LOCAL.CAT[HEAD adv-reg &
						   [SELECTED +,
						   KEYS.KEY pcl ]]],
					 [LOCAL.CONT.HOOK.LTOP #1] >,
			    VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #2,
					 LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nominal,
					 LOCAL.CAT.HEAD prep &  [SELECTED +,
								 KEYS.KEY fct-spec ],
					 LEX -]> ],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].

epon-particle-pp-clause-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CONT.HOOK.LTOP #ltop,
     LOCAL.CAT  [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #ltop,
			      LOCAL.CAT[HEAD adv-reg &
					     [SELECTED +,
					      KEYS.KEY pcl ]]],
			     [LOCAL.CONT.HOOK.LTOP #1] >,
		 VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
			       LOCAL.CAT.HEAD prep-comp & [SELECTED bool,  
						       KEYS.KEY clse  ],
			       LEX -] >],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].


epon-decl-and-yn-pp-synsem := epon-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD glob-comp] > ].
epon-wh-pp-synsem := epon-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].
epon-np-decl-and-yn-pp-synsem := epon-np-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD glob-comp] > ].

epon-decl-and-yn-particle-pp-synsem := epon-particle-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD glob-comp] > ].
epon-wh-particle-pp-synsem := epon-particle-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

;presentational-synsem-2
epon-pp-clause-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT  [VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
			       LOCAL.CAT.HEAD prep-comp & [SELECTED bool,  ; this has been commented out, don't remember why
						       KEYS.KEY clse  ],
			       LEX -] >,
	       	 VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #1] >],
;     LKEYS.KEYREL [ARG1 #1,
;		   ARGOBLQ #2],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].

epon-decl-and-yn-pp-clause-synsem := epon-pp-clause-synsem &
   [ LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblYN_expnYN. ok
epon-decl-and-yn-decl-and-yn-pp-clause-synsem := epon-decl-and-yn-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblYN_expnWH. ok
epon-decl-and-yn-wh-pp-clause-synsem := epon-decl-and-yn-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

epon-wh-pp-clause-synsem := epon-pp-clause-synsem &
   [ LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD verb-all & [DECL -]] > ].
;for: v-intrOblExpn-oblWH_expnYN. ok
epon-wh-decl-and-yn-pp-clause-synsem := epon-wh-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblWH_expnWH. ok
epon-wh-wh-pp-clause-synsem := epon-wh-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

;;
epon-decl-and-yn-particle-pp-clause-synsem := epon-particle-pp-clause-synsem &
   [ LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblYN_expnYN. ok
epon-decl-and-yn-decl-and-yn-particle-pp-clause-synsem := epon-decl-and-yn-particle-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD glob-comp] > ].
;x for: v-intrOblExpn-oblYN_expnWH. ok
epon-decl-and-yn-wh-particle-pp-clause-synsem := epon-decl-and-yn-particle-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].
;x
epon-wh-particle-pp-clause-synsem := epon-particle-pp-clause-synsem &
   [ LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD verb-all & [DECL -]] > ].
;for: v-intrPrtclOblExpn-oblWH_expnYN. ok
epon-wh-decl-and-yn-particle-pp-clause-synsem := epon-wh-particle-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD glob-comp & [DECL -]] > ].
;x for: v-intrOblExpn-oblWH_expnWH. ok
epon-wh-wh-particle-pp-clause-synsem := epon-wh-particle-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

;;
;presentational-synsem-2
epon-oblique-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT intrans-with-1icomps-pp-cat & [VAL.ICOMPS < [LOCAL.CAT[HEAD prep & [SELECTED +,
										   KEYS.KEY fct-spec  ],
								      QVAL.DOBJECT [LOCAL.CAT.HEAD glob-comp,
										    LOCAL.CONT.HOOK.LTOP #1]]]>],
     LKEYS.KEYREL [ARGoblq #1 ]].

; "det sp√∏rs om han kommer"
;presentational-synsem-2
epon-indirwhquest-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT.HEAD verb,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CAT.HEAD.DECL -,
					 LOCAL.CONT.HOOK.LTOP #1] > ],
;     LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !>].


;;;; COPULA-LIKE SYNSEMS

; "at han kommer er fint", "√• komme er fint"
copula-adj-abs-with-nonepon-synsem := lex-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD verb-or-comp,
                           LOCAL.CONT.HOOK.INDEX #5 & event-verb,
                           LOCAL.CONT.HOOK.LTOP #1,
                           LOCAL.AGR #7 ] >, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CONT.HOOK.LTOP #3,
                             LOCAL.CAT.HEAD prep-or-adj,
                             LOCAL.CONT.RELS.LIST.FIRST adj_rel,
                             LKEYS.KEYREL.ARG1 #1,
                             LOCAL.AGR #7 ] >],
    LKEYS.KEYREL.ARG1 #3 ].

; these subtypes reflect a selection really done by the adjective. But since
; adj does not syntactically select for a subject, it has to 'commission'
; that selection to the copula, of which the adj itself is a COMPS                    
copula-adj-abs-with-nonepon-decl-synsem := copula-adj-abs-with-nonepon-synsem & 
  [ LOCAL.CAT.VAL [ COMPS < [LOCAL.CAT.HEAD.KEYS.KEY adj-decl-selct,
                             LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL +] >,
                    SUBJ < [LOCAL.CAT.HEAD.DECL + ]> ]].
                    
copula-adj-abs-with-nonepon-quest-synsem := copula-adj-abs-with-nonepon-synsem & 
  [ LOCAL.CAT.VAL [ COMPS < [LOCAL.CAT.HEAD.KEYS.KEY adj-quest-selct,
                             LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL - ] >,
                    SUBJ < [LOCAL.CAT.HEAD.DECL - ]> ] ].
 
; v√¶re, bli - "han er syk"
;removed  LOCAL.CAT.VAL.COMPS.NON-LOCAL.SLASH <! !> , to enable "hvor gammel er du?"
copula-standard-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.INDEX super-event,
                              LOCAL.CAT.HEAD prep-or-adj & [KEYS.KEY propt,
							    WEAK -]] >]].

copula-predparticle-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX ref-ind]>, 
                    COMPS < [ LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ]] >]].
; ,
;                              NON-LOCAL.SLASH <! !> 

;,
;			    LOCAL.CAT.HEAD.EXPLETIVE -
copula-locpp-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
;                              LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.KEYS.KEY regnoun,
                              LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1]  ] >]].

copula-locpp-pp-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
;    LOCAL.CAT intrans-ncomps-doublesecpred1-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.KEYS.KEY regnoun,
                              LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1]  ],
			    [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.KEYS.KEY regnoun,
                              LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1]  ]>]].


;

copula-dirpp-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.HEAD prep & [KEYS.KEY dir]  ] >]].
;,
;    NON-LOCAL.SLASH <!!>

copula-predprtcl-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ]  ] >]].
; ,
;    NON-LOCAL.SLASH <!!>
;LOCAL.CONT.HOOK.XARG #5,

copula-locpp-with-nonepon-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.QVAL.SUBJECT [LOCAL.CAT.HEAD verb-or-comp,
			    LOCAL.CONT.HOOK.INDEX #5 & event], 
    LOCAL.CAT.QVAL.PREDIC [LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1],
			   LOCAL.CONT.HOOK.XARG #5]].
; ,
;                   COMPS < [ LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1],
;			      LOCAL.CONT.HOOK.XARG #5] >],

;    NON-LOCAL.SLASH <!!>



copula-locadv-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.HEAD adv-reg & [KEYS.KEY index-sit]  ] >]].




; v√¶re_abs  - "det er fint i Finnmark"
;                   COMPS < [ LOCAL.CONT.HOOK.XARG #5 & expl-ind
copula-standard-abs-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
			    LOCAL.CAT.HEAD.EXPLETIVE +]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5 & ref-ind,
                             LOCAL.CONT.HOOK.INDEX super-event,
                              LOCAL.CAT.HEAD prep-or-adv & [ KEYS.KEY index-sit1 ] ] >]].

copula-tough-abs-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>,                    
		    COMPS < [ LOCAL.CONT.HOOK.XARG #5 & ref-ind,
                             LOCAL.CONT.HOOK.INDEX super-event,
                              LOCAL.CAT.HEAD adj & [ KEYS.KEY absadj0-tough ],
                              LOCAL.DERIVED-HEAD - ] >]].

copula-er-√•-finne-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #2,
			  LOCAL.CAT.HEAD.EXPLETIVE -]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
			    LOCAL.HAS-WH-MOVED +,
			    LOCAL.CONT.HOOK.XARG #2 ] > ].

; v√¶re_5 - "han er en gutt", "han er gutten"
; the DERIVED-HEAD restr in order to avoid "er syk" handled by this rule
; (but it will take "er en syk", since teh specification is then embedded)
; lhsept2010: shifted the number identity req over to 'v-copIdN'
; 170811: and back here again

;,
;    NON-LOCAL.SLASH <!!>
#|
copula-nom-synsem := trans-arg1-2-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #1 & ref-ind] >,
		    COMPS < [ LOCAL.CAT.HEAD nominal,
                              LOCAL.CONT.HOOK.INDEX #1,
                              LOCAL.DERIVED-HEAD - ] >]].
|#
#|
copula-nom-synsem := trans-arg1-2-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >,
		    COMPS < [ LOCAL.CAT.HEAD np-head, ; not nominal-or-connect-n, that loses 'klokka er omtrent fem'
                              LOCAL.CONT.HOOK.INDEX ref-ind,
                              LOCAL.DERIVED-HEAD - ] >],
    NON-LOCAL.SLASH 0-dlist ].
|#

copula-nom-synsem := trans-arg1-2-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >,
		    COMPS < [ LOCAL.CAT.HEAD np-head, ; not nominal-or-connect-n, that loses 'klokka er omtrent fem'
                              LOCAL.CONT.HOOK.INDEX ref-ind,
                              LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			      LOCAL.DERIVED-HEAD -,
			      LOCAL.DERIVED-BARE-N-FROM-ADJ - ] >] ].

copula-clause-synsem := trans-subord-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ COMPS < [ LOCAL.CAT.HEAD comp,
                              LOCAL.CONT.HOOK.INDEX event,
                              LOCAL.DERIVED-HEAD - ] >],
    NON-LOCAL.SLASH <!!>].

; TODO: too strong with INV, rather be a ban against
copula-absinf-synsem := trans-absinfsubord-synsem & 
  [ LOCAL.CAT.HEAD copula  & [INV -] ].

copula-arg1absinf-absinf-synsem := trans-arg1absinf-absinfsubord-synsem & 
  [ LOCAL.CAT.HEAD copula  & [INV -]].

copula-indirwhquest-synsem := trans-indirwhquest-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula ].

copula-indir-y-n-quest-synsem := trans-indir-y-n-quest-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula ].
; ,
;    NON-LOCAL.SLASH <!!>

;copula-noun-with-sudecl-nonepon-synsem := lex-synsem &
copula-noun-with-sudecl-nonepon-synsem := trans-eventarg1-decl-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD fin-comp & [DECL +],
                          LOCAL.CONT.HOOK.LTOP #1,
			   LEX -] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2,
			    LOCAL.CONT.HOOK.INDEX ref-ind] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

copula-noun-with-suYN-nonepon-synsem := trans-eventarg1-interr-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD fin-comp & [DECL -],
                          LOCAL.CONT.HOOK.LTOP #1,
			   LEX - ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

copula-noun-with-suWH-nonepon-synsem := trans-eventarg1-interr-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD verb-all & [DECL -],
                          LOCAL.CONT.HOOK.LTOP #1,
			   LEX - ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

copula-noun-with-suabsinf-nonepon-synsem := trans-eventarg1-absinf-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -,
							DECL +,
							KEYS.KEY infinit-comp-arb],
                          LOCAL.CONT.HOOK.LTOP #1,
			   LEX - ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

 
;;;;;;;; POSSIBLE SEMANTICALLY ENRICHED SYNSEMS, 

;; A. NOT BASED on predsort.tdl

intrans-arg1-nonorient := intrans-arg1-synsem &
  [ LKEYS.KEYREL non-oriented-svh-rel ].

intrans-arg1-locomotion := intrans-arg1-synsem &
  [ LKEYS.KEYREL locomotion-rel ].

intrans-arg1-pure-orientation := intrans-arg1-synsem &
  [ LKEYS.KEYREL pure-orientation-rel ].

; is actively used, in masc-dir-noun-lxm
; now included in lxm-type
;nounsynsem-arg0dir := lex-synsem &
;    [ LOCAL.CONT.HOOK.DIRARG #1,
;      LKEYS.KEYREL.ARG0 #1,
;      LOCAL.CAT.HEAD.KEYS.KEY dirnoun ].

; "se ut". "peke hitover"; used, but in standard gr not clear why
intrans-arg1orient-synsem := intrans-arg1dir-synsem &
    [ LOCAL.CAT.VAL.ICOMPS <>,
      LKEYS.KEYREL i-pure-orientation-rel ].

; the class of transitive 'measuring-out-event' verbs
trans-arg1-2tel := trans-arg1-2-synsem.

trans-arg1dir-2length-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK.DIRARG #1,
    LKEYS.KEYREL.ARG1 #1,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT length-unit,
                            LOCAL.CAN-MAL-DROP -, ; for reflexive object - for mal-gram uses!
			    LOCAL.CAT.HEAD.KEYS.KEY measnoun ]>].

trans-arg1-2ejection := trans-arg1-2-synsem &
  [ LKEYS.KEYREL ejection-rel ].




;; B.  BASED on predsort.tdl
; the 'i-SYNSEM' types

posture-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-posture-svh-rel ].
arrow-pointing-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-pure-orientation-rel ].
road-going-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-path-constellation-rel ].
tour-going-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-locomotion-development-rel ].
locomotion-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-locomotion-rel ].

directing-arrow-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-pure-orientation-rel ].
directing-line-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-path-constellation-rel ].
directing-tour-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-locomo-conduction-rel ].
ejection-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-locomotion-rel ].

line-follow-line-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-parallel-double-path-constellation-rel ].
line-crossing-line-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-nonparallel-double-path-constellation-rel ].
begleiten-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-parallel-double-locomotion-rel ].
crossing-locomotors-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-nonparallel-double-locomotion-rel ].

init-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-arg1-init-rel ].
init-und-synsem := trans-arg1-2-synsem &
  [ LKEYS.KEYREL i-arg12-init-und-rel ].
init-dat-synsem := trans-arg1-2-synsem &
  [ LKEYS.KEYREL i-arg12-init-dat-rel ].
init-und-dat-synsem := ditrans-arg1-2-3-synsem &
  [ LKEYS.KEYREL i-arg123-init-und-dat-rel ].
und-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-arg1-und-rel ].
und-dat-synsem := trans-arg1-2-synsem &
  [ LKEYS.KEYREL i-arg12-und-dat-rel ].
dat-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-arg1-dat-rel ].

init-locomotion-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-arg1-init-locomotion-rel ].

;;; QVAL
qval-valence := avm &
  [ SUBJECT synsem ].

intrans-qval-sup := qval-valence.
intrans-qval := intrans-qval-sup.

trans-qval-sup := qval-valence &
  [ DOBJECT synsem & [ LOCAL.CAT.HEAD.ACCUSATIVE + ] ].

trans-qval := trans-qval-sup.

ditrans-qval-sup := trans-qval-sup &
  [ IOBJECT.LOCAL [ CAT.HEAD.ACCUSATIVE + ] ].

ditrans-qval := ditrans-qval-sup.

;; In secpred-constellations, if PREDIC is not vp/inf, then PIVOT will be
;; the ARG2 of the predicate serving as PREDIC. If PREDIC is vp/inf,
;; then the semantic role of the embedded V serving as PIVOT is whatever is
;; selected as SUBJECT of the vp/inf - can in principle be ARG1, ARG2 or ARG3
;; (if the VP is in passive form, for instance, it is not ARG1 even if the
;; verb is agentive).

secpred-qval := qval-valence &
  [ PREDIC.LOCAL.CAT.QVAL.SUBJECT.LOCAL [ CONT.HOOK.INDEX semarg ] ].

secpred2-qval := qval-valence &
  [ PREDIC2.LOCAL.CAT.QVAL.SUBJECT.LOCAL [ CONT.HOOK.INDEX semarg ] ].

intrans-secpred-qval-sup := secpred-qval &
  [ SUBJECT #1,
    PREDIC.LOCAL.CAT.QVAL.SUBJECT #1 ].

intrans-secpred-qval := intrans-secpred-qval-sup.

intrans-doublesecpred-qval := intrans-secpred-qval-sup & secpred2-qval &
  [ PREDIC2 synsem ].

trans-secpred-qval := secpred-qval & trans-qval-sup &
  [ DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
    PREDIC.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 ].

;trans2-secpred-qval := secpred-qval & trans-qval &
;  [ DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
;    PREDIC.LKEYS.KEYREL.ARG1 #1 ].

;LH 040117 not used, I think - threby also trans-invertsecpred-cat. Well, was wrong ...
trans2-secpred-qval := secpred-qval & trans-qval-sup &
  [ DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
    PREDIC.LOCAL.CONT.HOOK.XARG #1 ].

with-obl-pp-qval := qval-valence &
  [ OBL1 [ LOCAL mod-local ] ].

with-2obl-pp-qval := with-obl-pp-qval &
  [ OBL2.LOCAL.CAT.HEAD prep-or-adv ].

intrans-with-obl-pp-qval := intrans-qval-sup & with-obl-pp-qval.

intrans-with-2obl-pp-qval := intrans-qval-sup & with-2obl-pp-qval.

trans-with-obl-pp-qval := trans-qval-sup & with-obl-pp-qval.

trans-with-2obl-pp-qval := trans-qval-sup & with-2obl-pp-qval.

ditrans-with-obl-pp-qval := ditrans-qval-sup & with-obl-pp-qval.

lightverbnoun-qval := qval-valence &
  [ LVC-GVRNOR synsem ].

;;;;;
;;;;;   VALENCE
;;;;;

;empty-ncomps-val := valence &
;  [ COMPS < > ].

;subj-empty-ncomps-val := empty-ncomps-val &
;  [ SUBJ < [] > ].

;v-val := valence &
;  [ ICOMPS list ].

;absolute-v-val := v-val & empty-ncomps-val.

empty-icomps-v-val := valence &
  [ ICOMPS < > ].

intrans-v-val := valence &
  [ COMPS < > ].

trans-v-val := valence &
  [ COMPS < [], ... > ].

; TODO: something needed to exclude adverbs from serving as second object - 'kastet den ut' gets 6 parses with that.
ditrans-v-val := valence &
  [ COMPS < [ LOCAL[ CONT.HOOK.INDEX ref-ind ] ], [], ... > ].

lightverbnoun-val := valence &
  [ GOVERNOR list ].

;;;;;
;;;;;   CAT
;;;;;

qval-cat := cat &
  [ QVAL qval-valence ].

;; The following cat-types link the synsems on the valence lists to functional
;; categories. For example is the synsem on the SUBJ list of verbs linked to 
;; the functional category SUBJECT in 'v-cat'. 
;; The cat-types also carry information about the length of the valence lists.

lex-cat := qval-cat &
  [ VAL.SUBJ < #1 >,
    QVAL.SUBJECT #1 ].

p-cat := lex-cat &
  [ VAL.COMPS < #1 >,
    QVAL.DOBJECT #1 ].

empty-icomps-cat := lex-cat &
  [ VAL.ICOMPS < > ].

icomps-cat := lex-cat &
  [ VAL.ICOMPS <  #1 >,
    QVAL.OBL1 #1 ].

intrans-cat := lex-cat &
  [ VAL intrans-v-val,
    QVAL intrans-qval-sup ].

intrans-empty-icomps-cat := intrans-cat & empty-icomps-cat &
  [ QVAL intrans-qval ].

trans-cat := lex-cat &
  [ VAL.COMPS < #1, ... >,
    QVAL.DOBJECT #1,
    VAL trans-v-val,
    QVAL trans-qval-sup ].

trans-empty-icomps-cat := trans-cat & empty-icomps-cat.

trans-1ncomps-empty-icomps-cat := trans-empty-icomps-cat &
  [ VAL.COMPS < [] > ].


ditrans-cat := lex-cat &
  [ QVAL [ DOBJECT #1, ; ditrans-qval &  not accepted
           IOBJECT #2 ],
    VAL ditrans-v-val &
         [ COMPS < #2, #1 > ] ].

ditrans-empty-icomps-cat := ditrans-cat & 
                            empty-icomps-cat &
  [ VAL.COMPS < [], [] > ].

;; "renne halvfull"

intrans-secpred-cat := lex-cat &
  [ VAL valence,
    QVAL intrans-secpred-qval-sup ].

intrans-ncomps-secpred-cat := intrans-secpred-cat &
  [ VAL.COMPS < #1 >,
    QVAL intrans-secpred-qval & [ PREDIC #1 ] ].

; for "se syk[PREDIC1] ut[PREDIC2]"
intrans-ncomps-doublesecpred1-cat := intrans-secpred-cat &
  [ VAL.COMPS < #1, #2 >,
    QVAL intrans-doublesecpred-qval & [ PREDIC #1,
                                        PREDIC2 #2 ] ].

; for "se  ut[PREDIC2] til √• besvime[PREDIC1]"
intrans-ncomps-doublesecpred2-cat := intrans-secpred-cat &
  [ VAL.COMPS < #2, #1 >,
    QVAL intrans-doublesecpred-qval & [ PREDIC #1,
                                        PREDIC2 #2 ] ].

;intrans-icomps-secpred-cat := intrans-secpred-cat &
;  [ VAL.ICOMPS < #1 >,
;    QVAL intrans-secpred-qval & [ PREDIC #1 ] ].

trans-secpred-cat := trans-cat &
  [ VAL valence,
    QVAL trans-secpred-qval].

trans-invertsecpred-cat := lex-cat &
  [ VAL.COMPS < #2, #1 >,
    QVAL trans2-secpred-qval & [ DOBJECT #1,
                                 PREDIC #2 ]].



;; "sparke d√∏ren l√∏s"

trans-ncomps-secpred-cat := trans-secpred-cat &
  [ QVAL trans-secpred-qval & 
         [ PREDIC #2 ],
    VAL trans-v-val &
         [ COMPS < [ ], #2  > ] ].

trans-ncomps-secpred-invert-cat := trans-secpred-cat &
  [ QVAL trans-secpred-qval & 
         [ PREDIC #2 ],
    VAL trans-v-val &
         [ COMPS < #2, [ ]  > ] ].

;trans-icomps-secpred-cat := trans-secpred-cat &
;  [ QVAL trans-secpred-qval & 
;         [ PREDIC #2 ],
;    VAL trans-v-val &
;         [ COMPS < [ LOCAL [ CONT.HOOK.INDEX ref-ind ] ] >,
;           ICOMPS < #2  > ] ].

trans-ncomps-secpred-empty-icomps-cat := trans-ncomps-secpred-cat &
                                           trans-empty-icomps-cat.

trans-nosecpred-empty-icomps-cat :=  trans-1ncomps-empty-icomps-cat.

with-icomps-pp-cat := lex-cat &
  [ VAL.ICOMPS < #1, ...>,
    QVAL with-obl-pp-qval & [ OBL1 #1 & [ LOCAL.CAT [ HEAD prep-or-adv,
                                                      VAL.COMPS <> ] ] ] ].

intrans-with-icomps-pp-cat := with-icomps-pp-cat & intrans-cat &
  [ QVAL with-obl-pp-qval ].

;from [] to expressed-synsem, to avoid the missing prep mal-rule to appear with alle vil vise s√• viktige sauer
with-1icomps-pp-cat := with-icomps-pp-cat &
  [ VAL.ICOMPS < [] > ].

intrans-with-1icomps-pp-cat := with-1icomps-pp-cat & 
                               intrans-with-icomps-pp-cat.

with-2icomps-pp-cat := with-icomps-pp-cat &
  [ VAL.ICOMPS < [], #1 >,
    QVAL.OBL2 #1 ].

intrans-with-2icomps-pp-cat := with-2icomps-pp-cat & 
                               intrans-with-icomps-pp-cat.

trans-with-icomps-pp-cat := trans-cat & with-icomps-pp-cat.

trans-with-1icomps-pp-cat := trans-with-icomps-pp-cat & 
                               with-1icomps-pp-cat &
  [ VAL.COMPS < [] > ].

trans-with-2icomps-pp-cat := trans-with-icomps-pp-cat & 
                               with-2icomps-pp-cat &
  [ VAL.COMPS < [] > ].

ditrans-with-icomps-pp-cat := ditrans-cat & with-icomps-pp-cat.
;  [ VAL.ICOMPS < #1, ...>,
;    QVAL ditrans-with-obl-pp-qval & [ OBL1 #1 ] ].

ditrans-with-1icomps-pp-cat := ditrans-with-icomps-pp-cat &
                                         with-1icomps-pp-cat &
  [ VAL.COMPS < [], [] > ].

ditrans-empty-icomps-pp-cat := ditrans-empty-icomps-cat &
  [ VAL.COMPS < [LOCAL.CAT.HEAD prep], [] > ].

; presumably not needed
;ditrans-with-2icomps-pp-cat := ditrans-with-icomps-pp-cat &
;                                         with-2icomps-pp-cat &
;  [ VAL.COMPS < [], [] > ].

;ditrans-with-2ncomps-1icomps-pp-cat := ditrans-cat &
;                                         with-1icomps-pp-cat &
;  [ VAL.COMPS < [], [] > ].

; for nouns in light verb constructions
lightverbnoun-cat := qval-cat &
 [ VAL lightverbnoun-val & [GOVERNOR < #2 >],
   QVAL lightverbnoun-qval & [LVC-GVRNOR #2]].


;;;;;;;;;;;;;; LEXICAL RULES
#|
; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
passive-lexeme := const-ltol-rule & verb-general-lexeme &
[ INFLECTION #infl,
  SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4 ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
  ARGS < [ INFLECTION #infl,
           SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
                                  VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
                                        SPR #spr ] ] ],
                    LKEYS #keys,
                    NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
  C-CONT.RELS <! !> ].
|#

; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
; this is a verb-lexeme, but cannot inherit from 'verb-general-lexeme' because this does not allow any C-CONT RELS addidions
passive-lexeme := const-ltol-rule & lbl-ltop-lex-item-3rel &
[ INFLECTION #infl,
  SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4,
		   CONT.HCONS #hcons ],
           LKEYS #keys,
	   NON-LOCAL #non-local ],
  SYNSEM.LOCAL.CAT.HEAD verb-all,
  SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
  SYNSEM.LKEYS.KEYREL event-relation,
  SYNSEM.LOCAL.CONT.HOOK.XARG #1,
  SYNSEM.LOCAL.REL-CL-SOM-INIT -,
  SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
  SYNSEM.LOCAL.OBJ-DEL-APPLIED -,
  SYNSEM.LOCAL.COMPS-BEGUN -,		  ;; Added to avoid s-final. EAA030811
  SYNSEM.BIND unbnd,
  ARGS < [ INFLECTION #infl,
           SYNSEM.LOCAL.CAN-PASSIVIZE +,
	   SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED -,
	   SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
                                  VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
                                        SPR #spr ] ] ],
                    LKEYS #keys,
                    NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
  C-CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				 ARG0 #4,
				 RSTR #5 ], pron_rel & [ PRED "_understood-agent_rel",
							 LBL #6,
							 ARG0 #4 ] !>,
  C-CONT.HCONS #hcons & <! [ HARG #5,
			     LARG #6] !> ].

                                              
passive-ncomps1-sup := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #5,
                                    LOCAL.CAT.HEAD poss-subj-head  & [KEYS.KEY #kk],
				    LOCAL.CAT.HEAD.EXPLETIVE #expl] >, ;not a lower type, to enable rel-pron as subject.
                           COMPS #1,
                           ICOMPS #3 ],
;    SYNSEM.LOCAL.CONT.HOOK [XARG #5],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ #bool,
;    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    SYNSEM.VAL-CLASS #vc,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
                                              LOCAL.CAT.HEAD np-head & [KEYS.KEY #kk,
									EXPLETIVE #expl],
                                              LOCAL.BINDING.BOUND - ] . #1 >,; . #1
                                    ICOMPS #3 ],
             SYNSEM.VAL-CLASS #vc,
	     SYNSEM.LOCAL.CAN-PASTPART-ADJ #bool ] >].

passive-ncomps1 := passive-ncomps1-sup &
  [ SYNSEM.LOCAL.CONT.HOOK hook,
    ARGS < [SYNSEM.LOCAL.CONT.HOOK hook] > ].

passive-dir-ncomps1 := passive-ncomps1-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.DIRARG #5,
    ARGS < [SYNSEM.LOCAL.CONT.HOOK dir-hook & [ DIRARG #5 ]] > ].

; make a 'passive-dir-ncomps1' - needs some VARG regulations.
; same for subject-dir-presentational.
; 'ut' may need some tuning also

passive-ncomps2 := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #6,
                                    LOCAL.CAT.HEAD poss-subj-head  ] >,
                           COMPS < #5 . #1 >,
                           ICOMPS #3 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #6,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
;    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.VAL-CLASS #vc,
    SYNSEM.LOCAL.CONT.HOOK hook,
;    SYNSEM.NON-LOCAL.SLASH <! !>,  ; LH240713  a guess, to avoid topic-filling from sneaking into a passive, as in 'det kastes ballen til Ola'; but this also blocks 'jeg gjetter hva gutten kan ha blitt gitt'
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    COMPS < #5 & [LOCAL.CAT.HEAD nom,
						  LOCAL.CAT.HEAD.EXTRACTABLE -] . < [ LOCAL.CONT.HOOK.INDEX #6,
                                                     LOCAL.CAT.HEAD poss-subj-head ] . #1 > >,
                                    ICOMPS #3],
             SYNSEM.VAL-CLASS #vc,
	     SYNSEM.LOCAL.CONT.HOOK hook ]   > ].

;  [ SYNSEM  [ LOCAL.CAT trans-cat & [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
;                                                           CONT.HOOK.INDEX #3 & expl-ind  ]
                                           
subject-presentational-passive-sup := passive-lexeme &
  [ SYNSEM  [ LOCAL.CAT trans-cat & [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                                           CONT.HOOK.INDEX #3 & ref-ind  ],
                                           DOBJECT.LOCAL [CAT.HEAD.DEF -,
;                                                          CAT.HEAD.PRESENTED +,
                                                          CONT.HOOK.INDEX #2]],
                                     VAL.COMPS < #dobject & [] >,
                                     VAL.ICOMPS #icomps  ],
              LOCAL.CONT.HOOK.XARG #3 ],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX ref-ind ] >,
                                      ICOMPS #icomps ],
                                QVAL.DOBJECT #dobject ],
             SYNSEM.LKEYS.KEYREL [ARG1 #1,
                                  ARG2 #2],
             SYNSEM.LOCAL.CONT.HOOK.XARG #1 ]>].

subject-presentational-passive := subject-presentational-passive-sup &
  [ ARGS < [SYNSEM.LOCAL.CONT.HOOK hook] > ].
subject-dir-presentational-passive := subject-presentational-passive-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.DIRARG #5,
    ARGS < [SYNSEM.LOCAL.CONT.HOOK dir-hook & [ DIRARG #5 ]] > ].



; be revised on model of subject-presentational-passive
; NB replace 'passive-lexeme' here to comply with new def of impersonal-presentational-synsem
#|
impersonal-presentational-passive := passive-lexeme &
  [ SYNSEM  impersonal-presentational-synsem &
            [ LOCAL.CAT [ VAL [ COMPS #ncomps,
                                ICOMPS #icomps ],
                          QVAL.DOBJECT #dobject ] ],
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL [ COMPS #ncomps,
                                      ICOMPS #icomps ],
                                QVAL.DOBJECT #dobject ] ] > ].
|#

impersonal-presentational-passive := const-ltol-rule & lbl-ltop-lex-item-4rel &
  [ INFLECTION #infl,
    SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4,
		   CONT.HCONS #hcons ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,		 ;; Added to avoid s-final. EAA030811
    SYNSEM.BIND unbnd,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM.VAL-CLASS #vc,
    SYNSEM  lex-synsem &
            [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #10 & ref-ind ] ] ]],
	      LOCAL.CONT.HOOK.XARG #10,
	      LOCAL.CONT.HOOK.LTOP #20,
	      LOCAL.CAT [ VAL [ COMPS #ncomps,
;				COMPS <>,
                                ICOMPS #icomps ],
                          QVAL.DOBJECT #dobject ] ],
    ARGS < [ INFLECTION #infl,
	     SYNSEM.VAL-CLASS #vc,
	     SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
				    VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
					  SPR #spr ] ] ],
		      LKEYS #keys,
		      NON-LOCAL #non-local ],
	     SYNSEM.LOCAL.CAT [ VAL [ COMPS #ncomps,
                                      ICOMPS #icomps ],
                                QVAL.DOBJECT #dobject & [LOCAL.CAT.HEAD.DEF -,
							 LOCAL.CAT.HEAD.DEFINITE -]],
	     SYNSEM.LOCAL.OBJ-DEL-APPLIED -,
	     SYNSEM.LOCAL.CAN-PASSIVIZE + ] >,
    C-CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				   ARG0 #4,
				   RSTR #5 ], pron_rel & [ PRED "_understood-agent_rel",
							   LBL #6,
							   ARG0 #4 ], [PRED "intro-sit-rel",
									   ARG1 #10,
									   ARG2 #20] !>,
    C-CONT.HCONS #hcons & <! [ HARG #5,
			       LARG #6] !>  ].


impersonal-presentational-passive-from-intrans := const-ltol-rule & lbl-ltop-lex-item-4rel &
  [ INFLECTION #infl,
    SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4,
		   CONT.HCONS #hcons ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,				;; Added to avoid s-final. EAA030811
    SYNSEM.BIND unbnd,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM  lex-synsem &
            [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #10 & ref-ind ] ] ]],
	      LOCAL.CONT.HOOK.XARG #10,
	      LOCAL.CONT.HOOK.LTOP #20,
	      LOCAL.CAT [ VAL [ COMPS #ncomps,
                                ICOMPS #icomps ] ] ],
    ARGS < [ INFLECTION #infl,
	     SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
				    VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
					  SPR #spr ] ] ],
		      LKEYS #keys,
		      LOCAL.CAN-PASSIVIZE +,
		      NON-LOCAL #non-local ],
	     SYNSEM.LOCAL.CAT [ VAL [ COMPS #ncomps,
                                      COMPS <>,
				      ICOMPS #icomps ]],
	     SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
    C-CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				   ARG0 #4,
				   RSTR #5 ], pron_rel & [ PRED "_understood-agent_rel",
							   LBL #6,
							   ARG0 #4 ], [PRED "intro-sit-rel",
									   ARG1 #10,
									   ARG2 #20] !>,
    C-CONT.HCONS #hcons & <! [ HARG #5,
			       LARG #6] !>  ].


; be revised on model of subject-presentational-passive
;                                                           CONT.HOOK.INDEX #3 & expl-ind  ]
io-presentational-passive := passive-lexeme &
  [ SYNSEM  [ LOCAL.CAT ditrans-cat & [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                                           CONT.HOOK.INDEX #3 & ref-ind  ],
                                           DOBJECT.LOCAL [CAT.HEAD.DEF -,
                                                          CONT.HOOK.INDEX #2,
                                                          CAT.HEAD.PRESENTED +],
                                           IOBJECT.LOCAL [CONT.HOOK.INDEX #4]],
                                     VAL.COMPS < #iobject & [], #dobject & [] >,
                                     VAL.ICOMPS #icomps  ],
              LOCAL.CONT.HOOK.XARG #3 ],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL [ COMPS < #iobject & [ LOCAL.CONT.HOOK.INDEX #4 ], #dobject & [ LOCAL.CONT.HOOK.INDEX #2 ] >,
                                      ICOMPS #icomps ],
                                QVAL.IOBJECT #iobject,
                                QVAL.DOBJECT #dobject ],
             SYNSEM.LKEYS.KEYREL [ARG1 #1,
                                  ARG2 #2,
                                  ARG3 #4],
             SYNSEM.LOCAL.CONT.HOOK.XARG #1 ]>].




passive-obl := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
                                    LOCAL.CAT.HEAD poss-subj-head ] >,
                           ICOMPS < [LOCAL.CAT.VAL.COMPS <>,
                                     LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 & fct-pass-spec ],
                                     LOCAL.BINDING.BOUND -,
                                     LOCAL.DERIVED-HEAD +,
                                     LOCAL.CONT.HOOK.VARG #5,
                                     LOCAL. CONT.HOOK.LTOP #lbl]. #1 >,
                           COMPS #3 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    SYNSEM.VAL-CLASS #vc,
    ARGS < [ SYNSEM.LOCAL.CAN-PASSIVIZE +,
	     SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    ICOMPS < [LOCAL.CAT.QVAL.DOBJECT[ LOCAL.CONT.HOOK.INDEX #5],
                                              LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 ],
                                              LOCAL.BINDING.BOUND -,
                                              LOCAL. CONT.HOOK.VARG #5,
                                              LOCAL. CONT.HOOK.LTOP #lbl ]. #1 >,
                                    COMPS #3 ],
	     SYNSEM.VAL-CLASS #vc  ] >].

; to be constructed (shaped from an io and an obl version
;                                               CONT.HOOK.INDEX expl-ind  ]

presentational-obl-passive := passive-lexeme &
  [ SYNSEM  [ LOCAL.CAT [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                               CONT.HOOK.INDEX ref-ind  ],
                               OBL1[LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5] >,
                                    LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 & fct-actv-spec ],
                                    LOCAL.BINDING.BOUND -]]],
              LOCAL.CAT.VAL.COMPS #3,
              LOCAL.CAT.VAL.ICOMPS #7],
    SYNSEM.NON-LOCAL.SLASH <! !>,                                   
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM.VAL-CLASS #vc,
    ARGS < [ SYNSEM.VAL-CLASS #vc,
	     SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    ICOMPS < [LOCAL.CAT.QVAL.DOBJECT[ LOCAL.CONT.HOOK.INDEX #5],
                                              LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 ],
                                              LOCAL.BINDING.BOUND - ] >,
                                    COMPS #3,
                                    ICOMPS #7]  ]>].


; most likely one needs a KEYS.KEY specification to restrict this to only be used in connection with pass-obl
; ,                      KEYS.KEY fct-pass-spec

;; MHS 100713 Had to add no-slash due to SLASH shenanigans in sentences such as "gutten tar stien mot fjellet"
prep-word-sel-red := reg-mod-lex-item & word-to-word-rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #mod ] >,
     SYNSEM.LKEYS.KEYREL [ ARG1 #mod ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,; in order to prevent head-filler-subord-wh-phrase from taking this reduced PP as NON-HEAD-DTR in "jeg vet om du kommer".
     SYNSEM.LOCAL.CONT.HOOK.XARG #mod, ; compensating for change to reg-mod-lex-item - see type
     SYNSEM arg2-qvalcomps-synsem & [LOCAL [CAT [HEAD #3 & prep-ultra & [ KEYS.KEY #4 ] ],
                                           XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL [ CONT.HOOK.VARG #2,
		   CONT.HOOK.LTOP #lbl],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd,
    SYNSEM.LOCAL.CAT.HEAD [SELECTED +,
                           KEYS.KEY fct-pass-spec,
                           MOD < [ LOCAL.CONT.HOOK.INDEX.SORT referential-thing ]>],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    ARGS < prep-word-sel & [ SYNSEM.LOCAL [ CONT.HOOK.VARG #2,
					    CONT.HOOK.LTOP #lbl ],
                             SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #4 & fct-spec,
                             SYNSEM.LKEYS.KEYREL arg12-relation & [LBL #lbl,
								   ARG2 #2 ] ] >,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>  ].


; seemed necessary earlier on




obj-del-cum-dir-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CONT.HOOK.DIRARG #3,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM trans-arg1-2dir-synsem,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3 ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CONT.HOOK.DIRARG #3,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED - ].


#|
obj-del-cum-dir-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CONT.HOOK.VARG #3,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep-or-adv,
                                   LOCAL.CONT.HOOK.XARG #3 ] >,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM trans-arg1-2dir-synsem,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3 ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #3].
|#

obj-del-stnd-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3 & ref-ind,
				       LOCAL.CAT.HEAD nom,
				       LOCAL.BINDING.REFL-I - ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    DTR.SYNSEM.LKEYS.KEYREL.ARG2 #3,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED - ].

obj-del-ditr-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #4 >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < #4, [ LOCAL.CONT.HOOK.INDEX #3 ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    DTR.SYNSEM.LKEYS.KEYREL.ARG2 #3,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED - ].


; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
particle-shift-lexeme := const-ltol-rule & verb-general-lexeme &
  [ SYNSEM.LOCAL.CAT.HEAD #head & verb,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #scpr, #np >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.CONT #cont,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED +,
    SYNSEM.LOCAL.CAN-PASSIVIZE -,
    SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
    C-CONT.RELS <!!>,
    C-CONT.HCONS <!!>, 
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD #head & verb,
	     SYNSEM.LOCAL.CAN-PASSIVIZE -,
	     SYNSEM.LOCAL.KEY-SPEC #1,
	     SYNSEM.LOCAL.CAT trans-ncomps-secpred-cat,
	     SYNSEM. LOCAL.CAT.VAL.COMPS < #np & [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing],
						  LOCAL.BINDING [ LEX-TAME - ]], 
					   #scpr & [ LOCAL.CAT.HEAD adv,
						     LOCAL.CONT.HOOK.LTOP #2,
						     LOCAL.DERIVED-HEAD -,
						     LOCAL.CAT.HEAD [ KEYS.KEY #1],
						     LOCAL.CONT.HOOK.XARG #5 ] >,
	     SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps & <>,
	     SYNSEM.LOCAL.CONT #cont,
	     SYNSEM.LOCAL.CAN-MAL-INFIN-INSERT #malinf,
	     SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED -,
	     SYNSEM.LKEYS.KEYREL.ARGX #2 ] >].


;maybe to be abandoned, since directionals are treated as adjuncts
directional-shift-lexeme := const-ltol-rule & verb-general-lexeme &
  [ SYNSEM.LOCAL.CAT.HEAD #head & verb,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY dir],
				   LOCAL.CONT.HOOK.LTOP #2,
				   LOCAL.DERIVED-HEAD -,
				   LOCAL.WH-EXTRACTION-APPLIED -,
				   LOCAL.CAT.HEAD [ KEYS.KEY #1],
				   LOCAL.CONT.HOOK.XARG #5 ],
				 #np >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.CONT #cont,
    SYNSEM.LKEYS.KEYREL.ARGX #2,
    EXTRACTED-FROM -,
    SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED +,
    SYNSEM.LOCAL.CAN-PASSIVIZE -,
    SYNSEM.NON-LOCAL.SLASH #slash,
    C-CONT.RELS <!!>,
    C-CONT.HCONS <!!>, 
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD #head,
	     SYNSEM.LOCAL.CAN-PASSIVIZE -,
	     SYNSEM.LOCAL.KEY-SPEC #1,
	     SYNSEM.LOCAL.CAT trans-nosecpred-empty-icomps-cat,
	     SYNSEM. LOCAL.CAT.VAL.COMPS < #np & [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing]] >,
	     SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps & <>,
	     SYNSEM.LOCAL.CONT.HOOK dir-hook,
	     SYNSEM.LOCAL.CONT #cont,
	     SYNSEM.NON-LOCAL.SLASH #slash,
	     EXTRACTED-FROM -,
	     SYNSEM.LOCAL.PARTICLE-SHIFT-APPLIED - ] >].


#|

INFLECTION #infl,
  SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4 ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
  ARGS < [ INFLECTION #infl,
           SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
                                  VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
                                        SPR #spr ] ] ],
                    LKEYS #keys,
                    NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
  C-CONT.RELS <! !> ].

passive-ncomps1-sup := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #5,
                                    LOCAL.CAT.HEAD poss-subj-head  & [KEYS.KEY #kk],
				    LOCAL.CAT.HEAD.EXPLETIVE #expl] >, ;not a lower type, to enable rel-pron as subject.
                           COMPS #1,
                           ICOMPS #3 ],
;    SYNSEM.LOCAL.CONT.HOOK [XARG #5],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ #bool,
;    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    SYNSEM.VAL-CLASS #vc,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
                                              LOCAL.CAT.HEAD np-head & [KEYS.KEY #kk,
									EXPLETIVE #expl],
                                              LOCAL.BINDING.BOUND - ]. #1 >,
                                    ICOMPS #3 ],
             SYNSEM.VAL-CLASS #vc,
	     SYNSEM.LOCAL.CAN-PASTPART-ADJ #bool ] >].
|#



;;;;;;;;;; FOR-NONHEADED NPÓ´û

presparticpl-adj-lxm := adj-lxm & infl-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE prespartcpl,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    ARGS < verb-general-lexeme & [SYNSEM [LOCAL.CONT.HOOK.XARG #1,
					  LOCAL.CAT.HEAD.VOICE active,
					  LOCAL.CAT.VAL [ICOMPS <>,; not clear why <>
							 COMPS <>,; not clear why <>
							 SPR <>,; not clear why <>
							 SPEC <>]]] >,; not clear why <>
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].

pastparticpl-adj-word-sup := adjectival-word & word-to-word-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg,
;    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #key,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY propt, ; to avoid being analysed as tough-adj
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.AGR #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -, ; to prevent absurd noun formations
    SYNSEM.NON-LOCAL #nl,
    ARGS <  infl-perf-part-verb-word & 
            [SYNSEM.LOCAL.CAT.HEAD.VOICE voice,
 ;            SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #key,
	     SYNSEM.LOCAL.CAN-PASTPART-ADJ +,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
	     SYNSEM.LOCAL.CONT.HOOK #2,
	     SYNSEM.NON-LOCAL #nl ] >,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].

pastparticpl-adj-word := pastparticpl-adj-word-sup & adjective-word-2 &
 [ ARGS <  [SYNSEM.LOCAL.CAT.HEAD.VOICE passive] > ].

wk-pastpt-adj-word := pastparticpl-adj-word & infl-wtow-rule &  
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD np-head & [DEF + ],
                                   LOCAL.CAT.VAL.SPR < [] > ] >,
                            WEAK +,
                            DEGREE positive ]].

str-pastpt-adj-word := pastparticpl-adj-word &
  [ SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +,
    SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD np-head & [DEF bool , ; from '-', to accommodate "gutten skutt av Ola"
                                                          DEFINITE bool]]>,
                            WEAK -,
                            DEGREE positive ]].
                                    
strsg-pastpt-adj-word := str-pastpt-adj-word & const-wtow-rule &			 [ SYNSEM.LOCAL.AGR.PNG.NG sg ].    
strpl-pastpt-adj-word := str-pastpt-adj-word & infl-wtow-rule &			 [ SYNSEM.LOCAL.AGR.PNG.NG pl ].

pastparticpl-from-active-adj-word := pastparticpl-adj-word-sup & adjective-word &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED +,
   ARGS <  [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY resultvb,
	    SYNSEM.LOCAL.CAT.HEAD.VOICE active] > ].

wk-pastpt-from-active-adj-word := pastparticpl-from-active-adj-word & infl-wtow-rule &  
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD np-head & [DEF + ],
                                   LOCAL.CAT.VAL.SPR < [] > ] >,
                            WEAK +,
                            DEGREE positive ]].


; not utilized
;non-headed-np-phrase := phrasal &
;  [ SYNSEM.LOCAL.CAT.HEAD np-head,
;    SYNSEM.LOCAL.CONT.RELS #2 ,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adj,
;             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;             SYNSEM.LOCAL.CONT.RELS #2 ] >,
;    C-CONT.RELS <! !>,
;    C-CONT.HCONS <! !> ].

mod-to-n-rule := const-wtow-rule & noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LKEYS.KEYREL.LBL #4,
    SYNSEM.CAN-WTOW -,
    SYNSEM.LOCAL.CAT.HEAD np-head,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    SYNSEM.LKEYS.KEYREL #5,
    SYNSEM.LOCAL.DERIVED-HEAD bool,
    SYNSEM.NON-LOCAL #nonloc,
    DTR word & 
        [ SYNSEM.CAN-WTOW +,
;          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
 ;         SYNSEM.LOCAL.CONT.HOOK.XARG #1,
          SYNSEM.LKEYS.KEYREL #5,
          SYNSEM.LOCAL.CONT[ RELS [ LIST #first,
				    LAST #middle ],
			     HCONS [ LIST #scfirst,
				     LAST #scmiddle ] ],
	  SYNSEM.NON-LOCAL #nonloc],
    C-CONT[ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ] ].

event-to-n-rule := const-wtow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LOCAL.CONT.HOOK.INDEX super-event,
    SYNSEM.LKEYS.KEYREL.LBL #4,
    SYNSEM.CAN-WTOW -,
    SYNSEM.LOCAL.CAT.HEAD np-head,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    SYNSEM.LKEYS.KEYREL #5,
    SYNSEM.LOCAL.DERIVED-HEAD bool,
    SYNSEM.NON-LOCAL #nonloc,
    DTR word & 
        [ SYNSEM.CAN-WTOW +,
 	  SYNSEM.LKEYS.KEYREL #5,
          SYNSEM.LOCAL.CONT[ RELS [ LIST #first,
				    LAST #middle ],
			     HCONS [ LIST #scfirst,
				     LAST #scmiddle ] ],
	  SYNSEM.NON-LOCAL #nonloc],
    C-CONT[ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ] ].




; removed 'adjective-word & 
;        '
; so that also apply to superlatives
; have changed from DEFINITE #3 to DEF #3
adj-to-n-rule := mod-to-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.HEAD [ DEF #3,
                            DEFINITE -,
                            EXPLETIVE -,
                            KEYS.KEY absnoun ],
    SYNSEM.LOCAL.CAT.VAL.SPEC #4,
    SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    SYNSEM.NON-LOCAL #nl,
    INFL-MORPH #6,
    DTR [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK #3,
                                            KEYS.KEY propt ],
          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CAT.HEAD adj, ; & [DEGREE positive],
          SYNSEM.LOCAL.CONT.HOOK.XARG #1,
          SYNSEM.LOCAL.CAT.VAL.SPEC #4,
          SYNSEM.LOCAL.CAT.POSTHEAD #ph,
	  SYNSEM.LOCAL.MAL-INFLECT-LEEWAY +, ;to avoid feeding from mal-rules randomly applying
	  SYNSEM.NON-LOCAL #nl,
	  INFL-MORPH #6 ]].

#|
verb-to-n-rule := mod-to-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.HEAD [ DEFINITE -,
                            EXPLETIVE - ],
    SYNSEM.NON-LOCAL #nl,
    DTR nominalized-ing-verb-word &
	[ SYNSEM.LOCAL.CAT.HEAD verb,
	  SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
          SYNSEM.NON-LOCAL #nl ]].
|#

verb-to-n-rule := event-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel" ]!>,
    C-CONT.HCONS <! [ HARG #2,
		      LARG #3 ] !>,
;    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[]>,
;    SYNSEM.LOCAL.CAT.HEAD [ DEFINITE -,
;                            EXPLETIVE - ],
    DTR nominalized-ing-verb-word &
	[ SYNSEM.LOCAL.CAT.HEAD verb,
;	  SYNSEM.LOCAL.CAT.VAL #val,
	  SYNSEM.LOCAL.CONT.HOOK.XARG #1 ]].


; omitted ,
;                       AGR.PNG.NG pl  in DTR spec
adj-to-bare-n-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel" ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <>,
		       POSTHEAD #ph],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.SUBJ-ONLY #5,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ +,
    DTR.SYNSEM.LOCAL [ DERIVED-BARE-N-FROM-ADJ +,
		       SUBJ-ONLY #5,
		       CAT.POSTHEAD #ph,
;		       CAT.HEAD.KEYS.KEY color,  LH050214: allowed 'gule sover' but prohibited 'snille sover', which is not rational (or correct) - it was a means to reduce parseforest
		       CONT.HOOK.LTOP #3 ] ].


#|
; duplicate
adj-to-bare-n-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3 ].
|#


adj-to-n-cum-quantifier-rule := adj-to-n-rule &
  [ C-CONT.RELS <! arg0-relation & [ LBL #3,
				     ARG0 #1,
				     PRED "_uspec-entity_n_rel" ]!>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg,
    SYNSEM.LOCAL.CAT [ VAL.SPR < [LOCAL.CAT.HEAD quant] > ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR.SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg].

adj-to-n-cum-indefarticle-rule := adj-to-n-rule &
  [ C-CONT.RELS <! arg0-relation & [ LBL #3,
				     ARG0 #1,
				     PRED "_uspec-entity_n_rel" ]!>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ VAL.SPR < [LOCAL.CAT.HEAD art] > ],
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR.SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg].

adj-to-n-cum-defdem-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_def_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
			      ARG0 #1,
			      PRED "_uspec-entity_n_rel" ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
;    SYNSEM.LOCAL.CAT.HEAD adj,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       VAL.SPR < [LOCAL.CAT.HEAD det] > ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #3 ],
    DTR.SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg ].

adj-to-n-cum-card-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_def_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
			      ARG0 #1,
			      PRED "_uspec-entity_n_rel" ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       VAL.SPR < [LOCAL.CAT.HEAD card] > ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #3 ],
    DTR.SYNSEM.LOCAL.CAT.HEAD.DEGREE #deg ].


; the specification 'SORT referential-thing' blocks "to egg" from 
; meaning 'two dozens of egg'. 
;removed from DTR:  SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
;          
; there is some overlap between these types, applying to words, and
; the subsumption of cardnum and noun under card-nom, designed for complex
; cardinals like in "kommer tjue tretti" 'comes (at) 20.30'
card-to-bare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel"] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK hook & [XARG #1 & [ WH -]],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR cardinal-word & 
        [ SYNSEM.LOCAL.CAT.HEAD cardnum,
          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CONT.HOOK.XARG #1,
	  SYNSEM.LOCAL.CARD-TO-BARE-N +] ].

;;;

card-to-n-cum-defdem-rule := mod-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel"] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK hook & [XARG #1 & [ WH -]],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       HEAD.BARE +,
                       VAL.SPR < [LOCAL.CAT.HEAD det]> ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR cardinal-word & 
        [ SYNSEM.LOCAL.CAT.HEAD cardnum,
          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CONT.HOOK.XARG #1] ].
;;;
card-to-nonbare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CAT [ VAL.SPR < expressed-synsem >,
                       VAL.SPEC <>],
;    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX.PNG.PERS #1],
;    SYNSEM.LOCAL.CARD-TO-NONBARE-N +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR word & lbl-ltop-lex-item & 
        [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CAT.HEAD cardnum ]].


card-to-name-of-card-rule := mod-to-n-rule &
  [ C-CONT.RELS <! def-q-rel & [ PRED "_def_q_rel",
                                   ARG0 #4,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #4,
				   PRED "_name-of-card_n_rel"] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH -,
					SORT referential-thing],
;    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY name-of-card, ; comment out, to enable 'd√∏de i 1030'
    SYNSEM.LOCAL.CONT.HOOK hook & [XARG.PNG.PERS #1,
				   XARG.PNG.NG sg],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
;    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       HEAD.BARE +,
                       VAL.SPR <>,
		       HEAD.KEYS.KEY predsort],; KEYS.KEY #kk comment out, to enable 'd√∏de i 1030'
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR cardinal-word & 
        [ SYNSEM.LOCAL.CAT.HEAD cardnum & [KEYS.KEY predsort],; KEYS.KEY #kk comment out, to enable 'd√∏de i 1030'
          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.PERS #1] ].

; motivated mainly by "andre" as in "andre kommer"; so perhaps rather a special lexical entry for "andre" for such uses
ord-to-bare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ WH -],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ SORT referential-thing ],
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N +,
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR sign & 
        [ SYNSEM.LOCAL.CAT.HEAD adj,
          SYNSEM.LOCAL.CAT.HEAD adj & [DEGREE positive],
          SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ]].

; SYNSEM.LOCAL.POSSPRON-TO-BARE-N + in order to forestall 'apposition-rule' in "tredje juni"
ord-to-nonbare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CAT [ VAL.SPR < [] > ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ SORT referential-thing ],
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N +,
    DTR sign & 
        [ SYNSEM.LOCAL.CAT.HEAD adj & [DEGREE positive],
          SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY propt,
	  SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ]].





spec-to-n-rule := const-wtow-rule & noun-word & rule  & SLASH-cons-lrule &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LKEYS.KEYREL.LBL #4,
    SYNSEM.CAN-WTOW -,
    SYNSEM.LOCAL.CAT.HEAD np-head,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LKEYS.KEYREL #5,
    C-CONT[ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ],
    SYNSEM.LOCAL.CAT.HEAD [ DEFINITE -,
                            DEF  #bool ],
    SYNSEM.LOCAL.CAT [ VAL [COMPS <>,
                            SPEC <> ]],
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH -,
                                   SORT referential-thing ],
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.DERIVED-HEAD bool,
    DTR   [ SYNSEM.CAN-WTOW +,
            SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.DEF #bool ] >,
                  SYNSEM.LKEYS.KEYREL #5,
                  SYNSEM.LOCAL.CONT[ RELS [ LIST #first,
                                            LAST #middle ],
                                     HCONS [ LIST #scfirst,
                                             LAST #scmiddle ] ]]].

spec-to-bare-n-rule := spec-to-n-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [SPR < >]]].

spec-to-nonbare-n-rule := spec-to-n-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [SPR < [] >]]].

; 'absnoun' to make sure the N is not mistaken as a relational noun, with "av" in ingen av guttene' getting extra parses
; omitted  '& [ SORT full-thing ]' on top line, to get 'leste litt om Trondheim'
indefquant-to-bare-n-rule := spec-to-bare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #3 ] >,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,                          
    C-CONT.HCONS <!  !>,
    C-CONT.RELS <! [PRED "_pron_rel",
                    LBL #3,
                    ARG0 #1] !> ].

; SYNSEM.LOCAL.CARD-TO-BARE-N + in order for apposition-rule to not produce "hver gutt"
indefquant-to-nonbare-n-rule := spec-to-nonbare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ SORT referential-thing ]],
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    DTR.SYNSEM.LOCAL.CAT.HEAD q,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #3 ] >,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,                          
    C-CONT.HCONS <!  !>,
    C-CONT.RELS <! [PRED "_pron_rel",
                    LBL #3,
                    ARG0 #1] !> ].


posspron-to-bare-n-rule := spec-to-bare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK [INDEX #1 ],    
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N +,
    RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    DTR.SYNSEM.LOCAL.BINDING [ REFL-I -, REFL-II - ],
    C-CONT [ RELS <! poss-rel & [ ARG1 #2,
                                  ARG2 #1], def-q-rel & [ ARG0 #1,
                                                          RSTR #6 ], 
		   [PRED "_pron_rel",
                    LBL #7,
                    ARG0 #1]  !>,
             HCONS <! [HARG #6,
                       LARG #7] !>] ].

posspron-to-nonbare-n-rule := spec-to-nonbare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK [INDEX #1,
                            LTOP #7 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    DTR [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
          SYNSEM.LOCAL.CAT.VAL.COMPS < >,
          SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind, 
          SYNSEM.LOCAL.CAT.HEAD posspron,
          SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8],
    C-CONT [ RELS <! poss-rel & [ ARG1 #2,
                                  ARG2 #1], def-q-rel & [ ARG0 #1,
                                                          RSTR #6 ]  !>,
             HCONS <! [HARG #6,
                       LARG #7] !>]  ].

;; personal names [FIXME]

firstname_m_le := mascsg-proper-name-word.
firstname_f_le := femsg-proper-name-word.
etternavn_le := proper-name-word.


; For verbs, most of the inflectional effects are introduced at word level. The values under verb_inflection are inscribed under INFL-MORPH (which is a sign feature). The 'governing' phonological properties could have been given under INFLECTION, since they are lexeme properties - and INFLECTION and INFL-MORPH need not be coindexed. However, in the long run that may seem natural - so ideally, the feature PHON should house the relevant specification of infinitive 'stem' forms. For now, though, we try with INFLECTION as housing info that somehow affects the choice of inflectional rules - that is consistent with design so far.

; moved back from matrix.tdl
phon := inflection.
non-phon := inflection.

; just for immediate troll-purposes
proprium := inflection.

finstr := phon.
finstr-dd := finstr.
finstr-tt := finstr.
finstr-mm := finstr. ; short vowel, prim or sec stress
finstr-norm := finstr. ; short vowel, prim or sec stress
finstr-strong := finstr.

nonfstr := phon.
nonfstr-ic := phon.

;; Introduced to make a distinction between "-et", "-de" and "-te"-verbs. EAA. 050711  LH131015 adding for 'et_or_de'
;; The type nonfstr-strong is implemented to make sure that strong verbs only follow strong patterns.
nonfstr-et_or_de := nonfstr.
nonfstr-et_or_te := nonfstr.
nonfstr-de := nonfstr-et_or_de.
nonfstr-strong := nonfstr.

nonfstr-et := nonfstr-et_or_te & nonfstr-et_or_de.
nonfstr-te := nonfstr-et_or_te.


;; for nouns
;; if neut: infl_nlong or infl_nshort

; moved to matrix.tdl
;inflection := sort.

; see out.txt.new - nominal features to noun_inflection
;inflection := sort &
;[GEND gen, NUMB num, DEFINITENESS definiteness, MK *top*].

definiteness := *top*.
ind := definiteness.
def := definiteness.


nominal_inflection := inflection &
[GEND gen, NUMB num, MK *top*].

noun_inflection := nominal_inflection &
[DEFINITENESS definiteness].

;infl_mabbrev := noun_inflection. [unused]

infl_m_f := noun_inflection.

infl_m_nshort := noun_inflection.
infl_m_fshort := final-full-long-or-short.

infl_m :=  infl_m_nshort & infl_m_fshort & [GEND m].
infl_f :=  infl_m_fshort & [GEND f].
infl_n := noun_inflection & [GEND n].
infl_nlong := infl_n.
infl_nshort := infl_n & infl_m_nshort.

;final-full-mm := noun_inflection.
;final-full := noun_inflection.
light-e-sup := noun_inflection.

; for m & f nouns
final-full-mm := infl_m_f.
final-full-long-or-short := infl_m_f.
final-full := final-full-long-or-short.
infl_mshort := infl_m.
infl_fshort := infl_f.
light-e-mf-sup := infl_m_f & light-e-sup.
light-e := light-e-mf-sup.
light-e-short := light-e-mf-sup.
; for plural nouns part of collocations or otherwise normally plural - just as a mark
light-e-ic := noun_inflection.
; for def-sg nouns part of collocations or otherwise normally definite - just as a mark
finalfull-ic := inflection.
title-ic := inflection.
xx := inflection.
interj := inflection.
subst_fork-t := non-phon.
subst_fork := non-phon.
konj_fork := non-phon.
adj_fork := non-phon.

; for neuter nouns
final-full-mm-nshort := infl_nshort & final-full-mm.
final-full-mm-nlong := infl_nlong & final-full-mm.
final-full-nshort := infl_nshort & final-full-n.
final-full-nlong := infl_nlong & final-full-n.
; where both long and short is allowed
final-full-n := final-full & infl_n.

light-e-nshort := light-e-sup & infl_nshort.
light-e-nlong := light-e-sup & infl_nlong.

;;;;;;;;;;;;;;;;


verb_inflection := inflection &
[ TEMPUS tense, MODUS mood, DIATHESIS voice ].


adjective_inflection := nominal_inflection &
[ WEAKFORM bool,
  DEG degree ].


; first rule deletes first np on COMPS list: i.e., an np, preceded by nothing.
; so, it applies also to io in dobleobj
; second rule deletes both nps on COMPS list: i.e., two nps, preceded by nothing.
; so, no iteration of the first rule
deriv-pot := avm &
  [ CAN-OBJ-DEL bool,
    CAN-DOUBL-OBJ-DEL bool].

; datter
kinship-status := class.
; nabo
sociofunct-status := class.
; fot
phys-part-of-status := class.
; hovedstad
role-in-system-status := class.
; halvdel, delmengde
role-in-partition-status := class.
; inntrykk, resultat
role-in-situation-status := class.


; discourse
; moved to matrix
;discmode := sort.
single-developer := discmode.
presented-developer := discmode.
interact-developer := discmode.
scenic-developer := discmode.
question := discmode.
response := discmode.
added-info := discmode.

disc-add-phrase := basic-head-mod-phrase-simple & head-final &
   [ DISC-MODE #2 & discmode,
     SYNSEM.LOCAL.CAT.VAL [SUBJ antilist,
			   COMPS <>,
			   SPR <>,
			   SPEC <>],
     SYNSEM.LOCAL.CAT.QVAL #qval,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE #2,
     SYNSEM.NON-LOCAL.SLASH <! !>,
     SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    ARGS < [], [ SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
		  SYNSEM.LOCAL.CAT.QVAL #qval ] > ].

disc-firstadd-phrase := disc-add-phrase &
   [ ARGS < period-mod-phrase, 
	  period-mod-phrase > ].

disc-secondadd-phrase := disc-add-phrase &
   [ ARGS < disc-add-phrase, 
	  period-mod-phrase > ].

disc-firstsingdeveloper-phrase := disc-firstadd-phrase &
   [ DISC-MODE single-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL intrans-qval & [SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ]], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron]]> ].
disc-mediasresdeveloper-phrase := disc-firstadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p]], 
		  [ PRED "coreferential_rel",
		      ARG1 #3 & [PNG.PERS #q],
		      ARG2 #4 & [PNG.PERS #q]] !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
	      SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #3 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #4,
						  CAT.HEAD pers-pron,
						  CTXT pron-discbnd ]]> ].

disc-presentdeveloper-phrase := disc-firstadd-phrase &
   [ DISC-MODE presented-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED +,
	      SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 ], 
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron],
	      SYNSEM.LOCAL.CAT.HEAD.INV - ]> ].

disc-scenedeveloper-pres-phrase := disc-firstadd-phrase &
   [ DISC-MODE scenic-developer,
     C-CONT.RELS <! !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED + ], 
	    [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED + ]> ].

disc-scenedeveloper-reg-phrase := disc-firstadd-phrase &
   [ DISC-MODE scenic-developer,
     C-CONT.RELS <! !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED + ], 
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD noun,
	      SYNSEM.LOCAL.CAT.HEAD.INV - ] > ].

disc-secondsingdeveloper-phrase := disc-secondadd-phrase &
   [ DISC-MODE single-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ DISC-MODE single-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron]]> ].

disc-secondpresdeveloper-phrase := disc-secondadd-phrase &
   [ DISC-MODE single-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ DISC-MODE presented-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron]]> ].

disc-secondscenedeveloper-pron-phrase := disc-secondadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ], 
		  [ PRED "coreferential_rel",
		      ARG1 #3 & [PNG.PERS #q],
		      ARG2 #4 & [PNG.PERS #q] ] !>,
     ARGS < [ DISC-MODE scenic-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
	      SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #3 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #4,
						  CAT.HEAD pers-pron,
						  CTXT pron-discbnd ]]> ].

disc-secondscenedeveloper-reg-phrase := disc-secondadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! !>,
     ARGS < [ DISC-MODE scenic-developer ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD noun & [DEF +],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD noun & [DEF +]]> ].

disc-secondscenedeveloper-mix-phrase := disc-secondadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #3 & [PNG.PERS #p],
		      ARG2 #4 & [PNG.PERS #p] ] !>,
     ARGS < [ DISC-MODE scenic-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #3 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #4,
						  CAT.HEAD pers-pron ]]> ].

; det ligger en mann i sengen. han smiler. han sover.
; en mann ligger i sengen. han smiler. han sover.
; det kom en gutt. han sitter n√• i stolen.
; #det kom en gutt. det ligger en mann. [scenic]
; #det kom en gutt. gutten sitter i stolen. [scenic]
; *det kom en gutt. I stolen sitter han.
; det kommer en gutt. mannen v√•kner. han ser ham.
; det kommer en gutt. mannen v√•kner. mannen ser gutten.
; det kommer en gutt. mannen v√•kner. mannen ser ham.
; *det kommer en gutt. mannen v√•kner. han ser mannen.
; Kari ser Ola. Hun unng√•r ham.
; *Kari ser Ola. Jeg unng√•r ham.

disc-shortcontinuation-phrase := basic-head-mod-phrase-simple & head-initial &
   [ SYNSEM.LOCAL.CAT.VAL [SUBJ antilist,
			   COMPS <>,
			   SPR <>,
			   SPEC <>],
     SYNSEM.LOCAL.CAT.QVAL #qval,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE #2,
     SYNSEM.NON-LOCAL.SLASH <! !>,
     SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
	      SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE #2,
	      SYNSEM.LOCAL.CAT.QVAL #qval ], 
	    [  ] >,
     C-CONT.HCONS <! !> ].

disc-shortresponse-phrase := disc-shortcontinuation-phrase &
   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE question ].

disc-shortaddedinfo-phrase := disc-shortcontinuation-phrase &
   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE added-info ].

disc-shortphr-subj-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +],
	      SYNSEM.LOCAL.CONT.HOOK.XARG #1 ], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-obj-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +],
	      SYNSEM.LOCAL.CONT.HOOK.VARG #1 ],
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-obl-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +] ]], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-auxembobj-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +],
	      SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.VARG #1 ], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-auxembobl-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +] ]], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-subj-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
	      SYNSEM.LOCAL.CONT.HOOK.XARG #1 ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-obj-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
	      SYNSEM.LOCAL.CONT.HOOK.VARG #1 ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-obl-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -] ] ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-auxembobj-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
	      SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.VARG #1 ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-auxembobl-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -] ] ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

parenthesis-opener := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD parenthesis,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY start-parenth,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #1,
				  LOCAL.CAT.VAL.COMPS <>,
				  LOCAL.CAT.VAL.SUBJ <>,
				  LOCAL.CAT.VAL.SPR < >,
				  LOCAL.CAT.VAL.SPEC <>,
				  LOCAL.CAT.VAL.ICOMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD.KEYS.KEY end-parenth ] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "parenthetical_rel",
    SYNSEM.LKEYS.KEYREL arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HCONS <! !>].

parenthesis-closer := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD parenthesis,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY end-parenth,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "end-parenthetical_rel",
    SYNSEM.LOCAL.CONT.HCONS <! !>].

quotation-opener := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD quotation-mark,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY start-quote,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #1,
				  LOCAL.CAT.VAL.COMPS <>,
				  LOCAL.CAT.VAL.SUBJ <>,
				  LOCAL.CAT.VAL.SPR < >,
				  LOCAL.CAT.VAL.SPEC <>,
				  LOCAL.CAT.VAL.ICOMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD.KEYS.KEY end-quote ] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "quotation_rel",
    SYNSEM.LKEYS.KEYREL arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HCONS <! !>].

quotation-closer := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD quotation-mark,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY end-quote,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "end-quotation_rel",
    SYNSEM.LOCAL.CONT.HCONS <! !>].


clause :+ 
[ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].


;; EAA 300711: These types has been passed over from mal-types,
;; as NorSource types inherit from these.

var-m_noid-basic-head-mod-phrase-simple := basic-head-mod-phrase-simple-sup.

var-m_noid-head-mod-phrase-simple := head-mod-phrase-simple-sup & var-m_noid-basic-head-mod-phrase-simple.

var-m_noid-adj-head-phrase := adj-head-phrase-sup & var-m_noid-head-mod-phrase-simple &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD #head ] >, 
    C-CONT.RELS <! !>  ].

var-cc_opn-adj-head-phrase := adj-head-phrase-sup & head-mod-phrase-simple & 
[ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
  NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD #head ] > ].

var-cc_opn-m_noid-adj-head-phrase := adj-head-phrase-sup & var-m_noid-head-mod-phrase-simple.

var-m_noid-a-mod-phrase := a-mod-phrase-sup & var-m_noid-adj-head-phrase &
[C-CONT [RELS <! !>,
         HCONS <! !>]]. 

var-cc_opn-a-mod-phrase := a-mod-phrase-sup & var-cc_opn-adj-head-phrase.

var-cc_opn-m_noid-a-mod-phrase := a-mod-phrase-sup & var-cc_opn-m_noid-adj-head-phrase.


var-m_noid-adjective-mod-phrase := adjective-mod-phrase-sup & var-m_noid-a-mod-phrase.

var-cc_opn-adjective-mod-phrase := adjective-mod-phrase-sup & var-cc_opn-a-mod-phrase.

var-cc_opn-m_noid-adjective-mod-phrase := adjective-mod-phrase-sup & var-cc_opn-m_noid-a-mod-phrase.

;; Mal-addenda that has to touch NorSource proper. (But no adverse effects). EAA010811

adj-no_gd := adj-reg.


;; MHS 100713

SLASH-cons-lrule := lex-rule & 
[ SYNSEM.NON-LOCAL.SLASH #slash,
  DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

;; MHS 160713

no-hcons := sign & 
[ SYNSEM.LOCAL.CONT.HCONS <! !>]. ;; MHS 160713 Consider this a temporary type.


measure-out-prep-word :+ no-hcons.
part-measurenp-prep-word :+ no-hcons.
prep-detachposs-word :+ no-hcons.
part-adj-prep2-word :+ no-hcons.
part-card-prep-word :+ no-hcons.
prep-arg1prop-epon-lxm :+ no-hcons.
part-q-mass-prep-word :+ no-hcons.
part-q-prep-word :+ no-hcons.
part-adj-prep-word :+ no-hcons.
